<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿花花花deCSNotes</title>
  
  
  <link href="https://www.gtxhjh.cn/atom.xml" rel="self"/>
  
  <link href="https://www.gtxhjh.cn/"/>
  <updated>2021-02-19T12:29:12.486Z</updated>
  <id>https://www.gtxhjh.cn/</id>
  
  <author>
    <name>JH</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>volatile与伪共享的理解</title>
    <link href="https://www.gtxhjh.cn/2021/02/19/volatile%E4%B8%8E%E4%BC%AA%E5%85%B1%E4%BA%AB%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://www.gtxhjh.cn/2021/02/19/volatile%E4%B8%8E%E4%BC%AA%E5%85%B1%E4%BA%AB%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2021-02-19T05:47:46.000Z</published>
    <updated>2021-02-19T12:29:12.486Z</updated>
    
    <content type="html"><![CDATA[<p>学习java并发时，了解LongAdder的伪共享时思考，value已经定义为volatile，也就表示直接在主内存中进行操作，那么为什么还存在伪共享呢</p><blockquote><p>首先已知volatile不能保证原子性。比如多个线程读取到最新的值后，在这个值上进行++操作，无法保证原子性，因为++操作在字节码文件中，也分多步</p></blockquote><blockquote><p>普通变量与volatile变量的差别是volatile的特殊规则保证了新值能马上同步到主内存，以及每次使用前能够马上从内存刷新，即一个线程改动了某个变量的值之后，其他线程读取的话肯定能看到新的值 </p></blockquote><h2 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h2><p>那么Volatile是怎样来保证可见性的呢？在x86处理器下通过工具获取JIT编译器生成的汇编指令看看对Volatile进行写操作CPU会做什么事情。 </p><p><img src="/2021/02/19/volatile%E4%B8%8E%E4%BC%AA%E5%85%B1%E4%BA%AB%E7%9A%84%E7%90%86%E8%A7%A3/image-20210219131156934.png" alt="image-20210219131156934"></p><p>volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发人员手冊可知。lock前缀的指令在多核处理器下会引发两件事情 </p><ul><li><strong>将当前处理器缓存行的数据会写回到系统内存。</strong></li><li><strong>这个写回内存的操作会引起在其它CPU里缓存了该内存地址的数据无效。</strong></li></ul><blockquote><p><strong>深度解析：</strong></p><p>处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其它）后再进行操作。但操作完之后不知道何时会写到内存；假设对声明了Volatile变量进行写操作。JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。可是就算写回到内存。假设其它处理器缓存的值还是旧的。再运行计算操作就会有问题，所以<strong>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议</strong>。每一个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行相应的内存地址被改动，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行改动操作的时候，会强制又一次从系统内存里把数据读到处理器缓存里。</p><p>所以说不能说volatile是表示直接在主内存中进行操作，他还是会到缓存行中，只是对应的修改会立刻写回到系统内存，来保证最新，同时让其他CPU缓存了该内存地址的数据缓存行失效</p><p><strong>Lock前缀指令会引起处理器缓存回写到内存</strong>。Lock前缀指令导致在运行指令期间。声言处理器的 LOCK# 信号。在多处理器环境中，LOCK# 信号确保在声言该信号期间。处理器能够独占使用不论什么共享内存。</p><p>（由于它会锁住总线。导致其它CPU不能訪问总线，不能訪问总线就意味着不能訪问系统内存），可是在近期的处理器里，LOCK＃信号一般不锁总线，而是锁缓存。毕竟锁总线开销比較大。在8.1.4章节有具体说明锁定操作对处理器缓存的影响。对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和近期的处理器中，假设訪问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反地，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保改动的原子性，此操作被称为“缓存锁定”，<strong>缓存一致性机制会阻止同一时候改动被两个以上处理器缓存的内存区域数据</strong>。</p><p><strong>一个处理器的缓存回写到内存会导致其它处理器的缓存无效</strong>。</p><p>IA-32处理器和Intel 64处理器使用MESI（改动，独占，共享，无效）控制协议去维护内部缓存和其它处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32 和Intel 64处理器能嗅探其它处理器訪问系统内存和它们的内部缓存。它们使用嗅探技术保证它的内部缓存，系统内存和其它处理器的缓存的数据在总线上保持一致。</p><p>比如在Pentium和P6 family处理器中。假设通过嗅探一个处理器来检測其它处理器打算写内存地址。而这个地址当前处理共享状态，<strong>那么正在嗅探的处理器将无效它的缓存行，在下次訪问同样内存地址时，强制运行缓存行填充。</strong></p></blockquote><p>考虑到volatile的读写会让缓存行失效，那么如果在一个缓存行中存储了多个数据，一旦有已经修改的volatile数据存在，那么这个缓存行就会失效，影响到实际需要读写的另一个数据，导致性能下降，而想到的解决办法就是让一个缓存行只存有一个数据，剩余空间使用字节填充。 </p><p><strong>注意：</strong> 由于使用追加字节的方式须要处理器读取很多其它的字节到快速缓冲区，这<em>本身就会带来一定的性能消耗</em>，共享变量假设不被频繁写的话。锁的几率也很小，就不是必需通过追加字节的方式来避免相互锁定。 </p><h2 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h2><p>讲述volatile原理时也提到了伪共享的问题，其实此处只是伪共享问题的一个方面</p><p><strong>伪共享：</strong>当多个线程同时修改一个缓存行里面的多个变量时，<strong>由于同时只能有一个线程操作缓存行</strong>，所以相比于将每个变量放到一个缓存行，性能会有所下降，这就是伪共享</p><blockquote><p>class {int x ,int y}  x和y被放在同一个快速<strong>缓存</strong>区，假设一个线程改动x；那么另外一个线程改动y，必须等待x改动完毕后才干实施</p><p>CPU缓存系统中是以缓存行（cache line）为单位存储的。目前主流的CPU Cache 的 Cache Line 大小都是64Bytes。在多线程情况下，如果需要修改“<strong>共享同一个缓存行的变量</strong>”，就会无意中影响彼此的性能，这就是伪共享（False Sharing）</p></blockquote><p><strong>每一个cpu核心或者线程都会可能往同一个缓存行写数据；而且对共享变量，同一时候cpu核心会有各自的缓存行 ，当多核CPU线程同一时候改动在同一个快速缓存行各自独立的变量时，会不自不觉地影响性能。这就发生了伪共享False sharing。伪共享是性能的无声杀手。</strong></p><p>解决方案便是将快速缓存剩余的字节填充填满(pad)，确保不发生多个字段被挤入一个快速缓存区 </p><p><strong>总结：</strong>在单个线程下顺序修改一个缓存行中的多个变量，会充分利用程序运行的局部性原则，从而加速了程序的运行。而在多线程下并发修改一个缓存行中的多个变量时就会竞争缓存行，从而降低程序运行性能</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>作者写的很好，其中一些细节本文并未提到，建议参阅</p><footer><strong>https://www.cnblogs.com/mthoutai/p/6766874.html</strong></footer></blockquote><blockquote><footer><strong>https://zhuanlan.zhihu.com/p/286023308</strong></footer></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习java并发时，了解LongAdder的伪共享时思考，value已经定义为volatile，也就表示直接在主内存中进行操作，那么为什么还存在伪共享呢&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先已知volatile不能保证原子性。比如多个线程读取到最新的值后，在这个值上</summary>
      
    
    
    
    <category term="Java并发" scheme="https://www.gtxhjh.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://www.gtxhjh.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="多线程" scheme="https://www.gtxhjh.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="伪共享" scheme="https://www.gtxhjh.cn/tags/%E4%BC%AA%E5%85%B1%E4%BA%AB/"/>
    
    <category term="volatile" scheme="https://www.gtxhjh.cn/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>第三章_3-本地方法栈、本地方法接口</title>
    <link href="https://www.gtxhjh.cn/2021/02/10/JVM-3-3/"/>
    <id>https://www.gtxhjh.cn/2021/02/10/JVM-3-3/</id>
    <published>2021-02-10T14:16:37.000Z</published>
    <updated>2021-02-10T14:20:24.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h2><p><img src="/2021/02/10/JVM-3-3/image-20210210211122300.png" alt="image-20210210211122300"></p><ol><li>简单地讲，<strong>一个==Native Method==是一个Java调用非Java代码的接囗</strong>一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。</li><li>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</li><li>在定义一个native method时，并<strong>不提供实现体</strong>（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</li><li><strong>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序</strong></li></ol><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外，不代表抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IHaveNatives</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native4</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="为什么要使用-Native-Method？"><a href="#为什么要使用-Native-Method？" class="headerlink" title="为什么要使用 Native Method？"></a>为什么要使用 Native Method？</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意（操作系统底层用c和c++实现）时，问题就来了。</p><h3 id="与Java环境外交互"><a href="#与Java环境外交互" class="headerlink" title="与Java环境外交互"></a>与Java环境外交互</h3><p><strong>有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因</strong>。你可以想想Java需要与一些<strong>底层系统</strong>，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它<strong>为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节</strong>。</p><h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><ol><li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。</li><li>然而不管怎样，它毕竟不是一个完整的系统，它经常<em>依赖于一底层系统的支持</em>。这些底层系统常常是强大的操作系统。</li><li><strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</strong>。</li><li>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li></ol><h3 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s Java"></a>Sun’s Java</h3><ol><li><strong>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互</strong>。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</li><li>例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它<em>实现调用的是该类里的本地方法setPriority0()<em>。</em></em>这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API<strong>。这是</strong>一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用**。</li></ol><h3 id="本地方法的现状"><a href="#本地方法的现状" class="headerlink" title="本地方法的现状"></a>本地方法的现状</h3><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ol><li><strong>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li><li><strong>本地方法栈，也是线程私有的</strong></li><li>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul></li><li>本地方法一般是使用C语言或C++语言实现的。</li><li>它的具体做法是<strong>Native Method Stack中登记native方法（管理本地方法的调用）</strong>，在Execution Engine 执行时加载本地方法库。</li></ol><p><img src="/2021/02/10/JVM-3-3/image-20210210215204019.png" alt="image-20210210215204019"></p><p><strong>注意事项</strong></p><ol><li>==当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限==<ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的<strong>运行时数据区</strong></li><li>它甚至可以直接使用本地处理器中的<strong>寄存器</strong></li><li>直接从本地内存的堆中分配任意数量的<strong>内存</strong></li></ul></li><li>并<strong>不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等</strong>。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈</li><li>在Hotspot JVM中，直接将<strong>本地方法栈和虚拟机栈合二为一</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;本地方法接口&quot;&gt;&lt;a href=&quot;#本地方法接口&quot; class=&quot;headerlink&quot; title=&quot;本地方法接口&quot;&gt;&lt;/a&gt;本地方法接口&lt;/h1&gt;&lt;h2 id=&quot;本地方法&quot;&gt;&lt;a href=&quot;#本地方法&quot; class=&quot;headerlink&quot; title=&quot;本</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="运行时数据区" scheme="https://www.gtxhjh.cn/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    <category term="本地方法栈" scheme="https://www.gtxhjh.cn/tags/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>第三章_2-虚拟机栈</title>
    <link href="https://www.gtxhjh.cn/2021/02/08/JVM-3-2/"/>
    <id>https://www.gtxhjh.cn/2021/02/08/JVM-3-2/</id>
    <published>2021-02-08T15:54:42.000Z</published>
    <updated>2021-02-08T15:59:18.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-2：虚拟机栈"><a href="#第三章-2：虚拟机栈" class="headerlink" title="第三章-2：虚拟机栈"></a>第三章-2：虚拟机栈</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="虚拟机栈的出现背景"><a href="#虚拟机栈的出现背景" class="headerlink" title="虚拟机栈的出现背景"></a>虚拟机栈的出现背景</h3><ol><li> 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li><li> 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li></ol><h3 id="内存中的栈与堆"><a href="#内存中的栈与堆" class="headerlink" title="内存中的栈与堆"></a>内存中的栈与堆</h3><ol><li>首先栈是运行时的单位，而堆是存储的单位。</li><li>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ol><p><img src="/2021/02/08/JVM-3-2/image-20210205215401398.png" alt="image-20210205215401398"></p><h3 id="虚拟机栈基本内容"><a href="#虚拟机栈基本内容" class="headerlink" title="虚拟机栈基本内容"></a>虚拟机栈基本内容</h3><ul><li><p>Java虚拟机栈是什么？</p><ul><li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其<strong>内部保存一个个的栈帧（线程相关）</strong>（Stack Frame），**==对应着一次次的Java方法调用==**，栈是线程私有的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackTest test = <span class="keyword">new</span> StackTest();</span><br><span class="line">        test.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/02/08/JVM-3-2/image-20210205221839925.png" alt="image-20210205221839925"></p><ul><li><p>虚拟机栈的生命周期</p><ul><li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li></ul></li><li><p>虚拟机栈的作用</p><ul><li>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</li><li>局部变量，它是相比于成员变量来说的（或属性）</li><li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li></ul></li></ul><h3 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a>虚拟机栈的特点</h3><ul><li><p>栈是一种快速有效的分配存储方式，<strong>访问速度仅次于程序计数器</strong>。</p></li><li><p>JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li><p>对于栈来说不存在垃圾回收问题</p><ul><li>栈不需要GC，但是可能存在OOM</li></ul></li></ul><p><img src="/2021/02/08/JVM-3-2/image-20210205222539991.png" alt="image-20210205222539991"></p><h3 id="虚拟机栈的异常"><a href="#虚拟机栈的异常" class="headerlink" title="虚拟机栈的异常"></a>虚拟机栈的异常</h3><p><strong>面试题：栈中可能出现的异常？</strong></p><ul><li><p>Java 虚拟机规范允许Java<strong>栈的大小是动态的或者是固定不变的</strong></p><ul><li><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</p></li><li><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候<em>无法申请到足够的内存</em>，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</p></li></ul></li></ul><h3 id="参数调优-设置栈内存大小"><a href="#参数调优-设置栈内存大小" class="headerlink" title="参数调优-设置栈内存大小"></a>参数调优-设置栈内存大小</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><p>官方文档</p></blockquote><p>可以==使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间==，栈的大小直接决定了函数调用的最大可达深度。</p><blockquote><p>Sets the thread stack size (in bytes). Append the letter <code>k</code> or <code>K</code> to indicate KB, <code>m</code> or <code>M</code> to indicate MB, and <code>g</code> or <code>G</code> to indicate GB. The default value depends on the platform:</p><ul><li>Linux/x64 (64-bit): 1024 KB</li><li>macOS (64-bit): 1024 KB</li><li>Oracle Solaris/x64 (64-bit): 1024 KB</li><li>Windows: The default value depends on virtual memory</li></ul></blockquote><p>The following examples set the thread stack size to 1024 KB in different units:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没设置参数前</strong></p><p>部分输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">11404</span></span><br><span class="line"><span class="number">11405</span></span><br><span class="line"><span class="number">11406</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:<span class="number">691</span>)</span><br></pre></td></tr></table></figure><p>说明栈在11406这个深度溢出了</p><p><strong>设置栈参数之后</strong></p><p><img src="/2021/02/08/JVM-3-2/image-20210205223645371.png" alt="image-20210205223645371"></p><p>部分输出结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2474</span></span><br><span class="line"><span class="number">2475</span></span><br><span class="line"><span class="number">2476</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:<span class="number">77</span>)</span><br></pre></td></tr></table></figure><p>说明参数起作用了</p><h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><ol><li> 每个线程都有自己的栈，==栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在==</li><li> 在这个线程上正在执行的<strong>每个方法都各自对应一个栈帧（Stack Frame）</strong>。</li><li> 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ol><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><ol><li><p> JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</p></li><li><p> 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></p></li><li><p> 执行引擎运行的<strong>所有字节码指令只针对当前栈帧进行操作</strong>（寄存器中存储的也是当前栈帧的字节码指令操作地址）。</p></li><li><p> 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p></li></ol><p><img src="/2021/02/08/JVM-3-2/image-20210207203727137.png" alt="image-20210207203727137"></p><ol><li> <strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li> 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式。<ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束（异常往上抛）。</li><li>但不管使用哪种方式，都会导致栈帧被弹出。</li></ul></li></ol><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li><p><strong>局部变量表（Local Variables）</strong></p></li><li><p><strong>操作数栈（Operand Stack）（或表达式栈、操作栈）</strong></p></li><li><p>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</p></li><li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p></li><li><p>一些附加信息</p></li></ul><p><img src="/2021/02/08/JVM-3-2/image-20210207210022335.png" alt="image-20210207210022335"></p><blockquote><p>并行每个线程下的栈都是私有的，因此**==每个线程都有自己各自的栈==<strong>，并且每个栈里面都有很多栈帧，</strong>==栈帧的大小主要由局部变量表和操作数栈决定==**的</p></blockquote><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0007.png"><h2 id="内部结构-局部变量表"><a href="#内部结构-局部变量表" class="headerlink" title="内部结构-局部变量表"></a>内部结构-局部变量表</h2><blockquote><p>局部变量表也被称之为局部变量数组或本地变量表</p></blockquote><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ol start="2"><li><p><strong>定义为一个==数字数组==，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</p></li><li><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></p></li><li><p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</p></li><li><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。</p><blockquote><p>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</p><p>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p></blockquote></li><li><p>局部变量表中的变量只在当前方法调用中有效。</p><blockquote><p>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</p><p>当方法调用结束后，<strong>随着方法栈帧的销毁，局部变量表也会随之销毁</strong>。</p></blockquote></li></ol><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariablesTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//练习：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关于Slot的使用的理解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LocalVariablesTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String name1 = <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">        test2(date, name1);</span><br><span class="line">        System.out.println(date + name1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(Date dateP, String name2)</span> </span>&#123;</span><br><span class="line">        dateP = <span class="keyword">null</span>;</span><br><span class="line">        name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">        <span class="keyword">char</span> gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> dateP + name2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            b = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">        <span class="keyword">int</span> c = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0008.png"><p>看完字节码后，可得结论：所以局部变量表所需的容量大小是在编译期确定下来的。</p><h4 id="部分详解"><a href="#部分详解" class="headerlink" title="部分详解"></a>部分详解</h4><p>为了更好讲解，我们直接用jclasslib来看字节码，以main方法为例来讲解。一些一目了然的就不讲了</p><ul><li>main</li></ul><p><img src="/2021/02/08/JVM-3-2/image-20210207215011746.png" alt="image-20210207215011746"></p><ul><li>0-15  也就是有16行字节码，字节码指令</li></ul><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0009.png"><ul><li>方法异常信息表</li></ul><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0010.png"><ul><li>Misc（可见编译时已确定且不改变）</li></ul><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0011.png"><ul><li><p>行号表</p><p><strong>Java代码的行号和字节码指令行号的对应关系</strong></p></li></ul><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0012.png"><ul><li><p>局部变量表</p><p>方法中局部变量的刻画</p></li></ul><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0013.png"><p>1、图中圈的东西表示该<strong>局部变量的作用域范围</strong></p><p>2、Start PC==11表示在字节码的11行开始生效，也就是Java代码对应的第15行。即变量<strong>作用域起始位置</strong>。而声明int num在java代码的是第14行，说明是从声明的下一行开始生效</p><p>3、Length== 5表示局部变量<strong>剩余有效行数</strong>，main方法字节码指令总共有16行，从11行开始生效，那么剩下就是16-11 ==5。</p><p>4、描述中<code>Ljava/lang/String</code>   前面的L表示引用类型</p><blockquote><p>注意：生效行数和剩余有效行数都是针对于字节码文件的行数</p></blockquote><h3 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h3><ol><li><p>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</p></li><li><p><strong>局部变量表，最基本的存储单元是Slot（变量槽）</strong></p></li><li><p>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p></li><li><p>在局部变量表里，==<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型），<strong>64位的类型占用两个slot</strong>（1ong和double）==。</p><blockquote><p>byte、short、char在储存前辈转换为int，boolean也被转换为int，0表示false，非0表示true(所以局部变量表定义为<strong>数字</strong>数组)</p><p>long和double则占据两个slot</p></blockquote></li><li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值(使用起始索引)</p></li><li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照声明顺序被复制</strong>到局部变量表中的每一个slot上</p></li><li><p>如果当前<strong>帧</strong>是由构造<strong>方法</strong>或者实例<strong>方法</strong>创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（<strong>this也相当于一个变量</strong>）</p><blockquote><p>所以静态方法不能引用this，因为局部变量表中不存在this</p></blockquote></li></ol><p><img src="/2021/02/08/JVM-3-2/image-20210207220002807.png" alt="image-20210207220002807"></p><h3 id="Slot代码示例"><a href="#Slot代码示例" class="headerlink" title="Slot代码示例"></a>Slot代码示例</h3><p><strong>this 存放在 index = 0 的位置：</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.count++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>局部变量表：this 存放在 index = 0 的位置</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0015.png"><p><strong>64位的类型（1ong和double）占用两个slot</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(Date dateP, String name2)</span> </span>&#123;</span><br><span class="line">      dateP = <span class="keyword">null</span>;</span><br><span class="line">      name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">      <span class="keyword">double</span> weight = <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">      <span class="keyword">char</span> gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> dateP + name2;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>weight 为 double 类型，index 直接从 3 蹦到了 5</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0016.png"><p><strong>static 无法调用 this</strong></p><p>this 不存在与 static 方法的局部变量表中，所以无法调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h3><p>栈帧中的局部变量表中的<strong>槽位是可以重用</strong>的，如果一个<strong>局部变量过了其作用域</strong>，那么在其作用域之后申明<strong>新的局部变量变就很有可能会复用过期局部变量的槽位</strong>，从而达到节省资源的目的。</p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        b = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">    <span class="keyword">int</span> c = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>局部变量 c 重用了局部变量 b 的 slot 位置</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0017.png"><h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><blockquote><p>变量的分类：</p><ol><li><p>按照数据类型分：① 基本数据类型  ② 引用数据类型</p></li><li><p>按照在类中声明的位置分：</p></li></ol><p>成员变量：在使用前，都经历过默认初始化赋值</p><blockquote><p>类变量: 静态修饰的，linking的<strong>prepare阶段：给类变量==默认赋值==</strong> —&gt; <strong>initial阶段：给类变量显式赋值即静态代码块赋值</strong></p><p>实例变量：随着<strong>对象的创建</strong>，会在<strong>堆空间</strong>中分配实例变量空间，并进行**==默认赋值==**</p></blockquote><p>局部变量：在使用前，<strong>必须要进行显式赋值</strong>的！（局部变量表不存在系统初始化的过程）否则，编译不通过。</p></blockquote><ol><li> 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li> 我们知道成员变量有两次初始化的机会<strong>，</strong>第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li><li> 和类变量初始化不同的是，**==局部变量表不存在系统初始化的过程==**，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li></ol><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ol><li><p> 在栈帧中，<em>与性能调优关系最为密切的部分</em>就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p></li><li><p> <strong>==局部变量表中的变量也是重要的垃圾回收<em>根节点</em>，只要被局部变量表中直接或间接引用的对象都不会被回收==</strong></p></li></ol><h2 id="内部结构-操作数栈"><a href="#内部结构-操作数栈" class="headerlink" title="内部结构-操作数栈"></a>内部结构-操作数栈</h2><blockquote><p>栈：使用数组或链表来实现</p></blockquote><h3 id="操作数栈的特点"><a href="#操作数栈的特点" class="headerlink" title="操作数栈的特点"></a>操作数栈的特点</h3><ol><li><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</p></li><li><p>操作数栈，在方法执行过程中，**<em>根据字节码指令</em>，往栈中写入数据或提取数据**，即入栈（push）和 出栈（pop）</p><blockquote><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，</p><p>比如：执行复制、交换、求和等操作</p><p><img src="/2021/02/08/JVM-3-2/image-20210208190046413.png" alt="image-20210208190046413"></p></blockquote></li></ol><p><img src="/2021/02/08/JVM-3-2/image-20210208190138235.png" alt="image-20210208190138235"></p><h3 id="操作数栈的作用"><a href="#操作数栈的作用" class="headerlink" title="操作数栈的作用"></a>操作数栈的作用</h3><ul><li><p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</p></li><li><p><strong>操作数栈就是JVM执行引擎的一个工作区</strong>，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的（但数组的长度确定）</p></li><li><p><strong>每一个操作数栈都会拥有一个明确的栈深度用于存储数值</strong>，其所需的最大深度<strong>在编译期就定义好</strong>了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</p><p><img src="/2021/02/08/JVM-3-2/image-20210208190445589.png" alt="image-20210208190445589"></p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型</p><blockquote><p>32bit的类型占用一个栈单位深度</p><p>64bit的类型占用两个栈单位深度</p></blockquote></li><li><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></p></li><li><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p></li><li><p>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</p></li></ul><h3 id="操作数栈代码追踪"><a href="#操作数栈代码追踪" class="headerlink" title="操作数栈代码追踪"></a>操作数栈代码追踪</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">    <span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> k = i + j;</span><br><span class="line">    <span class="comment">// int m = 800;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/image-20210208191538431.png" alt="image-20210208191538431" style="zoom:50%;"><p>对应字节码指令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">15</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">8</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> iload_2</span><br><span class="line"> <span class="number">8</span> iadd</span><br><span class="line"> <span class="number">9</span> istore_3</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0021.png"><h4 id="一步一步看流程"><a href="#一步一步看流程" class="headerlink" title="一步一步看流程"></a>一步一步看流程</h4><blockquote><p>可以发现栈的深度已经明确</p></blockquote><p>1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0022.png"><p>2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了</p><blockquote><p><strong>解释</strong>为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0023.png"></blockquote><p>3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0024.png"><p>4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作</p><p>iload_1：取出局部变量表中索引为1的数据入操作数栈</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0025.png"><p>5、然后将操作数栈中的两个元素执行相加操作(执行引擎把字节码指令翻译成机器指令，让CPU运算)，并存储在局部变量表3的位置</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_004/0026.png"><h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p><strong>关于类型转换的说明</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_004/0027.png"><ul><li>  因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8</li><li>  但是存储在局部变量的时候，会转成 int 类型的变量：istore_4</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_004/0028.png"><ul><li>m改成800之后，byte存储不了，就成了short型，sipush 800</li></ul><p><strong>如果被调用的方法带有返回值，返回值入操作数栈</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> k = m + n;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span></span><br><span class="line">    <span class="keyword">int</span> i = getSum();</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getSum() 方法字节码指令：最后带着个 ireturn</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_004/0029.png"><p>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_004/0030.png"><h2 id="优化-栈顶缓存技术"><a href="#优化-栈顶缓存技术" class="headerlink" title="优化-栈顶缓存技术"></a>优化-栈顶缓存技术</h2><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p><ul><li><p><strong>问题：</strong>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要<strong>更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高</strong>。</p></li><li><p>由于<em>操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度</em>。为了<strong>解决</strong>这个问题，HotSpot JVM的设计者们提出了栈顶<strong>缓存</strong>（Tos，Top-of-Stack Cashing）技术：</p><blockquote><p><strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></p><blockquote><p>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</p><p><img src="/2021/02/08/JVM-3-2/image-20210208193901222.png" alt="image-20210208193901222"></p></blockquote></blockquote></li></ul><h2 id="内部结构-动态链接"><a href="#内部结构-动态链接" class="headerlink" title="内部结构-动态链接"></a>内部结构-动态链接</h2><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p><blockquote><p>大部分字节码指令执行时，都需要进行常量池的访问</p></blockquote><ol><li><p>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</p></li><li><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将==这些符号引用转换为调用方法的直接引用==</strong></p></li><li><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/image-20210208201706279.png" alt="image-20210208201706279" style="zoom:67%;"><p><img src="/2021/02/08/JVM-3-2/image-20210208201344590.png" alt="image-20210208201344590"></p><blockquote><p>注：如果都有空参，可以用#6</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicLinkingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        methodA();</span><br><span class="line"></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">10</span>; size <span class="number">712</span> bytes</span><br><span class="line">  MD5 checksum e56913c945f897c7ee6c0a608629bca8</span><br><span class="line">  Compiled from <span class="string">&quot;DynamicLinkingTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">DynamicLinkingTest</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #9.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #8.#24         // com/atguigu/java1/DynamicLinkingTest.num:I</span><br><span class="line">   #3 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = String             #27            // methodA()....</span><br><span class="line">   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #6 = String             #30            // methodB()....</span><br><span class="line">   #7 = Methodref          #8.#31         // com/atguigu/java1/DynamicLinkingTest.methodA:()V</span><br><span class="line">   #8 = Class              #32            // com/atguigu/java1/DynamicLinkingTest</span><br><span class="line">   #9 = Class              #33            // java/lang/Object</span><br><span class="line">  #10 = Utf8               num</span><br><span class="line">  #11 = Utf8               I</span><br><span class="line">  #12 = Utf8               &lt;init&gt;</span><br><span class="line">  #13 = Utf8               ()V</span><br><span class="line">  #14 = Utf8               Code</span><br><span class="line">  #15 = Utf8               LineNumberTable</span><br><span class="line">  #16 = Utf8               LocalVariableTable</span><br><span class="line">  #17 = Utf8               this</span><br><span class="line">  #18 = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line">  #19 = Utf8               methodA</span><br><span class="line">  #20 = Utf8               methodB</span><br><span class="line">  #21 = Utf8               SourceFile</span><br><span class="line">  #22 = Utf8               DynamicLinkingTest.java</span><br><span class="line">  #23 = NameAndType        #12:#13        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #24 = NameAndType        #10:#11        // num:I</span><br><span class="line">  #25 = Class              #34            // java/lang/System</span><br><span class="line">  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;</span><br><span class="line">  #27 = Utf8               methodA()....</span><br><span class="line">  #28 = Class              #37            // java/io/PrintStream</span><br><span class="line">  #29 = NameAndType        #38:#39        // println:(Ljava/lang/String;)V</span><br><span class="line">  #30 = Utf8               methodB()....</span><br><span class="line">  #31 = NameAndType        #19:#13        // methodA:()V</span><br><span class="line">  #32 = Utf8               com/atguigu/java1/DynamicLinkingTest</span><br><span class="line">  #33 = Utf8               java/lang/Object</span><br><span class="line">  #34 = Utf8               java/lang/System</span><br><span class="line">  #35 = Utf8               out</span><br><span class="line">  #36 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #37 = Utf8               java/io/PrintStream</span><br><span class="line">  #38 = Utf8               println</span><br><span class="line">  #39 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.DynamicLinkingTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         7: putfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #4                  // String methodA()....</span><br><span class="line">         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #6                  // String methodB()....</span><br><span class="line">         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         9: invokevirtual #7                  // Method methodA:()V</span><br><span class="line">        <span class="number">12</span>: aload_0</span><br><span class="line">        <span class="number">13</span>: dup</span><br><span class="line">        14: getfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">17</span>: iconst_1</span><br><span class="line">        <span class="number">18</span>: iadd</span><br><span class="line">        19: putfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">22</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">23</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;DynamicLinkingTest.java&quot;</span></span><br></pre></td></tr></table></figure><p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p><p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p><ul><li>先找 #8 ：<ul><li>  <code>#8 = Class #32</code> ：去找 #32</li><li>  <code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li><li>  结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li></ul></li><li>再来找 #31：<ul><li>  <code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li><li>  <code>#19 = Utf8 methodA</code> ：方法名为 methodA</li><li>  <code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li></ul></li></ul><p>3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p><p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p><p><img src="/2021/02/08/JVM-3-2/image-20210208202029476.png" alt="image-20210208202029476"></p><blockquote><p>当常量池运行，信息会存放在方法区</p></blockquote><p><strong>为什么要用常量池呢？</strong></p><ol><li><p> 因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</p></li><li><p> 常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></li></ol><h2 id="重点-方法的调用"><a href="#重点-方法的调用" class="headerlink" title="重点-方法的调用"></a>重点-方法的调用</h2><h3 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li><strong>静态链接</strong>：</li></ul><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下<strong>将调用方法的符号引用转换为直接引用的过程称之为静态链接</strong></p><ul><li><strong>动态链接</strong>：</li></ul><p>如果被调用的方法在编译期无法被确定下来，也就是说，<strong>只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接</strong>。</p><h3 id="早期绑定与晚期绑定"><a href="#早期绑定与晚期绑定" class="headerlink" title="早期绑定与晚期绑定"></a>早期绑定与晚期绑定</h3><blockquote><p>静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p></blockquote><p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p><ul><li><strong>早期绑定</strong></li></ul><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p><ul><li><strong>晚期绑定</strong></li></ul><p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，多管闲事&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eat();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，天经地义&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAnimal</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHunt</span><span class="params">(Huntable h)</span> </span>&#123;</span><br><span class="line">        h.hunt();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>部分字节码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java2.AnimalTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">54</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAnimal</span><span class="params">(com.atguigu.java2.Animal)</span></span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Animal;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         1: invokevirtual #2                  // Method com/atguigu/java2/Animal.eat:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">56</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">57</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">1</span> animal   Lcom/atguigu/java2/Animal;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHunt</span><span class="params">(com.atguigu.java2.Huntable)</span></span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Huntable;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         1: invokeinterface #3,  1            // InterfaceMethod com/atguigu/java2/Huntable.hunt:()V</span><br><span class="line">         <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">60</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">61</span>: <span class="number">6</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">1</span>     h   Lcom/atguigu/java2/Huntable;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;AnimalTest.java&quot;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>invokevirtual 体现为晚期绑定</p></li><li><p>invokeinterface 也体现为晚期绑定</p></li><li><p>invokespecial 体现为早期绑定</p></li></ul></blockquote><h3 id="多态与绑定"><a href="#多态与绑定" class="headerlink" title="多态与绑定"></a>多态与绑定</h3><ol><li><p> 随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言<strong>具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式</strong>。</p></li><li><p> Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。<strong>如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法</strong>。</p></li></ol><h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><h5 id="虚方法与非虚方法的区别"><a href="#虚方法与非虚方法的区别" class="headerlink" title="虚方法与非虚方法的区别"></a><strong>虚方法与非虚方法的区别</strong></h5><ol><li><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</p><blockquote><p>静态方法、私有方法、final方法(前都不可被重写)、实例构造器(确定的)、父类方法(确定用父类方法)都是非虚方法</p></blockquote></li><li><p>其他方法称为虚方法(不确定)</p></li></ol><h5 id="子类对象的多态的使用前提："><a href="#子类对象的多态的使用前提：" class="headerlink" title="子类对象的多态的使用前提："></a><strong>子类对象的多态的使用前提：</strong></h5><blockquote><p>类的继承关系</p><p>方法的重写</p></blockquote><h5 id="虚拟机中调用方法的指令"><a href="#虚拟机中调用方法的指令" class="headerlink" title="虚拟机中调用方法的指令"></a><strong>虚拟机中调用方法的指令</strong></h5><ul><li><strong>普通指令：</strong></li></ul><ol><li> invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li> invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li> invokevirtual：调用所有虚方法</li><li> invokeinterface：调用接口方法</li></ol><blockquote><p>这四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。<strong>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法</strong>。</p></blockquote><ul><li><p><strong>动态调用指令</strong></p><p>invokedynamic：动态解析出需要调用的方法，然后执行</p><blockquote><ol><li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【<strong>动态类型语言</strong>】支持而做的一种改进。</li><li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的**Lambda表达式(函数式接口)**的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</li><li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Func</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">func</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">(Func func)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lambda lambda = <span class="keyword">new</span> Lambda();</span><br><span class="line"></span><br><span class="line">        Func func = s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        lambda.lambda(func);</span><br><span class="line"></span><br><span class="line">        lambda.lambda(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_004/0033.png"></li></ul><h5 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">showFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father show final&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCommon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father 普通方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showPrivate</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son private&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        showStatic(<span class="string">&quot;atguigu.com&quot;</span>);</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        <span class="keyword">super</span>.showStatic(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        showPrivate(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">super</span>.showCommon();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showFinal();<span class="comment">//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。如果加super，即super.showFinal，那么就是invokespecial</span></span><br><span class="line">        <span class="comment">//虚方法如下：</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        invokevirtual  你没有显示的加super.，编译器认为你可能调用子类的showCommon(即使son子类没有重写，也  会认为)，所以编译期间确定不下来，就是虚方法。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        showCommon();</span><br><span class="line">        info();</span><br><span class="line"></span><br><span class="line">        MethodInterface in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//invokeinterface</span></span><br><span class="line">        in.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Father f)</span> </span>&#123;</span><br><span class="line">        f.showCommon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son so = <span class="keyword">new</span> Son();</span><br><span class="line">        so.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MethodInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Son 类中 show() 方法的字节码指令如下</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0032.png"><h3 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h3><ol><li><p>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言(Java)，反之是动态类型语言(js python)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String info = <span class="string">&quot;hjh&quot;</span>; <span class="comment">// 含具体类型， 如果为info=hjh则报错，说明编译期间会进行检查，不满足String类型，因此更严格</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;hjh&quot;</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="number">10</span><span class="comment">// var并不是真正的类型，只是形式上</span></span><br></pre></td></tr></table></figure></li><li><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是<strong>判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征</strong>。</p></li></ol><p>Java：String info = “mogu blog”;             (Java是静态类型语言的，会先编译就进行类型检查)<br>    JS：var name = “shkstart”;    var name = 10;    （运行时才进行检查）</p><pre><code>Python: info = 130.5 (运行时才检查)</code></pre><h3 id="Java语言中方法重写的本质"><a href="#Java语言中方法重写的本质" class="headerlink" title="Java语言中方法重写的本质"></a>Java语言中方法重写的本质</h3><ol><li><p>找到<strong>操作数栈顶的第一个元素</strong>所执行的对象的<strong>实际类型，记作C</strong>。</p></li><li><p>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。</p><ul><li>如果通过则返回这个方法的直接引用，查找过程结束</li></ul><ul><li>  如果不通过，则返回java.lang.IllegalAccessError 异常</li></ul></li><li><p>否则，按照继承关系<strong>从下往上</strong>依次对C的各个父类进行第2步的<strong>搜索和验证过程</strong>。</p></li><li><p>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常(是接口方法)。</p></li></ol><blockquote><p>上面这个过程称为<strong>动态分派</strong></p></blockquote><p><strong>IllegalAccessError介绍</strong></p><ol><li><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><blockquote><p>比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</p></blockquote></li></ol><h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><ol><li><p><strong>问题：</strong>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在<strong>每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率</strong>。</p><blockquote><p>解决：因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中(因为非常确定直接找到)。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</p></blockquote></li><li><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p></li></ol><p><strong>虚方法表何时创建：</strong></p><blockquote><p>虚方法表会在<strong>类加载的链接阶段</strong>被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</p><p><img src="/2021/02/08/JVM-3-2/image-20210208214249536.png" alt="image-20210208214249536"></p></blockquote><p><strong>例子1</strong></p><p>如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p><p><img src="/2021/02/08/JVM-3-2/image-20210208214306526.png" alt="image-20210208214306526"></p><blockquote><p>比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</p><p>下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</p></blockquote><p><strong>例子2</strong></p><p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20210208214727476.png" alt="image-20210208214727476"></p><p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20210208214749303.png" alt="image-20210208214749303"></p><p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20210208214959735.png" alt="image-20210208214959735"></p><p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20210208215038812.png" alt="image-20210208215038812"></p><h2 id="内部结构-方法返回地址"><a href="#内部结构-方法返回地址" class="headerlink" title="内部结构-方法返回地址"></a>内部结构-方法返回地址</h2><p><img src="/2021/02/08/JVM-3-2/image-20210208230030202.png" alt="image-20210208230030202"></p><blockquote><p>在一些帖子里，方法返回地址、动态链接、一些附加信息  也叫做帧数据区</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li>  正常执行完成</li><li>  出现未处理的异常，非正常退出</li></ul></li><li><p> 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过<strong>异常表</strong>来确定，栈帧中一般不会保存这部分信息（所以是针对正常退出）。</p></li><li><p> 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p></li><li><p> <strong>正常完成出口和异常完成出口的区别</strong>在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p></li></ol><h3 id="方法退出的两种方式"><a href="#方法退出的两种方式" class="headerlink" title="方法退出的两种方式"></a><strong>方法退出的两种方式</strong></h3><p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p><h4 id="正常退出："><a href="#正常退出：" class="headerlink" title="正常退出："></a><strong>正常退出：</strong></h4><ol><li><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</p></li><li><p>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</p><p>在字节码指令中，返回指令包含：</p><ul><li><p>ireturn：当返回值是boolean，byte，char，short和int类型时使用</p></li><li><p>lreturn：Long类型</p></li><li><p>freturn：Float类型</p></li><li><p>dreturn：Double类型</p></li><li><p>areturn：引用类型</p></li><li><p>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</p></li></ul></li></ol><h4 id="异常退出："><a href="#异常退出：" class="headerlink" title="异常退出："></a><strong>异常退出：</strong></h4><ol><li><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</p><blockquote><p>方法执行过程中，抛出异常时的异常处理，存储在一个<strong>异常处理表</strong>，方便在发生异常的时候找到处理异常的代码</p><p><img src="/2021/02/08/JVM-3-2/image-20210208231006993.png" alt="image-20210208231006993"></p><p>注意：此处为字节码指令地址</p><p>上面表示：4-16行指令异常，用19行字节码指令方式处理，针对任何类型</p></blockquote></li></ol><p>异常处理表：</p><ul><li>  反编译字节码文件，可得到 Exception table</li><li>  from ：字节码指令起始地址</li><li>  to ：字节码指令结束地址</li><li>  target ：出现异常跳转至地址为 11 的指令执行</li><li>  type ：捕获异常的类型</li></ul><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0041.png"><h2 id="内部结构-一些附加信息"><a href="#内部结构-一些附加信息" class="headerlink" title="内部结构-一些附加信息"></a>内部结构-一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三章-2：虚拟机栈&quot;&gt;&lt;a href=&quot;#第三章-2：虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;第三章-2：虚拟机栈&quot;&gt;&lt;/a&gt;第三章-2：虚拟机栈&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="运行时数据区" scheme="https://www.gtxhjh.cn/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    <category term="虚拟机栈" scheme="https://www.gtxhjh.cn/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>第三章_1-程序计数器(PC寄存器)</title>
    <link href="https://www.gtxhjh.cn/2021/02/08/JVM-3-1/"/>
    <id>https://www.gtxhjh.cn/2021/02/08/JVM-3-1/</id>
    <published>2021-02-08T15:52:54.000Z</published>
    <updated>2021-02-08T15:58:44.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-1：程序计数器-PC寄存器"><a href="#第三章-1：程序计数器-PC寄存器" class="headerlink" title="第三章-1：程序计数器(PC寄存器)"></a>第三章-1：程序计数器(PC寄存器)</h1><h2 id="PC寄存器介绍"><a href="#PC寄存器介绍" class="headerlink" title="PC寄存器介绍"></a>PC寄存器介绍</h2><blockquote><p>官方文档网址：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p></blockquote><p><img src="/2021/02/08/JVM-3-1/image-20210205205040315.png" alt="image-20210205205040315"></p><ol><li> JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li><li> 这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子（钩代码，行号指示器）），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</li><li> 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li> 在JVM规范中，<strong>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</strong>。</li><li> 任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。<strong>程序计数器会存储当前线程正在执行的Java方法的JVM指令地址</strong>；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li> 它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li> 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li> 它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域（无垃圾回收和OOM异常）</li></ol><h2 id="PC寄存器的作用"><a href="#PC寄存器的作用" class="headerlink" title="PC寄存器的作用"></a>PC寄存器的作用</h2><p>PC寄存器用来存储指向<strong>下一条指令的地址</strong>，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</p><p><img src="/2021/02/08/JVM-3-1/image-20210205205251917.png" alt="image-20210205205251917"></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line"></span><br><span class="line">        String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看字节码</p><blockquote><p>看字节码的方法：<a href="https://blog.csdn.net/21aspnet/article/details/88351875">https://blog.csdn.net/21aspnet/article/details/88351875</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter04/com/atguigu/java/PCRegisterTest.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">2</span>; size <span class="number">675</span> bytes</span><br><span class="line">  MD5 checksum 53b3ef104479ec9e9b7ce5319e5881d3</span><br><span class="line">  Compiled from <span class="string">&quot;PCRegisterTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java</span>.<span class="title">PCRegisterTest</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#26         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #27            // abc</span><br><span class="line">   #3 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Methodref          #30.#31        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #5 = Class              #32            // com/atguigu/java/PCRegisterTest</span><br><span class="line">   #6 = Class              #33            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/atguigu/java/PCRegisterTest;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               i</span><br><span class="line">  #19 = Utf8               I</span><br><span class="line">  #20 = Utf8               j</span><br><span class="line">  #21 = Utf8               k</span><br><span class="line">  #22 = Utf8               s</span><br><span class="line">  #23 = Utf8               Ljava/lang/String;</span><br><span class="line">  #24 = Utf8               SourceFile</span><br><span class="line">  #25 = Utf8               PCRegisterTest.java</span><br><span class="line">  #26 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #27 = Utf8               abc</span><br><span class="line">  #28 = Class              #34            // java/lang/System</span><br><span class="line">  #29 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;</span><br><span class="line">  #30 = Class              #37            // java/io/PrintStream</span><br><span class="line">  #31 = NameAndType        #38:#39        // println:(I)V</span><br><span class="line">  #32 = Utf8               com/atguigu/java/PCRegisterTest</span><br><span class="line">  #33 = Utf8               java/lang/Object</span><br><span class="line">  #34 = Utf8               java/lang/System</span><br><span class="line">  #35 = Utf8               out</span><br><span class="line">  #36 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #37 = Utf8               java/io/PrintStream</span><br><span class="line">  #38 = Utf8               println</span><br><span class="line">  #39 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java.PCRegisterTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java/PCRegisterTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">5</span>: istore_2</span><br><span class="line">         <span class="number">6</span>: iload_1</span><br><span class="line">         <span class="number">7</span>: iload_2</span><br><span class="line">         <span class="number">8</span>: iadd</span><br><span class="line">         <span class="number">9</span>: istore_3</span><br><span class="line">        10: ldc           #2                  // String abc</span><br><span class="line">        <span class="number">12</span>: astore        <span class="number">4</span></span><br><span class="line">        14: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">17</span>: iload_1</span><br><span class="line">        18: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        21: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">24</span>: iload_3</span><br><span class="line">        25: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">14</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">21</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span>     i   I</span><br><span class="line">            <span class="number">6</span>      <span class="number">23</span>     <span class="number">2</span>     j   I</span><br><span class="line">           <span class="number">10</span>      <span class="number">19</span>     <span class="number">3</span>     k   I</span><br><span class="line">           <span class="number">14</span>      <span class="number">15</span>     <span class="number">4</span>     s   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;PCRegisterTest.java&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>左边的数字代表<strong>指令地址（指令偏移）</strong>，即 PC 寄存器中可能存储的值，</p><p>执行引擎会读取 PC 寄存器中的值，操作虚拟机栈结构实现数据存取，并翻译指令为机器指令，让CPU做运算</p></li></ul><p><img src="/2021/02/08/JVM-3-1/image-20210205210241883.png" alt="image-20210205210241883"></p><h2 id="两个面试题"><a href="#两个面试题" class="headerlink" title="两个面试题"></a>两个面试题</h2><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？</strong>或者问<strong>为什么使用 PC 寄存器来记录当前线程的执行地址呢？</strong></p><ol><li><p> 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</p></li><li><p> JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</p></li></ol><p><img src="/2021/02/08/JVM-3-1/image-20210205210359065.png" alt="image-20210205210359065"></p><p><strong>PC寄存器为什么被设定为私有的？</strong></p><ol><li> 所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是==为每一个线程都分配一个PC寄存器==**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li> 由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li> 这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会<strong>产生自己的程序计数器和栈帧</strong>，程序计数器在各个线程之间互不影响。</li></ol><h2 id="CPU-时间片"><a href="#CPU-时间片" class="headerlink" title="CPU 时间片"></a>CPU 时间片</h2><ol><li><p> CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p></li><li><p> 在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p></li><li><p> 但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三章-1：程序计数器-PC寄存器&quot;&gt;&lt;a href=&quot;#第三章-1：程序计数器-PC寄存器&quot; class=&quot;headerlink&quot; title=&quot;第三章-1：程序计数器(PC寄存器)&quot;&gt;&lt;/a&gt;第三章-1：程序计数器(PC寄存器)&lt;/h1&gt;&lt;h2 id=&quot;PC寄</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="运行时数据区" scheme="https://www.gtxhjh.cn/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    <category term="程序计数器" scheme="https://www.gtxhjh.cn/tags/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>第3章-运行时数据区概述及线程</title>
    <link href="https://www.gtxhjh.cn/2021/02/08/JVM-3/"/>
    <id>https://www.gtxhjh.cn/2021/02/08/JVM-3/</id>
    <published>2021-02-08T15:50:10.000Z</published>
    <updated>2021-02-08T15:51:57.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章：运行时数据区概述及线程"><a href="#第3章：运行时数据区概述及线程" class="headerlink" title="第3章：运行时数据区概述及线程"></a>第3章：运行时数据区概述及线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="/2021/02/08/JVM-3/image-20210205202840541.png" alt="image-20210205202840541"></p><p>当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到<strong>运行时数据区</strong></p><p><img src="/2021/02/08/JVM-3/image-20210205203026946.png" alt="image-20210205203026946"></p><h2 id="运行时数据区结构"><a href="#运行时数据区结构" class="headerlink" title="运行时数据区结构"></a>运行时数据区结构</h2><h3 id="运行时数据区与内存"><a href="#运行时数据区与内存" class="headerlink" title="运行时数据区与内存"></a>运行时数据区与内存</h3><ol><li><p>内存是非常重要的系统资源，是<strong>硬盘和CPU的中间仓库及<em>桥梁</em></strong>，<strong>承载着操作系统和应用程序的<em>实时运行</em></strong>。==JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略==，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p></li><li><p>通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p></li></ol><blockquote><p>下图来自阿里巴巴手册JDK8</p></blockquote><p><img src="/2021/02/08/JVM-3/image-20210205203750578.png" alt="image-20210205203750578"></p><h3 id="线程的内存空间"><a href="#线程的内存空间" class="headerlink" title="线程的内存空间"></a>线程的内存空间</h3><ol><li><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是<strong>与线程一一对应</strong>的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p><img src="/2021/02/08/JVM-3/image-20210205203901582.png" alt="image-20210205203901582"></p></li><li><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>线程独有：独立包括程序计数器、栈、本地方法栈</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><strong>一般优化的就是堆空间、方法区，即共享部分</strong></p></li></ol><p><img src="/2021/02/08/JVM-3/image-20210205203843572.png" alt="image-20210205203843572"></p><h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p><strong>每个JVM只有一个Runtime实例</strong>。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p><blockquote><p>一个JVM对应一个Runtime实例，相当于运行时数据区</p></blockquote><p><img src="/2021/02/08/JVM-3/image-20210205204337554.png" alt="image-20210205204337554"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="JVM-线程"><a href="#JVM-线程" class="headerlink" title="JVM 线程"></a>JVM 线程</h3><ol><li><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</p></li><li><p><strong>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射</strong></p><blockquote><p>对于Java层面的线程，运行时真正调用的是操作系统的本地线程</p><p>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</p></blockquote></li><li><p>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</p></li></ol><h3 id="JVM-系统线程"><a href="#JVM-系统线程" class="headerlink" title="JVM 系统线程"></a>JVM 系统线程</h3><ul><li><p>如果使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</p></li><li><p>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p></li></ul><ol><li> <strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到<strong>安全点</strong>才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li> <strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行(典型的后台线程)</li><li> <strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li><li> <strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li><li> <strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第3章：运行时数据区概述及线程&quot;&gt;&lt;a href=&quot;#第3章：运行时数据区概述及线程&quot; class=&quot;headerlink&quot; title=&quot;第3章：运行时数据区概述及线程&quot;&gt;&lt;/a&gt;第3章：运行时数据区概述及线程&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="运行时数据区" scheme="https://www.gtxhjh.cn/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    <category term="概述" scheme="https://www.gtxhjh.cn/tags/%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>第2章-类加载子系统</title>
    <link href="https://www.gtxhjh.cn/2021/02/08/JVM-2/"/>
    <id>https://www.gtxhjh.cn/2021/02/08/JVM-2/</id>
    <published>2021-02-08T15:46:29.000Z</published>
    <updated>2021-02-08T15:51:11.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第2章：类加载子系统"><a href="#第2章：类加载子系统" class="headerlink" title="第2章：类加载子系统"></a>第2章：类加载子系统</h1><h2 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h2><h3 id="简图"><a href="#简图" class="headerlink" title="简图"></a>简图</h3><p><img src="images/image-20210202225707366.png" alt="image-20210202225707366"></p><ul><li>字节码文件通过类加载器子系统加载到内存</li><li>生成class对象，以及静态属性初始化等，主要在方法区</li><li>字节码指令的执行依靠执行引擎</li></ul><h3 id="详细图"><a href="#详细图" class="headerlink" title="详细图"></a>详细图</h3><p><img src="images/image-20210202225935448.png" alt="image-20210202225935448"></p><p><img src="images/image-20210202225952912.png" alt="image-20210202225952912"></p><blockquote><ol><li>加载</li></ol><p>验证、准备、解析</p><p>初始化</p><ol start="2"><li>内存层面、运行时数据区：</li></ol><p>PC寄存器（每个线程一份）</p><p>栈：虚拟机栈，每个线程一份，每个结构为栈帧</p><p>本地方法栈：涉及到本地方法接口调用</p><p>堆区：存放创建java对象</p><p>方法区：类信息、常量、域信息等</p><ol start="3"><li>执行引擎：</li></ol><p>解释器、即时编译器、垃圾回收器</p></blockquote><h2 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h2><p><strong>类加载器子系统作用：</strong></p><ol><li><p> 类加载器子系统<strong>负责从文件系统或者网络中加载Class文件</strong>，class文件在文件开头有特定的<em>文件标识</em>（验证阶段实现）。</p></li><li><p> ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p></li><li><p> <strong>==加载的类信息存放于一块称为方法区的内存空间==**。除了类的信息外，</strong>方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量**（这部分常量信息是Class文件中常量池部分的内存映射）</p></li></ol><p><img src="images/image-20210202234728432.png" alt="image-20210202234728432"></p><h2 id="类加载器ClassLoader角色"><a href="#类加载器ClassLoader角色" class="headerlink" title="类加载器ClassLoader角色"></a>类加载器ClassLoader角色</h2><ol><li> class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li> class file加载到JVM中，被称为DNA元数据模板（Car Class），放在方法区。</li><li> 在.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ol><p><img src="images/image-20210202235014793.png" alt="image-20210202235014793"></p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;谢谢ClassLoader加载我....&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;你的大恩大德，我下辈子再报！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加载过程</strong>：</p><ol><li>执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader</li><li>当前类是否加载？如果没有加载需要使用相应classloader装载，自定义类使用系统类加载器，加载中如果有问题抛出异常，相应的看字节码文件.class，如果<strong>不是合法的那么会有异常</strong></li><li>加载成功，有了class对象，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main</li></ol><p><img src="images/image-20210202235337618.png" alt="image-20210202235337618"></p><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p><strong>加载：</strong></p><ol><li><p> 通过一个类的全限定名获取定义此类的二进制字节流</p></li><li><p> 将这个字节流所代表的静态存储结构转化为方法区（源空间）的运行时数据结构</p></li><li><p> **==在内存中生成一个代表这个类的java.lang.Class对象(实例)==**，作为方法区这个类的各种数据的访问入口</p></li></ol><p><strong>加载class文件的方式：</strong></p><ol><li> 从本地系统中直接加载</li><li> 通过网络获取，典型场景：Web Applet</li><li> 从zip压缩包中读取，成为日后jar、war格式的基础（字节码文件）</li><li> 运行时计算生成，使用最多的是：动态代理技术</li><li> 由其他文件生成，典型场景：JSP应用</li><li> 从专有数据库中提取.class文件，比较少见</li><li> 从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ol><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><p>链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析</p><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证(Verify)"></a>验证(Verify)</h4><ol><li> 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。不合法会报verifyerror</li><li> 主要包括四种验证：<strong>文件格式验证，元数据验证，字节码验证，符号引用验证</strong>。</li></ol><p><strong>举例</strong></p><p>使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。</p><h4 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备(Prepare)"></a>准备(Prepare)</h4><ol><li> 为类变量（static<strong>变量</strong>）分配内存并且设置该类变量的<strong>默认初始值</strong>，即零值</li><li> 这里不包含用final修饰的static（这个就不是变量而是常量），因为final在<strong>编译的时候就会分配好了默认值</strong>，准备阶段会显式初始化</li><li> 注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li></ol><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//prepare阶段只是给a赋值为0，initial初始化阶段才为1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析(Resolve)"></a>解析(Resolve)</h4><ol><li><p> <strong>将常量池内的符号引用转换为直接引用的过程</strong></p></li><li><p> 事实上，<strong>解析操作往往会伴随着JVM在执行完初始化之后再执行</strong></p></li><li><p> 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p></li><li><p> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p></li></ol><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><h4 id="类的初始化时机-类的主动使用和被动使用"><a href="#类的初始化时机-类的主动使用和被动使用" class="headerlink" title="类的初始化时机/类的主动使用和被动使用"></a>类的初始化时机/类的主动使用和被动使用</h4><p>Java程序对类的使用方式分为：主动使用和被动使用</p><h5 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h5><ol><li><p><strong>创建</strong>类的实例(造对象)</p></li><li><p><strong>访问</strong>某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p><strong>调用</strong>类的静态方法</p></li><li><p><strong>反射主动加载</strong>（比如：Class.forName(“com.atguigu.Test”)）</p></li><li><p>初始化一个类的子类（父类也会主动使用）</p></li><li><p>Java虚拟机启动时<strong>被标明为启动类的类</strong></p></li><li><p>JDK7开始提供的<strong>动态语言支持</strong></p><p>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</p></li></ol><h5 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h5><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，<strong>都不会导致类的初始化</strong>，即不会执行初始化阶段（==不会调用 clinit() 方法和 init() 方法==）</p><blockquote><p>会加载，但不会初始化，因为有静态代码块的执行等</p></blockquote><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li><p> 初始化阶段就是执行<strong>类构造器方法</strong><code>&lt;clinit&gt;()</code>的过程</p></li><li><p> 此方法不需定义，是<strong>javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句==合并==而来</strong>。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</p></li><li><p> <code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</p></li><li><p> <code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>（类的<strong>构造器函数</strong>））</p></li><li><p> 若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code><strong>执行</strong>前，父类的<code>&lt;clinit&gt;()</code>已经<strong>执行完毕</strong></p></li><li><p> 虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁（一个类只会被加载一次）</p></li></ol><h4 id="1，2，3说明"><a href="#1，2，3说明" class="headerlink" title="1，2，3说明"></a>1，2，3说明</h4><p><strong>举例1：有static变量</strong></p><p>查看下面这个代码的字节码，可以发现有一个<code>&lt;clinit&gt;()</code>方法。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0009.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       num = <span class="number">2</span>;</span><br><span class="line">       number = <span class="number">20</span>;</span><br><span class="line">       System.out.println(num);</span><br><span class="line">       <span class="comment">//System.out.println(number);//报错：非法的前向引用。</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span></span><br><span class="line"><span class="comment">    * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会</span></span><br><span class="line"><span class="comment">    * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);<span class="comment">//2</span></span><br><span class="line">        System.out.println(ClassInitTest.number);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&lt;clint字节码&gt;：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> 1 putstatic #3 &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"> <span class="number">4</span> iconst_2</span><br><span class="line"> 5 putstatic #3 &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"> <span class="number">8</span> bipush <span class="number">20</span> <span class="comment">//先赋20</span></span><br><span class="line">10 putstatic #5 &lt;com/atguigu/java/ClassInitTest.number&gt;</span><br><span class="line">13 getstatic #2 &lt;java/lang/System.out&gt;</span><br><span class="line">16 getstatic #3 &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line">19 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">22</span> bipush <span class="number">10</span><span class="comment">//再赋10</span></span><br><span class="line">24 putstatic #5 &lt;com/atguigu/java/ClassInitTest.number&gt;</span><br><span class="line"><span class="number">27</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>当我们代码中包含static变量的时候，就会有clinit方法</p><p><strong>举例2：无 static 变量</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0010.png"><p>加上之后就有了</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0011.png"><h4 id="4说明"><a href="#4说明" class="headerlink" title="4说明"></a>4说明</h4><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0012.png"><p>在构造器中：</p><ul><li>先将类变量 a 赋值为 10</li><li>再将局部变量赋值为 20</li></ul><h4 id="5说明"><a href="#5说明" class="headerlink" title="5说明"></a>5说明</h4><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0013.png"><p>如上代码，加载流程如下：</p><ul><li>首先，执行 main() 方法需要加载 ClinitTest1 类</li><li>获取 Son.B 静态变量，需要加载 Son 类</li><li>Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载</li></ul><h4 id="6说明"><a href="#6说明" class="headerlink" title="6说明"></a>6说明</h4><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被<strong>同步加锁</strong></p><ul><li>类往内存的加载，只加载一次，加载到方法区</li><li>再使用，使用内存中类本身</li><li>因此一个类加载只调用一次clinit方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">            DeadThread dead = <span class="keyword">new</span> DeadThread();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程2开始</span><br><span class="line">线程1开始</span><br><span class="line">线程2初始化当前类</span><br><span class="line"></span><br><span class="line">&#x2F;然后程序卡死了</span><br></pre></td></tr></table></figure><p>程序卡死，分析原因：</p><ul><li>  两个线程<strong>同时去加载 DeadThread 类</strong>，而 DeadThread 类中静态代码块中有一处死循环</li><li>  <strong>先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放</strong></li><li>  所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）</li></ul><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol><li><p>JVM严格来讲支持两种类型的类加载器 。分别为<strong>引导类加载器</strong>（Bootstrap ClassLoader）和<strong>自定义类加载器</strong>（User-Defined ClassLoader）</p></li><li><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有==派生于抽象类ClassLoader的类加载器==都划分为自定义类加载器</strong></p></li><li><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</p></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0014.png"><p><strong>ExtClassLoader</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0015.png"><p><strong>AppClassLoader</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0016.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2 Launcher内部类</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器 包含关系</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//试图获取其上层：获取不到引导类加载器</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        <span class="comment">// 反射</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        ClassLoader classLoader1 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，<strong>因为引导类加载器右 C/C++ 语言，我们获取不到</strong></li><li>  Java的核心类库都是使用引导类加载器进行加载的</li><li>  两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明<strong>系统类加载器是全局唯一的</strong></li></ul><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><blockquote><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p></blockquote><ol><li> 这个类加载使用C/C++语言实现的，<strong>嵌套在JVM内部</strong></li><li> 它用来<strong>加载Java的核心库</strong>（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于<strong>提供JVM自身需要的类</strong></li><li> 并<strong>不继承自java.lang.ClassLoader，没有父加载器</strong></li><li> <strong>加载==扩展类和应用程序类加载器==，并作为他们的父类加载器</strong></li><li> 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ol><h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><blockquote><p><strong>扩展类加载器（Extension ClassLoader）</strong></p></blockquote><ol><li> <strong>Java语言编写</strong>，由sun.misc.Launcher$ExtClassLoader实现</li><li> <strong>派生于ClassLoader类</strong></li><li> 父类加载器为启动类加载器</li><li> 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。<strong>如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</strong></li></ol><h4 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h4><blockquote><p><strong>应用程序类加载器（也称为系统类加载器，AppClassLoader）</strong></p></blockquote><ol><li> Java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li> <strong>派生于ClassLoader类</strong></li><li> 父类加载器为扩展类加载器</li><li> 它<strong>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</strong></li><li> <strong>该类加载是程序中默认的类加载器</strong>，一般来说，Java应用的类都是由它来完成加载</li><li> 通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;**********启动类加载器**************&quot;</span>);</span><br><span class="line">        <span class="comment">//获取BootstrapClassLoader能够加载的api的路径</span></span><br><span class="line">        URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL element : urLs) &#123;</span><br><span class="line">            System.out.println(element.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span></span><br><span class="line">        ClassLoader classLoader = Provider.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***********扩展类加载器*************&quot;</span>);</span><br><span class="line">        String extDirs = System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String path : extDirs.split(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span></span><br><span class="line">        ClassLoader classLoader1 = CurveDB.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**********启动类加载器**************</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/resources.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/rt.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/sunrsasign.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/jsse.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/jce.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/charsets.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/jfr.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/classes</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">***********扩展类加载器*************</span><br><span class="line">C:\Program Files\Java\jdk1<span class="number">.8</span><span class="number">.0_131</span>\jre\lib\ext</span><br><span class="line">C:\Windows\Sun\Java\lib\ext</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@29453f44</span><br></pre></td></tr></table></figure><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><h4 id="什么时候需要自定义类加载器？"><a href="#什么时候需要自定义类加载器？" class="headerlink" title="什么时候需要自定义类加载器？"></a>什么时候需要自定义类加载器？</h4><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来<strong>定制类的加载方式</strong>。那为什么还需要自定义类加载器？</p><ol><li> 隔离加载类（中间件模块之间是隔离的，比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了（就要类仲裁）。不过<strong>一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间件之间是隔离的</strong>）</li><li> 修改类加载的方式</li><li> 扩展加载源（还可以考虑<strong>从数据库中加载类，路由器等等不同的地方加载</strong>）</li><li> 防止源码泄漏（<strong>对字节码文件进行<em>解密</em>，自己用的时候通过自定义类加载器来对其进行解密</strong>）</li></ol><h4 id="用户自定义类加载器实现步骤"><a href="#用户自定义类加载器实现步骤" class="headerlink" title="用户自定义类加载器实现步骤"></a>用户自定义类加载器实现步骤</h4><ol><li> 开发人员可以通过<strong>继承抽象类java.lang.ClassLoader类</strong>的方式，实现自己的类加载器，以满足一些特殊的需求</li><li> 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议<strong>把自定义的类加载逻辑写在findclass()方法中</strong></li><li> 在编写自定义类加载器时，<strong>如果没有太过于复杂的需求，可以直接继承URIClassLoader类</strong>，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><p>后详细</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//defineClass和findClass搭配使用</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//自定义流的获取方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassFromCustomPath(String name) &#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>, <span class="keyword">true</span>, customClassLoader);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><blockquote><p><strong>ClassLoader 类介绍</strong></p></blockquote><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（自定义类，不包括启动类加载器）</p><p><img src="images/image-20210204000243579.png" alt="image-20210204000243579"></p><p>sun.misc.Launcher它是一个java虚拟机的入口应用，扩展类和系统加载类都是其内部类</p><p><img src="images/image-20210204000529087.png" alt="image-20210204000529087"></p><h4 id="获取ClassLoader途径"><a href="#获取ClassLoader途径" class="headerlink" title="获取ClassLoader途径"></a>获取ClassLoader途径</h4><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0019.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.</span></span><br><span class="line">            ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            <span class="comment">//2.</span></span><br><span class="line">            ClassLoader classLoader1 = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            System.out.println(classLoader1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.</span></span><br><span class="line">            ClassLoader classLoader2 = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">            System.out.println(classLoader2);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="双亲委派机制原理"><a href="#双亲委派机制原理" class="headerlink" title="双亲委派机制原理"></a>双亲委派机制原理</h3><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说<strong>当需要使用该类时才会将它的class文件<em>加载到内存生成class对象</em></strong>。而且加载某个类的class文件时，Java虚拟机采用的是**==双亲委派模式，即把请求交由父类处理，它是一种任务委派模式==**</p><ol><li> 如果一个类加载器收到了类加载请求，它<strong>并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</strong>；（如扩展类加载器）</li><li> 如果父类加载器还存在其父类加载器，则<strong>进一步向上委托</strong>，依次递归，请求最终将到达顶层的启动类加载器；（如到引导类加载器）</li><li> 如果<strong>父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载</strong>，这就是双亲委派模式。</li><li> 父类加载器一层一层往下分配任务，<strong>如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</strong></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0020.png"><h3 id="双亲委派机制代码演示"><a href="#双亲委派机制代码演示" class="headerlink" title="双亲委派机制代码演示"></a>双亲委派机制代码演示</h3><h4 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h4><p>1、我们自己建立一个 java.lang.String 类，写上 static 代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        java.lang.String str = <span class="keyword">new</span> java.lang.String();</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,atguigu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        StringTest test = <span class="keyword">new</span> StringTest();</span><br><span class="line">        System.out.println(test.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello,atguigu.com</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><p>程序并没有输出我们静态代码块中的内容，可见<em>仍然加载的是 JDK 自带的 String 类</em>。</p><p>把刚刚的类改一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0021.png"><blockquote><p>由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader引导类加载器，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，<strong>在那个String类中并没有 main() 方法</strong>，所以就报了上面的错误。</p></blockquote><h4 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShkStart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br><span class="line">at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="number">662</span>)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">761</span>)</span><br><span class="line">at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:<span class="number">142</span>)</span><br><span class="line">at java.net.URLClassLoader.defineClass(URLClassLoader.java:<span class="number">467</span>)</span><br><span class="line">at java.net.URLClassLoader.access$<span class="number">100</span>(URLClassLoader.java:<span class="number">73</span>)</span><br><span class="line">at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">368</span>)</span><br><span class="line">at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">362</span>)</span><br><span class="line">at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">361</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">335</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:<span class="number">495</span>)</span><br><span class="line">Error: A JNI error has occurred, please check your installation and <span class="keyword">try</span> again</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> </span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制</strong></p><h4 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h4><p>当我们加载jdbc.jar 用于实现数据库连接的时候</p><ol><li><p>我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api</p></li><li><p>然后使用双亲委派机制，引导类加载器把rt.jar包加载进来，而<strong>rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类</strong>了</p></li><li><p><strong>具体的实现类就涉及到了某些第三方的jar包</strong>，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】</p></li><li><p><strong>==第三方的jar包中的类不属于核心api，属于系统类加载器来加载==</strong></p><blockquote><p>出现反向委派，系统类加载器，由当前线程上下文类加载器来加载具体实现类的api</p></blockquote></li><li><p>从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载</p></li></ol><p><img src="images/image-20210204001822391.png" alt="image-20210204001822391"></p><h3 id="双亲委派机制优势"><a href="#双亲委派机制优势" class="headerlink" title="双亲委派机制优势"></a>双亲委派机制优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p><ol><li><p>避免类的重复加载（类的层次关系来避免重复加载（只加载一次））</p></li><li><p>保护程序安全，防止核心API被随意篡改</p><ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ol><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><ul><li>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li><li>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a>如何判断两个class对象是否相同？</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li> 类的<strong>完整类名</strong>必须一致，<strong>包括包名</strong></li><li> <strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li></ol><blockquote><p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</p></blockquote><h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><ol><li><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</p><blockquote><ul><li><p><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></p></li><li><p>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（动态链接需要，后面讲）</p></li></ul></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第2章：类加载子系统&quot;&gt;&lt;a href=&quot;#第2章：类加载子系统&quot; class=&quot;headerlink&quot; title=&quot;第2章：类加载子系统&quot;&gt;&lt;/a&gt;第2章：类加载子系统&lt;/h1&gt;&lt;h2 id=&quot;内存结构概述&quot;&gt;&lt;a href=&quot;#内存结构概述&quot; class=&quot;</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="类加载子系统" scheme="https://www.gtxhjh.cn/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Flume自定义Sink</title>
    <link href="https://www.gtxhjh.cn/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Sink/"/>
    <id>https://www.gtxhjh.cn/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Sink/</id>
    <published>2021-02-07T07:56:25.000Z</published>
    <updated>2021-02-07T08:01:25.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flume自定义组件-Sink"><a href="#Flume自定义组件-Sink" class="headerlink" title="Flume自定义组件-Sink"></a>Flume自定义组件-Sink</h1><blockquote><p>Sink <strong>不断地轮询</strong> Channel 中的事件且<strong>批量地移除</strong>它们，并将这些事件批量写入到存储或索引系统、或者被发送到另一个 Flume Agent</p><p>Sink是完全事务性的。在从 Channel批量删除数据之前，每个 Sink用 Channel 启动一个事务。批量事件一旦成功写出到存储系统或下一个 Flume Agent，Sink就利用 Channel提交事务。<strong>事务一旦被提交，该 Channel从自己的内部缓冲区删除事件（否则重复数据）</strong>。 </p></blockquote><p>Sink组件目的地包括 hdfs、logger、avro、thrift、ipc、file、null、HBase、solr、自定义。官方提供的 Sink 类型已经很多，但是有时候并不能满足实际开发当中的需求，此时我们就需要根据实际需求自定义某些Sink。 </p><p>官方也提供了自定义 sink的接口： <a href="https://flume.apache.org/FlumeDeveloperGuide.html#sink">https://flume.apache.org/FlumeDeveloperGuide.html#sink</a> </p><blockquote><p>根据官方说明自定义MySink需要继承AbstractSink类并实现Configurable 接口。 </p><p>实现相应方法：<br>configure(Context context)//初始化context（读取配置文件内容） </p><p>process()//从Channel读取获取数据（event），这个方法将被循环调用。 </p><p>使用场景：读取 Channel数据写入MySQL或者其他文件系统。</p></blockquote><h2 id="自定义Sink"><a href="#自定义Sink" class="headerlink" title="自定义Sink"></a>自定义Sink</h2><h3 id="案例需求"><a href="#案例需求" class="headerlink" title="案例需求"></a>案例需求</h3><p>使用 flume接收数据，并在 Sink端给每条数据添加前缀和后缀，输出到控制台。前后缀可在flume任务配置文件中配置。 </p><h3 id="步骤示意图"><a href="#步骤示意图" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Sink/image-20210207113405264.png" alt="image-20210207113405264"></p><ol><li><p>自定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hjh.sink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flume.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.conf.Configurable;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.sink.AbstractSink;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 家慧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-02-07 14:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySink</span> <span class="keyword">extends</span> <span class="title">AbstractSink</span> <span class="keyword">implements</span> <span class="title">Configurable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义两个属性，前后缀</span></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String subfix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取logger对象</span></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(MySink.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置文件，为前后缀赋值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-07 14:43:46</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        prefix = context.getString(<span class="string">&quot;prefix&quot;</span>);</span><br><span class="line">        subfix = context.getString(<span class="string">&quot;subfix&quot;</span>, <span class="string">&quot;hjh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.获取channel</span></span><br><span class="line"><span class="comment">     * 2.从channel获取事务以及数据</span></span><br><span class="line"><span class="comment">     * 3.发送数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-07 14:45:12 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> EventDeliveryException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取返回值</span></span><br><span class="line">        Status status = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 2.获取channel</span></span><br><span class="line">        Channel channel = getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.从channel获取事务</span></span><br><span class="line">        Transaction transaction = channel.getTransaction();</span><br><span class="line">        <span class="comment">// 4.开启事务</span></span><br><span class="line">        transaction.begin();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 5.从channel获取数据</span></span><br><span class="line">            Event event = channel.take();</span><br><span class="line">            <span class="comment">// 6.处理事件</span></span><br><span class="line">            <span class="keyword">if</span> (event != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 事件体</span></span><br><span class="line">                String body = <span class="keyword">new</span> String(event.getBody());</span><br><span class="line">                <span class="comment">// 不用sout，用logger，需要logger对象</span></span><br><span class="line">                <span class="comment">// 调用各种级别的日志：info error debug warn</span></span><br><span class="line">                logger.info( prefix + body + subfix);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7.提交事务, 成功状态</span></span><br><span class="line">            transaction.commit();</span><br><span class="line">            status = Status.READY;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ChannelException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 提交失败, 回滚</span></span><br><span class="line">            transaction.rollback();</span><br><span class="line">            status = Status.BACKOFF;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭事务</span></span><br><span class="line">            transaction.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打包</p></li><li><p>配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a1.sources.r1.type &#x3D; netcat </span><br><span class="line">a1.sources.r1.bind &#x3D; localhost </span><br><span class="line">a1.sources.r1.port &#x3D; 44444 </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a1.sinks.k1.type &#x3D; com.atguigu.MySink </span><br><span class="line">#a1.sinks.k1.prefix &#x3D; atguigu: </span><br><span class="line">a1.sinks.k1.suffix &#x3D; :atguigu </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;flume-ng agent -c conf&#x2F; -f job&#x2F;mysink.conf -n a1 -Dflume.root.logger&#x3D;INFO,console </span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flume自定义组件-Sink&quot;&gt;&lt;a href=&quot;#Flume自定义组件-Sink&quot; class=&quot;headerlink&quot; title=&quot;Flume自定义组件-Sink&quot;&gt;&lt;/a&gt;Flume自定义组件-Sink&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Sink </summary>
      
    
    
    
    <category term="Flume" scheme="https://www.gtxhjh.cn/categories/Flume/"/>
    
    
    <category term="flume" scheme="https://www.gtxhjh.cn/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>Flume自定义Source</title>
    <link href="https://www.gtxhjh.cn/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Source/"/>
    <id>https://www.gtxhjh.cn/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Source/</id>
    <published>2021-02-07T07:56:15.000Z</published>
    <updated>2021-02-07T08:01:08.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flume自定义组件-Source"><a href="#Flume自定义组件-Source" class="headerlink" title="Flume自定义组件-Source"></a>Flume自定义组件-Source</h1><h2 id="自定义Source"><a href="#自定义Source" class="headerlink" title="自定义Source"></a>自定义Source</h2><blockquote><p>Source是负责接收数据到Flume Agent的组件。Source组件可以处理各种类型、各种格式的日志数据，包括avro、thrift、exec、jms、spooling directory、netcat、sequence generator、syslog、http、legacy。官方提供的 source类型已经很多，但是有时候并不能满足实际开发当中的需求，此时我们就需要根据实际需求自定义某些source。</p></blockquote><p>官方提供了自定义 source的接口： </p><p><a href="https://flume.apache.org/FlumeDeveloperGuide.html#source">https://flume.apache.org/FlumeDeveloperGuide.html#source</a> 根据官方说明自定义MySource</p><blockquote><p>需要继承AbstractSource类并实现Configurable 和PollableSource 接口</p><p>实现相应方法：<br>getBackOffSleepIncrement()//暂不用<br>getMaxBackOffSleepInterval()//暂不用<br>configure(Context context)//初始化context（读取配置文件内容，加载） </p><p>process()//获取数据，封装成 event并写入channel，这个方法将被循环调用， <strong>使用场景</strong>：读取 MySQL数据或者其他文件系统。 </p></blockquote><h3 id="案例需求"><a href="#案例需求" class="headerlink" title="案例需求"></a>案例需求</h3><p>使用flume接收数据，并给每条数据添加前缀，输出到控制台。前缀可从 flume配置文件中配置。 </p><p><img src="/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Source/image-20210206160459714.png" alt="image-20210206160459714"></p><h3 id="步骤示意图"><a href="#步骤示意图" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Source/image-20210206155115381.png" alt="image-20210206155115381"></p><ol><li><p>依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flume<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flume-ng-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>自定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> source;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flume.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.EventDeliveryException;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.PollableSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.conf.Configurable;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.event.SimpleEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.source.AbstractSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 家慧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-02-07 11:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySource</span> <span class="keyword">extends</span> <span class="title">AbstractSource</span> <span class="keyword">implements</span> <span class="title">Configurable</span>, <span class="title">PollableSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义全局的前缀&amp;后缀</span></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String subfix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置信息, 给前后缀赋值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-07 12:24:46</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        prefix = context.getString(<span class="string">&quot;prefix&quot;</span>);</span><br><span class="line">        subfix = context.getString(<span class="string">&quot;subfix&quot;</span>, <span class="string">&quot;hjh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.接收数据(for循环造数据)</span></span><br><span class="line"><span class="comment">     * 2.封装为事件</span></span><br><span class="line"><span class="comment">     * 3,将事件传给channel</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-07 12:05:19</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> EventDeliveryException </span>&#123;</span><br><span class="line">        Status status = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 1.接收数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 2.构造事件对象</span></span><br><span class="line">                SimpleEvent event = <span class="keyword">new</span> SimpleEvent();</span><br><span class="line">                <span class="comment">// 3.给事件设置值</span></span><br><span class="line">                event.setBody((prefix+ <span class="string">&quot;--&quot;</span> + i + <span class="string">&quot;--&quot;</span> + subfix).getBytes());</span><br><span class="line">                <span class="comment">// 4.将事件传给channel</span></span><br><span class="line">                getChannelProcessor().processEvent(event);</span><br><span class="line">                status = Status.READY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            status = Status.BACKOFF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getBackOffSleepIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxBackOffSleepInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>打包</p></li><li><p>配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a1.sources.r1.type &#x3D; com.atguigu.MySource </span><br><span class="line">a1.sources.r1.delay &#x3D; 1000 </span><br><span class="line">#a1.sources.r1.field &#x3D; atguigu </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a1.sinks.k1.type &#x3D; logger </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br></pre></td></tr></table></figure></li><li><p>开启</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;flume-ng agent -c conf&#x2F; -f job&#x2F;mysource.conf -n a1 -Dflume.root.logger&#x3D;INFO,console</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flume自定义组件-Source&quot;&gt;&lt;a href=&quot;#Flume自定义组件-Source&quot; class=&quot;headerlink&quot; title=&quot;Flume自定义组件-Source&quot;&gt;&lt;/a&gt;Flume自定义组件-Source&lt;/h1&gt;&lt;h2 id=&quot;自定义So</summary>
      
    
    
    
    <category term="Flume" scheme="https://www.gtxhjh.cn/categories/Flume/"/>
    
    
    <category term="flume" scheme="https://www.gtxhjh.cn/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>Flume自定义拦截器</title>
    <link href="https://www.gtxhjh.cn/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>https://www.gtxhjh.cn/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2021-02-07T07:56:01.000Z</published>
    <updated>2021-02-07T08:00:50.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flume自定义组件-Interceptor"><a href="#Flume自定义组件-Interceptor" class="headerlink" title="Flume自定义组件-Interceptor"></a>Flume自定义组件-Interceptor</h1><h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><h3 id="案例需求"><a href="#案例需求" class="headerlink" title="案例需求"></a>案例需求</h3><blockquote><p>使用Flume采集服务器本地日志，需要安装日志类型的不同，将不同种类的日志发往不同的分析系统</p></blockquote><p>如实际开发中，一台服务器产生的日志类型可能有不同种，不同类型的日志可能需要发送到不同的分析系统，可以用到Flume拓扑结构中的Multiplexing结构(channel选择器)</p><blockquote><p><strong>Multiplexing的原理</strong>：根据event中Header的某个key值，将不同的event发送到不同的channel</p><p>因此需要<strong>自定义一个Interceptor，为不同类型的event的Header中的key赋予不同的值</strong></p></blockquote><p>在该案例中，我们以端口数据模拟日志，以数字（单个）和字母（单个）模拟不同类型的日志，我们需要自定义 interceptor 区分数字和字母，将其分别发往不同的分析系统（Channel）。 </p><h3 id="步骤示意图"><a href="#步骤示意图" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/image-20210206141255716.png" alt="image-20210206141255716"></p><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flume<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flume-ng-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>定义拦截器类并实现Interceptor接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hjh.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flume.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.Event;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.interceptor.Interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-02-06 14:37:16</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明一个存放事件的集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Event&gt; addHeaderEvents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-06 14:48:15</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        addHeaderEvents = <span class="keyword">new</span> ArrayList&lt;Event&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个事件拦截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-06 14:47:42 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event 接口,需要实现类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">intercept</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取事件中的头信息</span></span><br><span class="line">        Map&lt;String, String&gt; headers = event.getHeaders();</span><br><span class="line">        <span class="comment">// 2.获取事件中的body信息</span></span><br><span class="line">        String body = <span class="keyword">new</span> String(event.getBody());</span><br><span class="line">        <span class="comment">// 3.根据body总是否有&quot;hello&quot;来决定添加怎样的头信息</span></span><br><span class="line">        <span class="keyword">if</span> (body.contains(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 4.添加头信息</span></span><br><span class="line">            headers.put(<span class="string">&quot;type&quot;</span>,<span class="string">&quot;hjh&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4.添加头信息</span></span><br><span class="line">            headers.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;bigdata&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回事件</span></span><br><span class="line">        <span class="keyword">return</span> event;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量事件拦截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-06 14:50:19</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Event&gt; <span class="title">intercept</span><span class="params">(List&lt;Event&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.清空集合</span></span><br><span class="line">        addHeaderEvents.clear();</span><br><span class="line">        <span class="comment">// 2.遍历events，给每一个事件添加头信息</span></span><br><span class="line">        <span class="keyword">for</span> (Event event : list) &#123;</span><br><span class="line">            <span class="comment">// 3.给每个事件添加头信息</span></span><br><span class="line">            addHeaderEvents.add(intercept(event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.返回结果</span></span><br><span class="line">        <span class="keyword">return</span> addHeaderEvents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-06 14:54:16</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 把构造方法私有化</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@date</span> 2021-02-06 14:54:54</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Interceptor <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TypeInterceptor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 配置方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@date</span> 2021-02-06 14:54:28</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打包，放入集群(flume/lib)</p></li><li><p>配置文件</p><p>为hadoop102上的Flume1配置1个netcat source，1个sink group（2个 avro sink），并配置相应的ChannelSelector和interceptor。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 k2 </span><br><span class="line"># 两个，有选择</span><br><span class="line">a1.channels &#x3D; c1 c2 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a1.sources.r1.type &#x3D; netcat </span><br><span class="line">a1.sources.r1.bind &#x3D; localhost </span><br><span class="line">a1.sources.r1.port &#x3D; 44444 </span><br><span class="line"></span><br><span class="line"># 关键</span><br><span class="line"># 拦截器</span><br><span class="line">a1.sources.r1.interceptors &#x3D; i1 </span><br><span class="line"># 静态内部类</span><br><span class="line">a1.sources.r1.interceptors.i1.type &#x3D; com.hjh.interceptor.TypeInterceptor$Builder </span><br><span class="line"></span><br><span class="line"># channel selector</span><br><span class="line">a1.sources.r1.selector.type &#x3D; multiplexing </span><br><span class="line"># 与header的key对应</span><br><span class="line">a1.sources.r1.selector.header &#x3D; type</span><br><span class="line"># 与header的value对应</span><br><span class="line">a1.sources.r1.selector.mapping.hjh &#x3D; c1 </span><br><span class="line">a1.sources.r1.selector.mapping.bigdata &#x3D; c2 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a1.sinks.k1.type &#x3D; avro </span><br><span class="line">a1.sinks.k1.hostname &#x3D; hadoop103 </span><br><span class="line">a1.sinks.k1.port &#x3D; 4141 </span><br><span class="line"></span><br><span class="line">a1.sinks.k2.type&#x3D;avro </span><br><span class="line">a1.sinks.k2.hostname &#x3D; hadoop104 </span><br><span class="line">a1.sinks.k2.port &#x3D; 4242 </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory </span><br><span class="line">a1.channels.c2.type &#x3D; memory </span><br><span class="line">a1.channels.c2.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c2.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 c2 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br><span class="line">a1.sinks.k2.channel &#x3D; c2 </span><br></pre></td></tr></table></figure><p>为hadoop103上的Flume2配置一个avro source 和一个logger sink。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line">a1.sources.r1.type &#x3D; avro </span><br><span class="line">a1.sources.r1.bind &#x3D; hadoop103 </span><br><span class="line">a1.sources.r1.port &#x3D; 4141 </span><br><span class="line"></span><br><span class="line">a1.sinks.k1.type &#x3D; logger </span><br><span class="line"></span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br></pre></td></tr></table></figure><p>为hadoop104上的Flume3配置一个avro source 和一个logger sink。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line">a1.sources.r1.type &#x3D; avro </span><br><span class="line">a1.sources.r1.bind &#x3D; hadoop104</span><br><span class="line">a1.sources.r1.port &#x3D; 4242</span><br><span class="line"></span><br><span class="line">a1.sinks.k1.type &#x3D; logger </span><br><span class="line"></span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br></pre></td></tr></table></figure></li><li><p>分别在hadoop102，hadoop103，hadoop104上启动 flume进程，注意先后顺序</p></li><li><p>在hadoop102使用 netcat向localhost:44444发送字母和数字。 </p></li><li><p>观察hadoop103和 hadoop104打印的日志</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flume自定义组件-Interceptor&quot;&gt;&lt;a href=&quot;#Flume自定义组件-Interceptor&quot; class=&quot;headerlink&quot; title=&quot;Flume自定义组件-Interceptor&quot;&gt;&lt;/a&gt;Flume自定义组件-Intercept</summary>
      
    
    
    
    <category term="Flume" scheme="https://www.gtxhjh.cn/categories/Flume/"/>
    
    
    <category term="flume" scheme="https://www.gtxhjh.cn/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>第二章 Flume进阶（2）</title>
    <link href="https://www.gtxhjh.cn/2021/02/05/Flume%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89/"/>
    <id>https://www.gtxhjh.cn/2021/02/05/Flume%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89/</id>
    <published>2021-02-05T08:58:34.000Z</published>
    <updated>2021-02-05T09:00:20.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-Flume进阶（2）"><a href="#第二章-Flume进阶（2）" class="headerlink" title="第二章 Flume进阶（2）"></a>第二章 Flume进阶（2）</h1><blockquote><p>下用实例来进行Flume学习</p></blockquote><h2 id="复制和多路复用案例"><a href="#复制和多路复用案例" class="headerlink" title="复制和多路复用案例"></a>复制和多路复用案例</h2><blockquote><p>使用 Flume-1 监控文件变动，Flume-1 将变动内容传递给 Flume-2（Avro Sink），（Avro Source）Flume-2 负责存储到HDFS。同时Flume-1将变动内容传递给Flume-3（Avro Sink），（Avro Source）Flume-3负责输出到Local FileSystem</p></blockquote><h3 id="步骤示意图"><a href="#步骤示意图" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/05/Flume%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89/image-20210205151801258.png" alt="image-20210205151801258"></p><ol><li><p>配置文件</p><p>配置一个接收日志文件的source和两个channel、两个sink，分别输送给flume-flume-hdfs和flume-flume-dir</p><ul><li><p>flume-file-flume.conf </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 k2 </span><br><span class="line">a1.channels &#x3D; c1 c2 </span><br><span class="line"></span><br><span class="line"># 将数据流复制给所有channel</span><br><span class="line">a1.sources.r1.selector.type &#x3D; replicating </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a1.sources.r1.type &#x3D; exec </span><br><span class="line">a1.sources.r1.command &#x3D; tail -F &#x2F;opt&#x2F;module&#x2F;hive&#x2F;logs&#x2F;hive.log a1.sources.r1.shell &#x3D; &#x2F;bin&#x2F;bash -c </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line"># sink端的avro是一个数据发送者</span><br><span class="line">a1.sinks.k1.type &#x3D; avro </span><br><span class="line">a1.sinks.k1.hostname &#x3D; hadoop102 </span><br><span class="line">a1.sinks.k1.port &#x3D; 4141 </span><br><span class="line"></span><br><span class="line">a1.sinks.k2.type &#x3D; avro </span><br><span class="line">a1.sinks.k2.hostname &#x3D; hadoop102 </span><br><span class="line">a1.sinks.k2.port &#x3D; 4142 </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line">a1.channels.c2.type &#x3D; memory </span><br><span class="line">a1.channels.c2.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c2.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 c2 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br><span class="line">a1.sinks.k2.channel &#x3D; c2</span><br></pre></td></tr></table></figure></li><li><p>flume-flume-hdfs.conf</p><p>上级Flume输出到的Source，输出为HDFS的Sink</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a2.sources &#x3D; r1 </span><br><span class="line">a2.sinks &#x3D; k1 </span><br><span class="line">a2.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line"># source端的avro是一个数据接收服务</span><br><span class="line">a2.sources.r1.type &#x3D; avro </span><br><span class="line">a2.sources.r1.bind &#x3D; hadoop102 </span><br><span class="line">a2.sources.r1.port &#x3D; 4141 </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a2.sinks.k1.type &#x3D; hdfs </span><br><span class="line">a2.sinks.k1.hdfs.path &#x3D; hdfs:&#x2F;&#x2F;hadoop102:9000&#x2F;flume2&#x2F;%Y%m%d&#x2F;%H #上传文件的前缀</span><br><span class="line">a2.sinks.k1.hdfs.filePrefix &#x3D; flume2- </span><br><span class="line">#是否按照时间滚动文件夹</span><br><span class="line">a2.sinks.k1.hdfs.round &#x3D; true </span><br><span class="line">#多少时间单位创建一个新的文件夹</span><br><span class="line">a2.sinks.k1.hdfs.roundValue &#x3D; 1 </span><br><span class="line">#重新定义时间单位</span><br><span class="line">a2.sinks.k1.hdfs.roundUnit &#x3D; hour </span><br><span class="line">#是否使用本地时间戳</span><br><span class="line">a2.sinks.k1.hdfs.useLocalTimeStamp &#x3D; true </span><br><span class="line">#积攒多少个Event才flush到HDFS一次</span><br><span class="line">a2.sinks.k1.hdfs.batchSize &#x3D; 100 </span><br><span class="line">#设置文件类型，可支持压缩</span><br><span class="line">a2.sinks.k1.hdfs.fileType &#x3D; DataStream </span><br><span class="line">#多久生成一个新的文件</span><br><span class="line">a2.sinks.k1.hdfs.rollInterval &#x3D; 600 </span><br><span class="line">#设置每个文件的滚动大小大概是128M</span><br><span class="line">a2.sinks.k1.hdfs.rollSize &#x3D; 134217700 </span><br><span class="line">#文件的滚动与Event数量无关</span><br><span class="line">a2.sinks.k1.hdfs.rollCount &#x3D; 0 </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a2.channels.c1.type &#x3D; memory </span><br><span class="line">a2.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a2.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a2.sources.r1.channels &#x3D; c1 </span><br><span class="line">a2.sinks.k1.channel &#x3D; c1 </span><br></pre></td></tr></table></figure></li><li><p>flume-flume-dir.conf</p><p>配置上级Flume输出到的Source，输出为本地目录（需要存在）的Sink</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a3.sources &#x3D; r1 </span><br><span class="line">a3.sinks &#x3D; k1 </span><br><span class="line">a3.channels &#x3D; c2 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a3.sources.r1.type &#x3D; avro </span><br><span class="line">a3.sources.r1.bind &#x3D; hadoop102 </span><br><span class="line">a3.sources.r1.port &#x3D; 4142</span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a3.sinks.k1.type &#x3D; file_roll </span><br><span class="line">a3.sinks.k1.sink.directory &#x3D; &#x2F;opt&#x2F;module&#x2F;data&#x2F;flume3 </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a3.channels.c2.type &#x3D; memory </span><br><span class="line">a3.channels.c2.capacity &#x3D; 1000 </span><br><span class="line">a3.channels.c2.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a3.sources.r1.channels &#x3D; c2 </span><br><span class="line">a3.sinks.k1.channel &#x3D; c2 </span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a3 --conf-file job/group1/flume-flume-dir.conf </span><br><span class="line">bin/flume-ng agent --conf conf/ --name a2 --conf-file job/group1/flume-flume-hdfs.conf </span><br><span class="line">bin/flume-ng agent --conf conf/ --name a1 --conf-file job/group1/flume-file-flume.conf </span><br></pre></td></tr></table></figure></li><li><p>启动Hadoop和Hive</p></li><li><p>检查HDFS数据</p></li></ol><h2 id="负载均衡和故障转移案例"><a href="#负载均衡和故障转移案例" class="headerlink" title="负载均衡和故障转移案例"></a>负载均衡和故障转移案例</h2><blockquote><p>使用 Flume1 监控一个端口，其 sink 组中的 sink 分别对接 Flume2 和 Flume3，采用FailoverSinkProcessor，实现故障转移的功能。</p></blockquote><h3 id="步骤示意图-1"><a href="#步骤示意图-1" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/05/Flume%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89/image-20210205153444280.png" alt="image-20210205153444280"></p><ol><li><p>配置文件</p><ul><li><p>flume-netcat-flume.conf </p><p>配置1个netcat source和 1个 channel、1个sink group（2个sink），分别输送给 flume-flume-console1和flume-flume-console2。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line">a1.sinkgroups &#x3D; g1 </span><br><span class="line">a1.sinks &#x3D; k1 k2 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a1.sources.r1.type &#x3D; netcat </span><br><span class="line">a1.sources.r1.bind &#x3D; localhost </span><br><span class="line">a1.sources.r1.port &#x3D; 44444 </span><br><span class="line"></span><br><span class="line">a1.sinkgroups.g1.processor.type &#x3D; failover a1.sinkgroups.g1.processor.priority.k1 &#x3D; 5 a1.sinkgroups.g1.processor.priority.k2 &#x3D; 10 a1.sinkgroups.g1.processor.maxpenalty &#x3D; 10000 </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a1.sinks.k1.type &#x3D; avro </span><br><span class="line">a1.sinks.k1.hostname &#x3D; hadoop102 </span><br><span class="line">a1.sinks.k1.port &#x3D; 4141</span><br><span class="line"></span><br><span class="line">a1.sinks.k2.type &#x3D; avro </span><br><span class="line">a1.sinks.k2.hostname &#x3D; hadoop102 </span><br><span class="line">a1.sinks.k2.port &#x3D; 4142 </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br><span class="line">a1.sinkgroups.g1.sinks &#x3D; k1 k2 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br><span class="line">a1.sinks.k2.channel &#x3D; c1 </span><br></pre></td></tr></table></figure><blockquote><p>processor.priority：配置优先级</p><p>加入三个Sink，优先级按顺序为k1、k2、k3</p><p>当k1宕机，那么进入失败队列，不再考虑，后选择k2，当k1复活，则与processor.maxpenalty，假如是30s，那么30s之内复活则不考虑</p></blockquote><p>如果使用<strong>负载均衡</strong>，改动如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a1.sinkgroups.g1.processor.type &#x3D; load_balance </span><br><span class="line">a1.sinkgroups.g1.processor.backoff &#x3D; true</span><br><span class="line">a1.sinkgroups.g1.processor.selector &#x3D; random</span><br></pre></td></tr></table></figure></li><li><p>flume-flume-console1.conf </p><p>配置上级Flume输出的 Source，输出是到本地控制台。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a2.sources &#x3D; r1 </span><br><span class="line">a2.sinks &#x3D; k1 </span><br><span class="line">a2.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a2.sources.r1.type &#x3D; avro </span><br><span class="line">a2.sources.r1.bind &#x3D; hadoop102 </span><br><span class="line">a2.sources.r1.port &#x3D; 4141 </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a2.sinks.k1.type &#x3D; logger </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a2.channels.c1.type &#x3D; memory </span><br><span class="line">a2.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a2.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a2.sources.r1.channels &#x3D; c1 </span><br><span class="line">a2.sinks.k1.channel &#x3D; c1 </span><br></pre></td></tr></table></figure></li><li><p>flume-flume-console2.conf </p><p>配置上级Flume输出的 Source，输出是到本地控制台。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a3.sources &#x3D; r1 </span><br><span class="line">a3.sinks &#x3D; k1 </span><br><span class="line">a3.channels &#x3D; c2 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a3.sources.r1.type &#x3D; avro </span><br><span class="line">a3.sources.r1.bind &#x3D; hadoop102 </span><br><span class="line">a3.sources.r1.port &#x3D; 4142 </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a3.sinks.k1.type &#x3D; logger </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a3.channels.c2.type &#x3D; memory </span><br><span class="line">a3.channels.c2.capacity &#x3D; 1000 </span><br><span class="line">a3.channels.c2.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a3.sources.r1.channels &#x3D; c2 </span><br><span class="line">a3.sinks.k1.channel &#x3D; c2 </span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a3 --conf-file job/group2/flume-flume-console2.conf -Dflume.root.logger=INFO,console </span><br><span class="line">bin/flume-ng agent --conf conf/ --name a2 --conf-file job/group2/flume-flume-console1.conf -Dflume.root.logger=INFO,console </span><br><span class="line">bin/flume-ng agent --conf conf/ --name a1 --conf-file job/group2/flume-netcat-flume.conf </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>向本机44444端口发送内容</p></li><li><p>查看控制台打印日志</p></li><li><p>kill Flume2，观察Flume3打印情况</p><blockquote><p>注：使用jps -ml查看Flume进程。 </p></blockquote></li></ol><h2 id="聚合案例"><a href="#聚合案例" class="headerlink" title="聚合案例"></a>聚合案例</h2><blockquote><p>hadoop102上的Flume-1监控文件/opt/module/data/group.log，<br>hadoop103上的Flume-2监控某一个端口的数据流，<br>Flume-1 与 Flume-2 将数据发送给 hadoop104 上的 Flume-3，Flume-3 将最终数据打印到控制台。</p></blockquote><h3 id="步骤示意图-2"><a href="#步骤示意图-2" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/05/Flume%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89/image-20210205163825594.png" alt="image-20210205163825594"></p><ol><li><p>配置文件</p><ol><li><p>flume1-logger-flume.conf</p><p>配置Source用于监控 hive.log文件，配置Sink输出数据到下一级Flume。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a1.sources.r1.type &#x3D; exec </span><br><span class="line">a1.sources.r1.command &#x3D; tail -F &#x2F;opt&#x2F;module&#x2F;group.log a1.sources.r1.shell &#x3D; &#x2F;bin&#x2F;bash -c </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a1.sinks.k1.type &#x3D; avro </span><br><span class="line">a1.sinks.k1.hostname &#x3D; hadoop104 </span><br><span class="line">a1.sinks.k1.port &#x3D; 4141 </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>flume2-netcat-flume.conf</p><p>配置Source监控端口 44444数据流，配置Sink数据到下一级Flume： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a2.sources &#x3D; r1 </span><br><span class="line">a2.sinks &#x3D; k1 </span><br><span class="line">a2.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a2.sources.r1.type &#x3D; netcat </span><br><span class="line">a2.sources.r1.bind &#x3D; hadoop103 </span><br><span class="line">a2.sources.r1.port &#x3D; 44444 </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a2.sinks.k1.type &#x3D; avro </span><br><span class="line">a2.sinks.k1.hostname &#x3D; hadoop104 </span><br><span class="line">a2.sinks.k1.port &#x3D; 4141 </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory </span><br><span class="line">a2.channels.c1.type &#x3D; memory </span><br><span class="line">a2.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a2.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a2.sources.r1.channels &#x3D; c1 </span><br><span class="line">a2.sinks.k1.channel &#x3D; c1 </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>flume3-flume-logger.conf</p><p>配置source用于接收 flume1与flume2发送过来的数据流，最终合并后sink到控制台。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a3.sources &#x3D; r1 </span><br><span class="line">a3.sinks &#x3D; k1 </span><br><span class="line">a3.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a3.sources.r1.type &#x3D; avro </span><br><span class="line">a3.sources.r1.bind &#x3D; hadoop104 </span><br><span class="line">a3.sources.r1.port &#x3D; 4141</span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line"># Describe the sink </span><br><span class="line">a3.sinks.k1.type &#x3D; logger </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a3.channels.c1.type &#x3D; memory </span><br><span class="line">a3.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a3.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a3.sources.r1.channels &#x3D; c1 </span><br><span class="line">a3.sinks.k1.channel &#x3D; c1 </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a3 --conf-file job/group3/flume3-flume-logger.conf -Dflume.root.logger=INFO,console </span><br><span class="line">bin/flume-ng agent --conf conf/ --name a2 --conf-file job/group3/flume1-logger-flume.conf </span><br><span class="line">bin/flume-ng agent --conf conf/ --name a1 --conf-file job/group3/flume2-netcat-flume.conf </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在hadoop103上向/opt/module目录下的group.log追加内容 </p></li><li><p>在hadoop102上向44444端口发送数据 </p></li><li><p>检查hadoop104上数据</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-Flume进阶（2）&quot;&gt;&lt;a href=&quot;#第二章-Flume进阶（2）&quot; class=&quot;headerlink&quot; title=&quot;第二章 Flume进阶（2）&quot;&gt;&lt;/a&gt;第二章 Flume进阶（2）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;下用实例来进行Fl</summary>
      
    
    
    
    <category term="Flume" scheme="https://www.gtxhjh.cn/categories/Flume/"/>
    
    
    <category term="flume" scheme="https://www.gtxhjh.cn/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>第二章 Flume进阶（1）</title>
    <link href="https://www.gtxhjh.cn/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/"/>
    <id>https://www.gtxhjh.cn/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/</id>
    <published>2021-02-04T10:00:52.000Z</published>
    <updated>2021-02-10T14:13:23.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-Flume进阶（1）"><a href="#第二章-Flume进阶（1）" class="headerlink" title="第二章 Flume进阶（1）"></a>第二章 Flume进阶（1）</h1><h2 id="Flume事务"><a href="#Flume事务" class="headerlink" title="Flume事务"></a>Flume事务</h2><p><img src="/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/image-20210204170214688.png" alt="image-20210204170214688"></p><blockquote><p>Channel是<strong>被动型</strong>的，事务主动推送事件，而输出端主动拉取事件</p></blockquote><h2 id="Flume-Agent内部原理"><a href="#Flume-Agent内部原理" class="headerlink" title="Flume Agent内部原理"></a>Flume Agent内部原理</h2><p><img src="/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/image-20210204172300521.png" alt="image-20210204172300521"></p><blockquote><p>拦截器可以配置多个，更灵活</p><p>source可以绑定多个channel，由channel选择器来选择绑定的channel，同时可以设置选择策略</p><ul><li>ChannelSelector</li></ul><p>ChannelSelector 的作用就是选出 Event将要被发往哪个 Channel。其共有两种类型，分别是Replicating（复制）和 Multiplexing（多路复用）</p><blockquote><p>ReplicatingSelector（默认） 会将同一个Event发往<strong>所有的</strong> Channel</p><p>Multiplexing 会根据<strong>相应的原则</strong>，将不同的 Event发往不同的Channel</p><p>如：</p><p>![image-20210208134618032](第二章 Flume进阶（1）.assets/image-20210208134618032.png)</p></blockquote><p>put事务就在第六步</p><p>channel可以绑定多个sink，具体给哪个sink由sink组决定</p><ul><li>SinkProcessor</li></ul><p>SinkProcessor 共 有 三 种 类 型 ， 分 别 是 DefaultSinkProcessor 、LoadBalancingSinkProcessor 和FailoverSinkProcessor </p><blockquote><p><strong>DefaultSinkProcessor</strong> 对应的是单个的 Sink</p><p>LoadBalancingSinkProcessor 和FailoverSinkProcessor 对应的是 Sink Group</p><ol><li><strong>LoadBalancingSinkProcessor</strong> 可以实现负载均衡的功能</li><li><strong>FailoverSinkProcessor</strong>可以实现故障转移的功能</li></ol></blockquote></blockquote><h2 id="Flume拓扑结构"><a href="#Flume拓扑结构" class="headerlink" title="Flume拓扑结构"></a>Flume拓扑结构</h2><h3 id="简单串联"><a href="#简单串联" class="headerlink" title="简单串联"></a>简单串联</h3><p><img src="/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/image-20210204174330299.png" alt="image-20210204174330299"></p><ul><li><p>将多个 flume (Agent)顺序连接起来了，从最初的 source 开始到最终 sink 传送的目的存储系统</p><blockquote><p>可同一台机器也可跨机器。跨机器时flume不能跨机器读磁盘，需要网络通信读取使用Sink-&gt;RPC-&gt;Source串起来</p></blockquote></li><li><p>此模式不建议桥接过多的flume数量，flume数量过多不仅<strong>会影响传输速率</strong>，而且一旦传输过程中某个节点 flume宕机，会影响整个传输系统</p></li></ul><h3 id="复制和多路复用"><a href="#复制和多路复用" class="headerlink" title="复制和多路复用"></a>复制和多路复用</h3><p><img src="/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/image-20210204174352601.png" alt="image-20210204174352601"></p><blockquote><p>单source，多channel、sink</p></blockquote><p>Flume 支持将事件流向一个或者多个目的地。这种模式可以将相同数据复制到多个channel 中，或者将不同数据分发到不同的 channel 中，sink 可以选择传送到不同的目的地。 </p><h3 id="负载均衡和故障转移"><a href="#负载均衡和故障转移" class="headerlink" title="负载均衡和故障转移"></a>负载均衡和故障转移</h3><p><img src="/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/image-20210204174418127.png" alt="image-20210204174418127"></p><blockquote><p>一个Channel多个Sink，<strong>Sink组应用</strong></p></blockquote><p>Flume支持使用将多个sink逻辑上分到一个sink组，sink组<em>配合不同的SinkProcessor</em>可以实现负载均衡和错误恢复的功能</p><ul><li>解决单个进程压力过大问题同时可以故障转移</li></ul><blockquote><p>单个Sink压力大，三个Sink轮询的方式发到三个不同的Agent，让不同的Agent写HDFS，同时3个Channel可以缓存更多</p></blockquote><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><img src="/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/image-20210204174431094.png" alt="image-20210204174431094"></p><blockquote><p>多个源头Source</p></blockquote><p>最常见的，也非常实用的模式，日常 web应用通常分布在上百个服务器，大者甚至上千个、上万个服务器，产生的日志，处理起来也非常麻烦。用 flume的这种组合方式能很好的解决这一问题。</p><blockquote><p><strong>每台服务器部署一个flume</strong> 采集日志，<strong>传送到一个集中收集日志的flume</strong>，再由此flume 上传到hdfs、hive、hbase 等，进行日志分析</p><ul><li>聚合到一台压力过大，也可以采用上个模式，降低压力</li><li>另外，一种汇总方式是每个Sink发送到<strong>同个端口</strong>，另一种是发送到<strong>不同端口</strong>，那么就有3个source来接收而这三个source绑定一个channel，也是一种聚合</li></ul><p><strong>后台多个服务器解决同一个业务，但是任何一台不可能同时处理用户多个请求，需要负载均衡，用户的请求到底给谁处理，即负载均衡。如软件层的负载均衡Nginx，轮询的发送用户请求</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-Flume进阶（1）&quot;&gt;&lt;a href=&quot;#第二章-Flume进阶（1）&quot; class=&quot;headerlink&quot; title=&quot;第二章 Flume进阶（1）&quot;&gt;&lt;/a&gt;第二章 Flume进阶（1）&lt;/h1&gt;&lt;h2 id=&quot;Flume事务&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Flume" scheme="https://www.gtxhjh.cn/categories/Flume/"/>
    
    
    <category term="flume" scheme="https://www.gtxhjh.cn/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>第一章 Flume概述</title>
    <link href="https://www.gtxhjh.cn/2021/02/04/Flume%E6%A6%82%E8%BF%B0/"/>
    <id>https://www.gtxhjh.cn/2021/02/04/Flume%E6%A6%82%E8%BF%B0/</id>
    <published>2021-02-04T10:00:19.000Z</published>
    <updated>2021-02-04T10:05:08.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-Flume概述"><a href="#第一章-Flume概述" class="headerlink" title="第一章 Flume概述"></a>第一章 Flume概述</h1><blockquote><p>Flume 是Cloudera 提供的一个高可用的，高可靠的，分布式的海量**==日志数据==采集、聚合和传输的系统**（即文本文件，图片不行）</p><p>Flume 基于流式架构，灵活简单</p></blockquote><p><img src="/2021/02/04/Flume%E6%A6%82%E8%BF%B0/image-20210204125745058-1612416154240.png" alt="image-20210204125745058"></p><p>Flume最主要的作用：**==实时==读取服务器本地磁盘的数据，将数据写入到HDFS**</p><h2 id="Flume基础架构"><a href="#Flume基础架构" class="headerlink" title="Flume基础架构"></a>Flume基础架构</h2><p><img src="/2021/02/04/Flume%E6%A6%82%E8%BF%B0/image-20210204130430497-1612416151397.png" alt="image-20210204130430497"></p><blockquote><p>方框中才是主要的Flume组件</p></blockquote><ul><li><p>Agent</p><ol><li>一个JVM进程，以<strong>事件</strong>的形式将数据从源头送至目的</li><li>主要有 3个部分组成：Source 、Channel、Sink </li></ol></li><li><p>Source（读）</p><ol><li><p>Source负责接收数据到Flume Agent的组件</p><blockquote><p>Source组件可以处理各种类型、各种格式的日志数据，包括avro、thrift、exec、jms、spooling directory、netcat、sequence generator、syslog、http、legacy </p></blockquote><p><strong>举例：</strong></p><p>Avro Source：单点故障时，希望对接另一个Flume用到，两个Flume通信，<strong>轻量RPC通道</strong></p><p>Exec Source：命令行监控</p><p>Taildir Source：监控多个目录变化的数据，监控本地文件会用到</p><p>Kafka Source：从Kafka读</p><p>NetCat</p></li></ol></li><li><p>Channel（<strong>缓冲</strong>）</p><p>Channel是位于Source 和Sink 之间的**==缓冲区==<strong>，因此，Channel允许Source 和Sink</strong>运作在不同的速率**上</p><blockquote><p>Channel 是线程安全的，可以同时处理几个 Source 的写入操作和几个Sink的读取操作</p></blockquote><p>Flume自带两种Channel：<strong>Memory Channel和 File Channel以及Kafka Channel</strong></p><ol><li>Memory Channel是<strong>内存中的队列</strong>。Memory Channel在不需要关心数据丢失的情景下适用。如果需要关心数据丢失，那么 Memory Channel就不应该使用，因为程序死亡、机器宕机或者重启都会导致数据丢失（容易坏）</li><li>File Channel 将所有事件写到磁盘。因此在程序关闭或机器宕机的情况下不会丢失数据，（但是慢）</li></ol></li><li><p>Sink（写）</p><p>Sink 不断地<em>轮询 Channel 中的事件且批量地移除它们</em>，并将这些事件<strong>批量写入到存储或索引系统、或者被发送到另一个 Flume Agent</strong></p><blockquote><p>Sink 组件目的地包括 hdfs、hive、logger、avro（avro sink到avro source）、thrift、ipc、file、HBase、solr、自定义 </p></blockquote></li><li><p>Event</p><p>传输单元，<strong>Flume 数据传输的基本单元</strong>，以 Event 的形式将数据从源头送至目的地（封装）</p><p>Event由<strong>Header</strong>和**==Body==**两部分组成</p><ul><li>Header用来存放该 event的一些<strong>属性</strong>，为 <strong>K-V结构</strong></li><li>Body用来存放该条数据，形式为<strong>字节数组</strong></li></ul><p><img src="/2021/02/04/Flume%E6%A6%82%E8%BF%B0/image-20210204132154832.png" alt="image-20210204132154832"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-Flume概述&quot;&gt;&lt;a href=&quot;#第一章-Flume概述&quot; class=&quot;headerlink&quot; title=&quot;第一章 Flume概述&quot;&gt;&lt;/a&gt;第一章 Flume概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Flume 是Cloudera 提供的一个</summary>
      
    
    
    
    <category term="Flume" scheme="https://www.gtxhjh.cn/categories/Flume/"/>
    
    
    <category term="flume" scheme="https://www.gtxhjh.cn/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>Flume部署</title>
    <link href="https://www.gtxhjh.cn/2021/02/04/Flume%E9%83%A8%E7%BD%B2/"/>
    <id>https://www.gtxhjh.cn/2021/02/04/Flume%E9%83%A8%E7%BD%B2/</id>
    <published>2021-02-04T10:00:08.000Z</published>
    <updated>2021-02-04T10:04:13.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flume部署"><a href="#Flume部署" class="headerlink" title="Flume部署"></a>Flume部署</h1><ol><li><p>flume启动只需要启动agent即可</p></li><li><p>配置conf，有官方案例，配置source、sink、channel的，案例分析如下</p><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204135115408.png" alt="image-20210204135115408"></p><blockquote><p>复数s表示可多个</p><p>前面为变量声明后面为赋值</p><p>channels和channel说明：source可以绑定多个channel，而sink只能绑定一个channel，但是一个channel可以绑定多个sink</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent   </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a1.sources.r1.type &#x3D; netcat </span><br><span class="line">a1.sources.r1.bind &#x3D; localhost </span><br><span class="line">a1.sources.r1.port &#x3D; 44444 </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a1.sinks.k1.type &#x3D; logger </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br></pre></td></tr></table></figure></li><li><p>开启Flume监听端口</p><p>法1：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a1 --conf-file job/flume-netcat-logger.conf -Dflume.root.logger=INFO,console </span><br></pre></td></tr></table></figure><p>法2：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent -c conf/ -n a1 -f job/flume-netcat-logger.conf -Dflume.root.logger=INFO,console </span><br></pre></td></tr></table></figure><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204135914136.png" alt="image-20210204135914136"></p><p>开启了一个服务端</p><p>再开启一个客户端发送消息</p><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204140530296.png" alt="image-20210204140530296"></p><p>服务端接收到</p><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204140459986.png" alt="image-20210204140459986"></p></li></ol><h2 id="监控单个追加文件"><a href="#监控单个追加文件" class="headerlink" title="监控单个追加文件"></a>监控单个追加文件</h2><blockquote><p>实时监控Hive日志，并上传到HDFS中</p></blockquote><h3 id="步骤示意图"><a href="#步骤示意图" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204141239468.png" alt="image-20210204141239468"></p><ol><li><p>Flume要想将数据输出到HDFS，须持有Hadoop相关jar包 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commons-configuration-1.6.jar、 </span><br><span class="line">hadoop-auth-2.7.2.jar、</span><br><span class="line">hadoop-common-2.7.2.jar、 </span><br><span class="line">hadoop-hdfs-2.7.2.jar、 </span><br><span class="line">commons-io-2.4.jar、</span><br><span class="line">htrace-core-3.1.0-incubating.jar </span><br></pre></td></tr></table></figure><p>拷贝到/opt/module/flume/lib文件夹下</p></li><li><p>创建flume-file-hdfs.conf配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 </span><br><span class="line">a1.channels &#x3D; c1</span><br><span class="line"></span><br><span class="line"># Describe the source</span><br><span class="line">a1.sources.r1.type &#x3D; exec</span><br><span class="line">a1.sources.r1.command &#x3D; tail -F &#x2F;opt&#x2F;module&#x2F;hive&#x2F;logs&#x2F;hive.log</span><br><span class="line"># 执行shell脚本的绝对路径</span><br><span class="line">a1.sources.r1.shell &#x3D; &#x2F;bin&#x2F;bash -c </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a1.sinks.k1.type &#x3D; hdfs</span><br><span class="line"># 路径用了年月日加小时</span><br><span class="line">a1.sink.k1.hdfs.path &#x3D;  hdfs:&#x2F;&#x2F;hadoop102:9000&#x2F;flume&#x2F;%Y%m%d&#x2F;%H</span><br><span class="line"># 上传文件的前缀</span><br><span class="line">a1.sinks.k1.hdfs.filePrefix &#x3D; logs- </span><br><span class="line"></span><br><span class="line"># 是否按照时间滚动文件夹</span><br><span class="line">a1.sinks.k1.hdfs.round &#x3D; true </span><br><span class="line"># 多少时间单位创建一个新的文件夹</span><br><span class="line">a1.sinks.k1.hdfs.roundValue &#x3D; 1 </span><br><span class="line"># 重新定义时间单位</span><br><span class="line">a1.sinks.k1.hdfs.roundUnit &#x3D; hour </span><br><span class="line"></span><br><span class="line"># 是否使用本地时间戳</span><br><span class="line">a1.sinks.k1.hdfs.useLocalTimeStamp &#x3D; true </span><br><span class="line"></span><br><span class="line"># 积攒多少个Event才flush到HDFS一次,看容量，到时间也会刷新不一定到容量</span><br><span class="line">a1.sinks.k1.hdfs.batchSize &#x3D; 1000 </span><br><span class="line"># 设置文件类型，可支持压缩,LZO也可</span><br><span class="line">a1.sinks.k1.hdfs.fileType &#x3D; DataStream </span><br><span class="line"></span><br><span class="line"># 多久生成一个新的文件</span><br><span class="line">a1.sinks.k1.hdfs.rollInterval &#x3D; 30 </span><br><span class="line"># 设置每个文件的滚动大小</span><br><span class="line">a1.sinks.k1.hdfs.rollSize &#x3D; 134217700 </span><br><span class="line"># 文件的滚动与Event数量无关</span><br><span class="line">a1.sinks.k1.hdfs.rollCount &#x3D; 0</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br></pre></td></tr></table></figure><blockquote><p>对于所有与时间相关的转义序列，Event Header中必须存在以 “timestamp”的 key（除非hdfs.useLocalTimeStamp 设置为 true，此方法会使用 TimestampInterceptor 自动添加timestamp）</p></blockquote><p>由于 Hive 日志在 Linux 系统中所以读取文件的类型选择：exec 即 execute 执行的意思。表示执行 Linux命令来读取文件。 </p></li><li><p>运行Flume</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a2 --conf-file job/flume-file-hdfs.conf</span><br></pre></td></tr></table></figure></li><li><p>开启Hadoop和Hive并操作Hive产生日志 </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br><span class="line">sbin/start-yarn.sh</span><br><span class="line">bin/hive</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt;</span><br></pre></td></tr></table></figure></li><li><p>在HDFS上查看文件</p><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204151706518.png" alt="image-20210204151706518"></p></li></ol><h2 id="监控目录下多个新文件"><a href="#监控目录下多个新文件" class="headerlink" title="监控目录下多个新文件"></a>监控目录下多个新文件</h2><blockquote><p>使用Flume监听整个目录的文件，并上传至HDFS</p></blockquote><h3 id="步骤示意图-1"><a href="#步骤示意图-1" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204152209228.png" alt="image-20210204152209228"></p><ol><li><p>配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a3.sources &#x3D; r3 </span><br><span class="line">a3.sinks &#x3D; k3 </span><br><span class="line">a3.channels &#x3D; c3 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a3.sources.r3.type &#x3D; spooldir </span><br><span class="line">a3.sources.r3.spoolDir &#x3D; &#x2F;opt&#x2F;module&#x2F;flume&#x2F;upload </span><br><span class="line"></span><br><span class="line">a3.sources.r3.fileSuffix &#x3D; .COMPLETED </span><br><span class="line">a3.sources.r3.fileHeader &#x3D; true </span><br><span class="line">#忽略所有以.tmp结尾的文件，不上传</span><br><span class="line">a3.sources.r3.ignorePattern &#x3D; ([^ ]*\.tmp) </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a3.sinks.k3.type &#x3D; hdfs </span><br><span class="line">a3.sinks.k3.hdfs.path </span><br><span class="line">hdfs:&#x2F;&#x2F;hadoop102:9000&#x2F;flume&#x2F;upload&#x2F;%Y%m%d&#x2F;%H #上传文件的前缀</span><br><span class="line">a3.sinks.k3.hdfs.filePrefix &#x3D; upload- </span><br><span class="line">#是否按照时间滚动文件夹</span><br><span class="line">a3.sinks.k3.hdfs.round &#x3D; true </span><br><span class="line">#多少时间单位创建一个新的文件夹</span><br><span class="line">a3.sinks.k3.hdfs.roundValue &#x3D; 1 </span><br><span class="line">#重新定义时间单位</span><br><span class="line">a3.sinks.k3.hdfs.roundUnit &#x3D; hour </span><br><span class="line">#是否使用本地时间戳</span><br><span class="line">a3.sinks.k3.hdfs.useLocalTimeStamp &#x3D; true </span><br><span class="line">#积攒多少个Event才flush到HDFS一次</span><br><span class="line">a3.sinks.k3.hdfs.batchSize &#x3D; 100 </span><br><span class="line"></span><br><span class="line">#设置文件类型，可支持压缩</span><br><span class="line">a3.sinks.k3.hdfs.fileType &#x3D; DataStream </span><br><span class="line">#多久生成一个新的文件</span><br><span class="line">a3.sinks.k3.hdfs.rollInterval &#x3D; 60 </span><br><span class="line">#设置每个文件的滚动大小大概是128M</span><br><span class="line">a3.sinks.k3.hdfs.rollSize &#x3D; 134217700 </span><br><span class="line">#文件的滚动与Event数量无关</span><br><span class="line">a3.sinks.k3.hdfs.rollCount &#x3D; 0 </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory a3.channels.c3.type &#x3D; memory </span><br><span class="line">a3.channels.c3.capacity &#x3D; 1000 </span><br><span class="line">a3.channels.c3.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel a3.sources.r3.channels &#x3D; c3 </span><br><span class="line">a3.sinks.k3.channel &#x3D; c3 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204152409837.png" alt="image-20210204152409837"></p><blockquote><p>文件后缀表示添加给完成的文件后缀.COMPLETED，因为要不断观察文件，作监控，上传一个文件后添加后缀，下次在看到该后缀则不上传</p></blockquote></li><li><p>启动监控文件夹命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a3 --conf-file job/flume-dir-hdfs.conf </span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：在使用Spooling Directory Source 时</p><ul><li><p>不要在监控目录中创建并持续修改文件（<strong>不可监控动态变化即追加文件</strong>）</p></li><li><p>上传完成的文件会以**.COMPLETED结尾**</p></li><li><p>被监控文件夹<strong>每500毫秒扫描一次文件变动</strong> </p></li></ul></blockquote></li><li><p>向upload文件夹中添加文件</p></li><li><p>查看HDFS上的数据</p></li><li><p>等待1s，再次查询upload文件夹</p></li></ol><h2 id="监控目录下多个追加文件"><a href="#监控目录下多个追加文件" class="headerlink" title="监控目录下多个追加文件"></a>监控目录下多个追加文件</h2><blockquote><p>Exec source 适用于监控一个实时追加的文件，但不能保证数据不丢失</p><p>Spooldir Source能够保证数据不丢失，且能够实现断点续传，但延迟较高，不能实时监控</p><p>而Taildir Source既能够实现断点续传，又可以保证数据不丢失，还能够进行实时监控。 </p></blockquote><blockquote><p>用Flume监听整个目录的实时追加文件，并上传至HDFS</p></blockquote><h3 id="步骤示意图-2"><a href="#步骤示意图-2" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204155954745.png" alt="image-20210204155954745"></p><ol><li><p>配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a3.sources &#x3D; r3 </span><br><span class="line">a3.sinks &#x3D; k3 </span><br><span class="line">a3.channels &#x3D; c3 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a3.sources.r3.type &#x3D; TAILDIR </span><br><span class="line">a3.sources.r3.positionFile &#x3D; &#x2F;opt&#x2F;module&#x2F;flume&#x2F;tail_dir.json a3.sources.r3.filegroups &#x3D; f1 </span><br><span class="line">a3.sources.r3.filegroups.f1 &#x3D; &#x2F;opt&#x2F;module&#x2F;flume&#x2F;files&#x2F;file.* </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a3.sinks.k3.type &#x3D; hdfs </span><br><span class="line">a3.sinks.k3.hdfs.path </span><br><span class="line">hdfs:&#x2F;&#x2F;hadoop102:9000&#x2F;flume&#x2F;upload&#x2F;%Y%m%d&#x2F;%H #上传文件的前缀</span><br><span class="line">a3.sinks.k3.hdfs.filePrefix &#x3D; upload- </span><br><span class="line">#是否按照时间滚动文件夹</span><br><span class="line">a3.sinks.k3.hdfs.round &#x3D; true </span><br><span class="line">#多少时间单位创建一个新的文件夹</span><br><span class="line">a3.sinks.k3.hdfs.roundValue &#x3D; 1 </span><br><span class="line">#重新定义时间单位</span><br><span class="line">a3.sinks.k3.hdfs.roundUnit &#x3D; hour </span><br><span class="line">#是否使用本地时间戳</span><br><span class="line">a3.sinks.k3.hdfs.useLocalTimeStamp &#x3D; true </span><br><span class="line">#积攒多少个Event才flush到HDFS一次</span><br><span class="line">a3.sinks.k3.hdfs.batchSize &#x3D; 100 </span><br><span class="line">#设置文件类型，可支持压缩</span><br><span class="line">a3.sinks.k3.hdfs.fileType &#x3D; DataStream </span><br><span class="line">#多久生成一个新的文件</span><br><span class="line">a3.sinks.k3.hdfs.rollInterval &#x3D; 60 </span><br><span class="line">#设置每个文件的滚动大小大概是128M</span><br><span class="line">a3.sinks.k3.hdfs.rollSize &#x3D; 134217700 </span><br><span class="line">#文件的滚动与Event数量无关</span><br><span class="line">a3.sinks.k3.hdfs.rollCount &#x3D; 0 </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory a3.channels.c3.type &#x3D; memory </span><br><span class="line">a3.channels.c3.capacity &#x3D; 1000 </span><br><span class="line">a3.channels.c3.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel a3.sources.r3.channels &#x3D; c3 </span><br><span class="line">a3.sinks.k3.channel &#x3D; c3 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204160221739.png" alt="image-20210204160221739"></p><blockquote><p>positionFile：json文件</p><p>Taildir说明：</p><p>Taildir Source 维护了一个json格式的position File，其会定期的往 position File中更新每个文件读取到的最新的位置，因此能够实现断点续传。Position File的格式如下： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;inode&quot;:2496272,&quot;pos&quot;:12,&quot;file&quot;:&quot;&#x2F;opt&#x2F;module&#x2F;flume&#x2F;files&#x2F;file1.t xt&quot;&#125; </span><br><span class="line">&#123;&quot;inode&quot;:2496275,&quot;pos&quot;:12,&quot;file&quot;:&quot;&#x2F;opt&#x2F;module&#x2F;flume&#x2F;files&#x2F;file2.t xt&quot;&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：Linux 中储存文件元数据的区域就叫做inode，每个inode 都有一个号码，操作系统用 inode 号码来识别不同的文件，Unix/Linux 系统内部不使用文件名，而使用 inode 号码来识别文件</p></blockquote></li><li><p>启动监控文件夹命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a3 --conf-file job/flume-taildir-hdfs.conf </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>向files文件夹中追加内容</p></li><li><p>向upload文件夹中添加文件 </p></li><li><p>查看HDFS上的数据</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flume部署&quot;&gt;&lt;a href=&quot;#Flume部署&quot; class=&quot;headerlink&quot; title=&quot;Flume部署&quot;&gt;&lt;/a&gt;Flume部署&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;flume启动只需要启动agent即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置co</summary>
      
    
    
    
    <category term="Flume" scheme="https://www.gtxhjh.cn/categories/Flume/"/>
    
    
    <category term="flume" scheme="https://www.gtxhjh.cn/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>命令行在任意目录下启动任意脚本方法</title>
    <link href="https://www.gtxhjh.cn/2021/02/03/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9C%A8%E4%BB%BB%E6%84%8F%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%90%AF%E5%8A%A8%E4%BB%BB%E6%84%8F%E8%84%9A%E6%9C%AC%E6%96%B9%E6%B3%95/"/>
    <id>https://www.gtxhjh.cn/2021/02/03/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9C%A8%E4%BB%BB%E6%84%8F%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%90%AF%E5%8A%A8%E4%BB%BB%E6%84%8F%E8%84%9A%E6%9C%AC%E6%96%B9%E6%B3%95/</id>
    <published>2021-02-03T08:11:35.000Z</published>
    <updated>2021-02-03T08:45:36.648Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天在执行.sh脚本文件时，发现必须在脚本所在的路径下才可执行，找到方法可以在任意目录下启动脚本，在此记录</p><p>[<a href="https://blog.csdn.net/qq_16633405/article/details/82056619]">https://blog.csdn.net/qq_16633405/article/details/82056619]</a>: </p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>简单说PATH就是一组路径的字符串变量，当你输入的命令不带任何路径时，LINUX会在PATH记录的路径中查找该命令。有的话则执行，<strong>不存在则提示命令找不到</strong>，也就是我们经常看到的<code>-bash: ***: command not found</code>。比如在根目录/下可以输入命令ls,在/usr目录下也可以输入ls,但其实ls命令根本不在这个两个目录下，当你输入ls命令时LINUX会去/bin,/usr/bin,/sbin等目录寻找该命令。而PATH就是定义/bin:/sbin:/usr/bin等这些路径的变量，其中冒号为目录间的分割符。使用<code>export $PATH</code>命令可以查看环境变量的内容。<br>那么如何自定义一个路径呢</p><hr><p>修改环境变量PATH， 给PATH增加一个值/usr/local/apache/bin </p><h2 id="Linux环境变量"><a href="#Linux环境变量" class="headerlink" title="Linux环境变量"></a>Linux环境变量</h2><p><strong>注意：</strong></p><ul><li>登录式Shell，采用用户名比如XXXX登录，会自动加载/etc/profile</li><li>非登录式Shell，采用ssh 比如ssh XXXX登录，不会自动加载/etc/profile，会自动加载~/.bashrc</li></ul><p>首先查看~/.bashrc</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> rm=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> cp=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> mv=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; <span class="keyword">then</span></span><br><span class="line">        . /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><blockquote><p>加载该文件，会加载/etc/bashrc文件，因此继续查看/etc/bashrc，下拉文件底部，可以看到下代码</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -r <span class="string">&quot;<span class="variable">$i</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$PS1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        . <span class="string">&quot;<span class="variable">$i</span>&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        . <span class="string">&quot;<span class="variable">$i</span>&quot;</span> &gt;/dev/null</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>该语句表示其会加载/etc/profile.d中所有.sh后缀的文件</p></blockquote><p>继续查看/etc/profile文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># By default, we want umask to get set. This sets it for login shell</span></span><br><span class="line"><span class="comment"># Current threshold for system reserved uid/gids is 200</span></span><br><span class="line"><span class="comment"># You could check uidgid reservation validity in</span></span><br><span class="line"><span class="comment"># /usr/share/doc/setup-*/uidgid file</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$UID</span> -gt 199 ] &amp;&amp; [ <span class="string">&quot;`/usr/bin/id -gn`&quot;</span> = <span class="string">&quot;`/usr/bin/id -un`&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">umask</span> 002</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">umask</span> 022</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh /etc/profile.d/sh.local ; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -r <span class="string">&quot;<span class="variable">$i</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;-#*i&#125;</span>&quot;</span> != <span class="string">&quot;$-&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            . <span class="string">&quot;<span class="variable">$i</span>&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            . <span class="string">&quot;<span class="variable">$i</span>&quot;</span> &gt;/dev/null</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> i</span><br><span class="line"><span class="built_in">unset</span> -f pathmunge</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>其也会加载到profile.d中.sh后缀文件</p></blockquote><p>那么综上，整理profile与profile.d的区别</p><ul><li> 两个文件都是设置环境变量文件的，/etc/profile是永久性的环境变量,是全局变量，/etc/profile.d/设置所有 用户生效</li><li>/etc/profile.d/比/etc/profile好维护，不想要什么变量直接删除/etc/profile.d/下对应的shell脚本即可，不用 像/etc/profile需要改动此文件 </li></ul><blockquote><p>[<a href="https://blog.csdn.net/qq_36522306/article/details/94616769]">https://blog.csdn.net/qq_36522306/article/details/94616769]</a>: </p></blockquote><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><blockquote><p>加入需要任意地方启动/XX/XX/XX中的.sh脚本</p></blockquote><h2 id="1、直接在命令行中设置PATH"><a href="#1、直接在命令行中设置PATH" class="headerlink" title="1、直接在命令行中设置PATH"></a>1、直接在命令行中设置PATH</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> PATH=<span class="variable">$PATH</span>:/XX/XX/XX</span></span><br></pre></td></tr></table></figure><blockquote><p> 使用这种方法,只对当前会话有效，也就是说每当登出或注销系统以后，PATH设置就会失效。 </p></blockquote><h2 id="2、在profile中设置PATH"><a href="#2、在profile中设置PATH" class="headerlink" title="2、在profile中设置PATH"></a>2、在profile中设置PATH</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p> 找到export行，在下面新增加一行，内容为： </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/XX/XX/XX</span><br></pre></td></tr></table></figure><p>最后命令行中输入：source profile命令使得PATH的修改立马生效</p><h2 id="3、在当前用户的profile中设置PATH"><a href="#3、在当前用户的profile中设置PATH" class="headerlink" title="3、在当前用户的profile中设置PATH"></a>3、在当前用户的profile中设置PATH</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p> 修改PATH行,把/XX/XX/XX添加进去,如 :</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PATH=$PATH:$HOME/bin:/XX/XX/XX。</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">source</span> ~/.bash_profile</span></span><br></pre></td></tr></table></figure><p> 让这次的修改生效。</p><blockquote><p>这种方法只对当前用户起作用的,其他用户该修改无效</p></blockquote><h2 id="4、在profile-d中设置PATH"><a href="#4、在profile-d中设置PATH" class="headerlink" title="4、在profile.d中设置PATH"></a>4、在profile.d中设置PATH</h2><p>对于/XX/XX/XX中某个XX.sh脚本（/XX/XX/XX/XX.sh）</p><p>在profile.d中创建一个新的文件，如env.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir env.sh</span><br></pre></td></tr></table></figure><p>在其中加入/XX/XX/XX路径</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/XX/XX/XX</span><br></pre></td></tr></table></figure><p>以后在/XX/XX/XX中的任意XX.sh脚本，均可在任意位置执行XX命令执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;今天在执行.sh脚本文件时，发现必须在脚本所在的路径下才可执行，找到方法可以在任意目录下启动脚本，在此记录&lt;/p&gt;
&lt;p&gt;[&lt;a href=&quot;https://blog.csdn.net/qq_16633405/article/details/820</summary>
      
    
    
    
    <category term="脚本" scheme="https://www.gtxhjh.cn/categories/%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="脚本" scheme="https://www.gtxhjh.cn/tags/%E8%84%9A%E6%9C%AC/"/>
    
    <category term="linux" scheme="https://www.gtxhjh.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>第1章-JVM和Java体系架构</title>
    <link href="https://www.gtxhjh.cn/2021/02/03/JVM-1/"/>
    <id>https://www.gtxhjh.cn/2021/02/03/JVM-1/</id>
    <published>2021-02-03T07:48:30.000Z</published>
    <updated>2021-02-10T14:15:10.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章：JVM和Java体系架构"><a href="#第1章：JVM和Java体系架构" class="headerlink" title="第1章：JVM和Java体系架构"></a>第1章：JVM和Java体系架构</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你是否也遇到过这些问题？</p><ol><li> 运行着的线上系统突然卡死，系统无法访问，甚至直接OOM！</li><li> 想解决线上JVM GC问题，但却无从下手。</li><li> 新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了。</li><li> 每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</li></ol><p><img src="/2021/02/03/JVM-1/image-20210201205747659.png" alt="image-20210201205747659"></p><p>大部分Java开发人员，除了会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。</p><h2 id="Java-VS-C"><a href="#Java-VS-C" class="headerlink" title="Java VS C++"></a>Java VS C++</h2><blockquote><p>懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</p><p>C++语言需要程序员自己来分配内存和回收内存，对于高手来说可能更加舒服，但是对于普通开发者，如果技术实力不够，很容易造成内存泄漏。而Java全部交给JVM进行内存分配和回收。</p></blockquote><h2 id="Java-跨平台的语言"><a href="#Java-跨平台的语言" class="headerlink" title="Java-跨平台的语言"></a>Java-跨平台的语言</h2><p><img src="/2021/02/03/JVM-1/image-20210201205817371.png" alt="image-20210201205817371"></p><h2 id="JVM-跨语言的平台"><a href="#JVM-跨语言的平台" class="headerlink" title="JVM-跨语言的平台"></a>JVM-跨语言的平台</h2><p><img src="/2021/02/03/JVM-1/image-20210201210003808.png" alt="image-20210201210003808"></p><ol><li> 随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。</li><li> Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它<strong>只关心“字节码”文件</strong>。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，<strong>只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行</strong>。</li></ol><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><ol><li> 平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：<strong>jvm字节码</strong>。</li><li> 不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</li><li> Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，<strong>Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息</strong>。</li></ol><h2 id="多语言混合编程"><a href="#多语言混合编程" class="headerlink" title="多语言混合编程"></a>多语言混合编程</h2><ol><li><p>Java平台上的多语言混合编程成为主流，<strong>通过特定领域的语言去解决特定领域的问题是当前软件开发</strong>应对日趋复杂的项目需求的一个方向。</p></li><li><p>试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，<em>每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上</em>。</p></li><li><p> 对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如DaVinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</p></li></ol><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="虚拟机概念"><a href="#虚拟机概念" class="headerlink" title="虚拟机概念"></a>虚拟机概念</h3><ul><li><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<strong>系统虚拟机和程序虚拟机</strong>。</p><ul><li>大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们完全是**对物理计算机硬件的仿真(模拟)**，提供了一个可运行完整操作系统的软件平台。</li></ul><ul><li><strong>==程序虚拟机的典型代表就是Java虚拟机==**，它</strong>专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令**。</li></ul></li><li><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p></li></ul><h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><ol><li> Java虚拟机是<strong>一台执行Java字节码的虚拟计算机</strong>，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</li><li> JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li><li> <strong>Java技术的核心就是Java虚拟机</strong>（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</li></ol><p><strong>作用：</strong></p><p>**==Java虚拟机就是二进制字节码的运行环境==**，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p><p><strong>特点：</strong></p><ol><li> 一次编译，到处运行</li><li> 自动内存管理</li><li> 自动垃圾回收功能</li></ol><h2 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h2><p><img src="/2021/02/03/JVM-1/image-20210201212334988.png" alt="image-20210201212334988"></p><p><img src="/2021/02/03/JVM-1/image-20210201212502305.png" alt="image-20210201212502305"></p><h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="==JVM的整体结构=="></a>==JVM的整体结构==</h2><ol><li> HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li><li> 采用解释器与即时编译器并存的架构。</li><li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</li></ol><p><img src="/2021/02/03/JVM-1/image-20210201212621647.png" alt="image-20210201212621647"></p><blockquote><ul><li><p>jvm解释运行字节码文件，入口原材料为class files</p></li><li><p>而字节码文件经过类装载器子系统加载到内存生成class对象（加载、链接、初始化）</p></li><li><p>生成到方法区，对应有class实例，根据程序，有堆、栈、PC等</p></li><li><p><strong>多线程共享方法区、堆。而其余每个线程一份</strong></p></li><li><p>执行引擎有：<strong>解释器（响应快，步行），即时编译器（寻找热点代码即时编译成本地机器指令，并进行缓存，坐公交车），垃圾回收器</strong></p><blockquote><p>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</p></blockquote><img src="/2021/02/03/JVM-1/image-20210201213023017.png" alt="image-20210201213023017" style="zoom: 80%;"><p>操作系统只能识别机器指令，而字节码指令不等同于机器指令，而执行引擎相当于一个翻译者</p></li></ul></blockquote><img src="/2021/02/03/JVM-1/image-20210210220712529.png" alt="image-20210210220712529" style="zoom:67%;"><h2 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h2><p><img src="/2021/02/03/JVM-1/image-20210201213219345.png" alt="image-20210201213219345"></p><h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另外一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。具体来说：这两种架构之间的区别：</p><h3 id="基于栈的指令集架构"><a href="#基于栈的指令集架构" class="headerlink" title="基于栈的指令集架构"></a>基于栈的指令集架构</h3><p>基于栈式架构的特点：</p><ol><li> 设计和实现更简单，适用于资源受限的系统；</li><li> 避开了寄存器的分配难题：使用零地址指令方式分配</li><li> 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现（栈只有入栈出栈操作，更容易实现）</li><li> 不需要硬件支持，可移植性更好，更好实现跨平台（内存层面，不需要和硬件接触，可移植性好）</li></ol><h3 id="基于寄存器的指令级架构"><a href="#基于寄存器的指令级架构" class="headerlink" title="基于寄存器的指令级架构"></a>基于寄存器的指令级架构</h3><p>基于寄存器架构的特点：</p><ol><li> 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li> 指令集架构则<strong>完全依赖硬件，与硬件的耦合度高，可移植性差</strong></li><li> 性能优秀和执行更高效</li><li> 花费更少的指令去完成一项操作</li><li> 在大部分情况下，<strong>基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</strong></li></ol><h3 id="两种架构的举例"><a href="#两种架构的举例" class="headerlink" title="两种架构的举例"></a>两种架构的举例</h3><p>同样执行2+3这种逻辑操作，其指令分别如下：</p><ul><li><p><strong>基于栈的计算流程（以Java虚拟机为例）：</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iconst_2 <span class="comment">//常量2入栈</span></span><br><span class="line">istore_1</span><br><span class="line">iconst_3 <span class="comment">// 常量3入栈</span></span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd <span class="comment">//常量2/3出栈，执行相加</span></span><br><span class="line">istore_0 <span class="comment">// 结果5入栈</span></span><br></pre></td></tr></table></figure><p>  8个指令</p></li><li><p><strong>而基于寄存器的计算流程</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mov eax,<span class="number">2</span> <span class="comment">//将eax寄存器的值设为1</span></span><br><span class="line">add eax,<span class="number">3</span> <span class="comment">//使eax寄存器的值加3</span></span><br></pre></td></tr></table></figure><p>  2个指令</p></li></ul><h3 id="JVM架构总结"><a href="#JVM架构总结" class="headerlink" title="JVM架构总结"></a>JVM架构总结</h3><p><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的</strong>。不同平台CPU架构不同，所以不能设计为基于寄存器的。栈的优点：跨平台，指令集小，编译器容易实现，缺点是性能比寄存器差一些。</p><blockquote><p>栈：跨平台性、指令集小、指令多；执行性能比寄存器差</p></blockquote><h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过<strong>引导类加载器（bootstrap class loader）</strong>创建一个<strong>初始类（initial class）</strong>来完成的，这个类是由虚拟机的具体实现指定的。</p><blockquote><p>如object类也需要引导类加载器加载，自定的类需要系统加载器加载</p></blockquote><h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li><li>程序开始执行时他才运行，程序结束时他就停止</li><li><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的==进程==</strong></li></ul><h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p><strong>有如下的几种情况：</strong></p><ul><li><p>程序正常执行结束</p></li><li><p>程序在执行过程中遇到了异常或错误而异常终止</p></li><li><p>由于操作系统用现错误而导致Java虚拟机进程终止</p></li><li><p>某线程调用Runtime类或System类的exit()方法，或Runtime类的halt()方法，并且Java安全管理器也允许这次exit()或halt()操作。</p></li><li><p>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</p></li></ul><h2 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ol><li> 早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是<strong>世界上第一款商用Java虚拟机</strong>，JDK1.4时完全被淘汰。</li><li> 这款虚拟机内部只提供解释器，没有即时编译器，因此效率比较低。【即时编译器会把热点代码的本地机器指令缓存起来，那么以后使用热点代码的时候，效率就比较高】</li><li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作，解释器和编译器不能配合工作。<ul><li>我们将字节码指令翻译成机器指令也是需要花时间的，如果只使用JIT，就需要把所有字节码指令都翻译成机器指令，就会导致翻译时间过长，也就是说在程序刚启动的时候，等待时间会很长。</li><li>而解释器就是走到哪，解释到哪。</li></ul></li><li> 现在Hotspot内置了此虚拟机。</li></ol><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ol><li><p>为了解决上一个虚拟机问题，jdk1.2时，Sun提供了此虚拟机。</p></li><li><p>Exact Memory Management：准确式内存管理</p><ul><li><p>也可以叫Non-Conservative/Accurate Memory Management</p></li><li><p>虚拟机可以知道内存中某个位置的数据具体是什么类型。</p></li></ul></li><li><p>具备现代高性能虚拟机的维形</p><ul><li><p>热点探测（寻找出热点代码进行缓存）</p></li><li><p>编译器与解释器混合工作模式</p></li></ul></li><li><p> 只在Solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</p></li></ol><h3 id="HotSpot-VM（重点）"><a href="#HotSpot-VM（重点）" class="headerlink" title="HotSpot VM（重点）"></a>HotSpot VM（重点）</h3><ol><li><p>HotSpot历史</p><ul><li><p>最初由一家名为“Longview Technologies”的小公司设计</p></li><li><p>1997年，此公司被Sun收购；2009年，Sun公司被甲骨文收购。</p></li><li><p>JDK1.3时，HotSpot VM成为默认虚拟机</p></li></ul></li><li><p>目前<strong>Hotspot占有绝对的市场地位，称霸武林</strong>。</p><ul><li><p>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</p></li><li><p>Sun/oracle JDK和openJDK的默认虚拟机</p></li><li><p>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。（比如其他两个商用虚机都没有方法区的概念）</p></li></ul></li><li><p>从服务器、桌面到移动端、嵌入式都有应用。</p></li><li><p>名称中的HotSpot指的就是它的热点代码探测技术。</p><ul><li><p>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</p></li><li><p>  通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</p></li></ul></li></ol><h3 id="JRockit（商用三大虚拟机之一）"><a href="#JRockit（商用三大虚拟机之一）" class="headerlink" title="JRockit（商用三大虚拟机之一）"></a>JRockit（商用三大虚拟机之一）</h3><ol><li><p>专注于服务器端应用：它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</p></li><li><p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM：使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</p></li><li><p>优势：全面的Java运行时解决方案组合</p><ul><li><p>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</p></li><li><p>Mission Control服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</p></li></ul></li><li><p>2008年，JRockit被Oracle收购。</p></li><li><p>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p></li><li><p> 高斯林：目前就职于谷歌，研究人工智能和水下机器人</p></li></ol><h3 id="IBM的J9（商用三大虚拟机之一）"><a href="#IBM的J9（商用三大虚拟机之一）" class="headerlink" title="IBM的J9（商用三大虚拟机之一）"></a>IBM的J9（商用三大虚拟机之一）</h3><ol><li><p>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</p></li><li><p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</p></li><li><p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</p></li><li><p>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给Eclipse基金会管理，也称为Eclipse OpenJ9</p></li><li><p> OpenJDK -&gt; 是JDK开源了，包括了虚拟机</p></li></ol><h3 id="KVM和CDC-CLDC-Hotspot"><a href="#KVM和CDC-CLDC-Hotspot" class="headerlink" title="KVM和CDC/CLDC Hotspot"></a>KVM和CDC/CLDC Hotspot</h3><ol><li><p> Oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM </p></li><li><p> KVM（Kilobyte）是CLDC-HI早期产品</p></li><li><p> 目前移动领域地位尴尬，智能机被Android和iOS二分天下。</p></li><li><p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p><ul><li><p>智能控制器、传感器</p></li><li><p>  老人手机、经济欠发达地区的功能手机</p></li></ul></li><li><p> 所有的虚拟机的原则：一次编译，到处运行。</p></li></ol><h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><ol><li> 前面三大“高性能Java虚拟机”使用在<strong>通用硬件平台上</strong></li><li> 这里Azul VW和BEA Liquid VM是与<strong>特定硬件平台绑定</strong>、软硬件配合的专有虚拟机：高性能Java虚拟机中的战斗机。</li><li> Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的Java虚拟机。</li><li> 每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</li><li> 2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</li></ol><h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><ol><li> 高性能Java虚拟机中的战斗机。</li><li> BEA公司开发的，直接运行在自家Hypervisor系统上</li><li> Liquid VM即是现在的JRockit VE（Virtual Edition）。<strong>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等</strong>。</li><li> 随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</li></ol><h3 id="Apache-Marmony"><a href="#Apache-Marmony" class="headerlink" title="Apache Marmony"></a>Apache Marmony</h3><ol><li><p>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</p></li><li><p>它是IElf和Intel联合开发的开源JVM，受到同样开源的Open JDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</p></li><li><p> 虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p></li></ol><h3 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h3><ol><li><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p></li><li><p>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</p></li><li><p> 1997年，Sun以侵犯商标、不正当竞争罪名指控微软成功，赔了Sun很多钱。微软WindowsXP SP3中抹掉了其VM。现在Windows上安装的jdk都是HotSpot。</p></li></ol><h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><ol><li><p>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p></li><li><p><strong>基于OpenJDK开发了自己的定制版本AlibabaJDK</strong>，简称AJDK。是整个阿里Java体系的基石。</p></li><li><p>基于OpenJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</p><ul><li>  创新的GCIH（GCinvisible heap）技术实现了off-heap，<strong>即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的</strong>。</li><li>  GCIH中的<strong>对象还能够在多个Java虚拟机进程中实现共享</strong></li><li>  使用crc32指令实现JvM intrinsic降低JNI的调用开销</li><li>  PMU hardware的Java profiling tool和诊断协助功能</li><li>  针对大数据场景的ZenGC</li></ul></li><li><p> taobao vm应用在阿里产品上性能高，<strong>硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能</strong></p></li></ol><ul><li>目前已经在淘宝、天猫上线，把Oracle官方JvM版本全部替换了。</li></ul><h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><ol><li><p>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</p></li><li><p><strong>Dalvik VM只能称作虚拟机，而不能称作“Java虚拟机”</strong>，它没有遵循 Java虚拟机规范</p></li><li><p>不能直接执行Java的Class文件</p></li><li><p>基于寄存器架构，不是jvm的栈架构。</p></li><li><p> 执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p></li></ol><ul><li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li></ul><ol start="7"><li> Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</li></ol><h3 id="Graal-VM（未来虚拟机）"><a href="#Graal-VM（未来虚拟机）" class="headerlink" title="Graal VM（未来虚拟机）"></a>Graal VM（未来虚拟机）</h3><ol><li><p>2018年4月，Oracle Labs公开了GraalvM，号称 “<strong>Run Programs Faster Anywhere</strong>”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</p></li><li><p>GraalVM在HotSpot VM基础上增强而成的<strong>跨语言全栈虚拟机，可以作为“任何语言”</strong>的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</p></li><li><p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p></li><li><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p></li><li><p> <strong>如果说HotSpot有一天真的被取代，Graalvm希望最大</strong>。但是Java的软件生态没有丝毫变化。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以Oracle HotSpot VM为默认虚拟机。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第1章：JVM和Java体系架构&quot;&gt;&lt;a href=&quot;#第1章：JVM和Java体系架构&quot; class=&quot;headerlink&quot; title=&quot;第1章：JVM和Java体系架构&quot;&gt;&lt;/a&gt;第1章：JVM和Java体系架构&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="https://www.gtxhjh.cn/2021/01/28/Vue/vue/"/>
    <id>https://www.gtxhjh.cn/2021/01/28/Vue/vue/</id>
    <published>2021-01-28T05:46:30.000Z</published>
    <updated>2021-02-03T08:03:12.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="vue实例"><a href="#vue实例" class="headerlink" title="vue实例"></a>vue实例</h2><p> 每个 Vue 应用都是通过用 <code>Vue</code> 函数创建一个新的 <strong>Vue 实例</strong>开始的： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  &#x2F;&#x2F; 选项</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; vm为vue.js对象</span><br><span class="line">&#x2F;&#x2F; el:element 元素属性</span><br><span class="line">&#x2F;&#x2F; data:数据变量</span><br></pre></td></tr></table></figure><h3 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h3><p> 当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的 property 加入到 Vue 的<strong>响应式系统</strong>中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;vue.js&quot; type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &#123;&#123; a &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">        var data &#x3D; &#123; a : 1&#125;;</span><br><span class="line">        var vm &#x3D; new Vue(&#123;</span><br><span class="line">            el: &quot;#app&quot;,</span><br><span class="line">            data: data &#x2F;&#x2F;此data非彼data</span><br><span class="line">        &#125;);</span><br><span class="line">        data.a &#x3D; &quot;hi .... new ...&quot;  &#x2F;&#x2F; 通过data改变值</span><br><span class="line">        vm.a &#x3D; &quot;test&quot;;  &#x2F;&#x2F; 与上等价</span><br><span class="line">        &#x2F;&#x2F; 获得这个实例上的 property</span><br><span class="line">        &#x2F;&#x2F; 返回源数据中对应的字段</span><br><span class="line">        vm.a &#x3D;&#x3D; data.a &#x2F;&#x2F; &#x3D;&gt; true</span><br><span class="line">        &#x2F;&#x2F; 此处另加值比如b不行，需要提前在new vue中声明（当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的）</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  newTodoText: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  visitCount: <span class="number">0</span>,</span><br><span class="line">  hideCompletedTodos: <span class="literal">false</span>,</span><br><span class="line">  todos: [],</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//针对上面未申明问题，可以提前设置初始值</span></span><br></pre></td></tr></table></figure><p>唯一的例外是使用 <code>Object.freeze()</code>，这会阻止修改现有的 property，也意味着响应系统无法再<em>追踪</em>变化。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-1&quot;&gt;</span><br><span class="line">    &lt;p&gt; &#123;&#123; b &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;b &#x3D; &#39;change&#39;&quot;&gt;Change it&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var data &#x3D; &#123; b : &#39;bar&#39;&#125;;</span><br><span class="line">    Object.freeze(data)  &#x2F;&#x2F; 此处注意需要放在放入new vue实例之前</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-1&quot;,</span><br><span class="line">        data: data</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 <code>$</code>，以便与用户定义的 property 区分开来 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">    &#123;&#123; a &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var data &#x3D; &#123; a : 1&#125;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#example&quot;,</span><br><span class="line">        data: data</span><br><span class="line">    &#125;)</span><br><span class="line">    vm.$data &#x3D;&#x3D;&#x3D; data &#x2F;&#x2F; -&gt; TRUE</span><br><span class="line">    vm.$el &#x3D;&#x3D;&#x3D; document.getElementById(&#39;example&#39;) &#x2F;&#x2F; -&gt; TRUE</span><br><span class="line"></span><br><span class="line">    vm.$watch(&#39;a&#39;, function(newVal, oldVal)&#123;</span><br><span class="line">        &#x2F;&#x2F; 这个回调在vm.a改变后调用</span><br><span class="line">        console.log(newVal, oldVal)</span><br><span class="line">    &#125;)</span><br><span class="line">    vm.$data.a &#x3D; 2</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>watch观察变化，返回观察前后结果</p><p>首先指定观察的变量，然后执行回调函数，含newval、oldval。会记录变量的变化，返回最新一次</p></blockquote><p>实验中改变a的值效果如下：</p><p><img src="/2021/01/28/Vue/vue/image-20201111144705922.png" alt="image-20201111144705922"></p><h3 id="实例生命周期钩子"><a href="#实例生命周期钩子" class="headerlink" title="实例生命周期钩子"></a>实例生命周期钩子</h3><p> 每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会 </p><p><strong>写在new vue对象内，以属性的方式进行声明</strong></p><blockquote><p>api:</p><p><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90</a></p></blockquote><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p> 生命周期钩子的 <code>this</code> 上下文指向调用它的 Vue 实例 </p><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><p> 比如 <a href="https://cn.vuejs.org/v2/api/#created"><code>created</code></a> 钩子可以用来在一个实例被<strong>创建之后</strong>执行代码： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        data: &#123;</span><br><span class="line">            a: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        created: function () &#123;</span><br><span class="line">            &#x2F;&#x2F; &#96;this&#96; 指向 vm 实例</span><br><span class="line">            console.log(&#39;a is: &#39; + this.a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; &#x3D;&gt; &quot;a is: 1&quot; </span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p> 不要在选项 property 或回调上使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>，比如</p><p> <code>created: () =&gt; console.log(this.a)</code> 或</p><p> <code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code>。</p><p>因为箭头函数并没有 <code>this</code>，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code> 或 <code>Uncaught TypeError: this.myMethod is not a function</code> 之类的错误。 </p><p> 所有的生命周期钩子自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算。这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)。这是因为箭头函数绑定了父上下文，因此 <code>this</code> 与你期待的 Vue 实例不同，<code>this.fetchTodos</code> 的行为未定义 </p></blockquote><h4 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h4><p> <img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue 实例生命周期"> </p><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p> 数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值。Mustache 标签将会被替代为对应数据对象上 <code>msg</code> property 的值。无论何时，绑定的数据对象上 <code>msg</code> property 发生了改变，插值处的内容都会更新。</p><p>通过使用 <strong>v-once 指令</strong>，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span id&#x3D;&quot;app&quot; v-once&gt;Message: &#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var data &#x3D; &#123; msg : 1&#125;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data: data</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="原始HTML"><a href="#原始HTML" class="headerlink" title="原始HTML"></a>原始HTML</h4><p> 双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，需要使用 <code>v-html</code> 指令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id&#x3D;&quot;app-2&quot;&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125; &lt;&#x2F;p&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-2&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            rawHtml: &#39;&lt;span style&#x3D;&quot;color : red&quot;&gt;hello world&lt;&#x2F;span&gt;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>result：</p><p><img src="/2021/01/28/Vue/vue/image-20201112123917581.png" alt="image-20201112123917581"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id&#x3D;&quot;app-2&quot; v-html&#x3D;&quot;rawHtml&quot;&gt;Using v-html mustaches: &#123;&#123; rawHtml &#125;&#125; &lt;&#x2F;p&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-2&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            rawHtml: &#39;&lt;span style&#x3D;&quot;color : red&quot;&gt;hello world&lt;&#x2F;span&gt;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>result：</p><p><img src="/2021/01/28/Vue/vue/image-20201112123944530.png" alt="image-20201112123944530"></p><blockquote><p><code>span</code> 的内容将会被替换成为 property 值 <code>rawHtml</code>，直接作为 HTML——会忽略解析 property 值中的数据绑定。注意，你不能使用 <code>v-html</code> 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位 </p></blockquote><h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-3&quot;&gt;</span><br><span class="line">    &lt;div v-bind:class&#x3D;&quot;color&quot;&gt;test..bind&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- v-bind:属性&#x3D;&quot;..&quot; --&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-3&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            color: &#39;red&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">    .red&#123;color: red; font-size: 100px;&#125;</span><br><span class="line">    &#x2F;* font-size设置大小 *&#x2F;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>result：</p><img src="/2021/01/28/Vue/vue/image-20201112125658940.png" alt="image-20201112125658940" style="zoom: 50%;"><p> Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 <code>v-bind</code> 指令</p><p> 对于布尔 attribute (它们只要存在就意味着值为 <code>true</code>)，<code>v-bind</code> 工作起来略有不同</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button v-bind:disabled&#x3D;&quot;isButtonDisabled&quot;&gt;Button&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><p>如果 <code>isButtonDisabled</code> 的值是 <code>null</code>、<code>undefined</code> 或 <code>false</code>，则 <code>disabled</code> attribute 甚至不会被包含在渲染出来的 `` 元素中 </p><h4 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式"></a>JavaScript表达式</h4><p>对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持，使得不仅限于使用 简单的 property 键值 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;javascript_study&quot;&gt;</span><br><span class="line">    &lt;div&gt; &#123;&#123;number + 1&#125;&#125; &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div&gt; &#123;&#123; ok ? &#39;YES&#39; : &#39;NO&#39;&#125;&#125; &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div&gt; &#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125; &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#javascript_study&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            number: 2,</span><br><span class="line">            ok: 0,</span><br><span class="line">            message: &quot;vue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>result：<img src="/2021/01/28/Vue/vue/image-20201112130939266.png" alt="image-20201112130939266" style="zoom:50%;"></p><p>这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含<strong>单个表达式</strong>，否则<strong>不会</strong>生效 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是语句，不是表达式 --&gt;</span></span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>模板表达式都被放在沙盒中，只能访问<a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9">全局变量的一个白名单</a>，如 <code>Math</code> 和 <code>Date</code> 。你不应该在模板表达式中试图访问用户定义的全局变量 </p></blockquote><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p> 指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute。指令 attribute 的值预期是<strong>单个 JavaScript 表达式</strong> (<code>v-for</code> 是例外情况)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM </p><p>如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>现在你看到我了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>一些指令能接收一个参数，在指令名称之前:表示，如v-bind用于响应式更新html属性</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>href为参数，v-bind指令将该元素href属性与表达式url绑定</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app-1&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- v-on监听DOM事件，参数为监听事件名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app-1&quot;</span>,</span></span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>v-on监听事件</p><p>对于事件单击：click</p><p>对于鼠标事件：monseenter</p><p>对于双击事件：dbclick</p><p>触发事件执行方法，方法定义于methods中</p><p><strong>v-on:click简写为:@click，其他亦然</strong></p></blockquote><h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><p>可用方括号括起来的 JavaScript 表达式作为一个指令的参数</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <code>attributeName</code> 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用，如果Vue 实例有一个 <code>data</code> property <code>attributeName</code>，其值为 <code>&quot;href&quot;</code>，那么这个绑定将等价于 <code>v-bind:href</code> </p><p> 可以<strong>使用动态参数为一个动态的事件名绑定处理函数</strong> </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:</span>[<span class="attr">eventName</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 当 <code>eventName</code> 的值为 <code>&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code> </p><h5 id="对动态参数的值的约束"><a href="#对动态参数的值的约束" class="headerlink" title="对动态参数的值的约束"></a>对动态参数的值的约束</h5><p> 动态参数预期会求出一个字符串，异常情况下值为 <code>null</code>。这个特殊的 <code>null</code> 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告 </p><h5 id="对动态参数表达式的约束"><a href="#对动态参数表达式的约束" class="headerlink" title="对动态参数表达式的约束"></a>对动态参数表达式的约束</h5><ul><li>动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的 </li><li>在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写 </li></ul><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p> 修饰符 (modifier) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，<code>.prevent</code> 修饰符告诉 <code>v-on</code> 指令对于触发的事件调用 <code>event.preventDefault()</code> </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p> <code>v-</code> 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，<code>v-</code> 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。因此，Vue 为 <code>v-bind</code> 和 <code>v-on</code> 这两个最常用的指令，提供了特定简写 </p><h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> <code>:</code> 与 <code>@</code> 对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的 </p></blockquote><h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><blockquote><p>对于一些复杂逻辑，考虑使用计算属性</p></blockquote><p>如下式子过于复杂</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">  &#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>使用计算属性后：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-1&quot;&gt;</span><br><span class="line">    &lt;p&gt;Orignal message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage&#125;&#125;&quot;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-1&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;Hello&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            &#x2F;&#x2F; 计算属性的 getter</span><br><span class="line">            reversedMessage: function () &#123;</span><br><span class="line">                &#x2F;&#x2F; this 指向vm实例</span><br><span class="line">                return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>此处声明了计算属性 <strong>reversedMessage</strong>。提供的函数将作为 property <strong>vm.reversedMessage</strong> 的 <strong>getter</strong> 函数</p></blockquote><p>result：</p><p><img src="/2021/01/28/Vue/vue/image-20201114184714141.png" alt="image-20201114184714141"></p><p><img src="/2021/01/28/Vue/vue/image-20201114184707924.png" alt="image-20201114184707924"></p><blockquote><p> <code>vm.reversedMessage</code> 的值始终取决于 <code>vm.message</code> 的值</p></blockquote><h3 id="计算属性缓存和方法"><a href="#计算属性缓存和方法" class="headerlink" title="计算属性缓存和方法"></a>计算属性缓存和方法</h3><p>有时可以通过在表达式中调用方法来达到上面效果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-1&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;Hello&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            reversedMessage: function() &#123;</span><br><span class="line">                return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p> <strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数 </p></blockquote><p>注意： 如果没有缓存，我们将不可避免的多次执行 <strong>A</strong> 的 getter </p><h3 id="计算属性和侦听属性"><a href="#计算属性和侦听属性" class="headerlink" title="计算属性和侦听属性"></a>计算属性和侦听属性</h3><blockquote><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：<strong>侦听属性</strong>。当有一些数据需要随着其它数据变动而变动时，很容易滥用 <code>watch</code>。然而，通常更好的做法是使用计算属性而不是命令式的 <code>watch</code> 回调 </p></blockquote><p>watch回调使用如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; fullName &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-1&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            firstName: &quot;Foo&quot;,</span><br><span class="line">            lastName: &quot;Bar&quot;,</span><br><span class="line">            fullName: &quot;Foo Bar&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch: &#123;</span><br><span class="line">            &#x2F;&#x2F; 监听firstName值</span><br><span class="line">            firstName: function (val) &#123;</span><br><span class="line">                this.fullName &#x3D; val + &#39; &#39; + this.lastName</span><br><span class="line">            &#125;,</span><br><span class="line">            lastName: function (val) &#123;</span><br><span class="line">                this.fullName &#x3D; this.firstName + &#39; &#39; + val</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>result：</p><p><img src="/2021/01/28/Vue/vue/image-20201114201209891.png" alt="image-20201114201209891"></p><p>当将firstname改为TEST结果如下：</p><p><img src="/2021/01/28/Vue/vue/image-20201114201240937.png" alt="image-20201114201240937"></p><p><img src="/2021/01/28/Vue/vue/image-20201114201246853.png" alt="image-20201114201246853"></p><blockquote><p> 上面代码是命令式且重复的，使用计算属性更加简单</p></blockquote><h3 id="计算属性的setter"><a href="#计算属性的setter" class="headerlink" title="计算属性的setter"></a>计算属性的setter</h3><blockquote><p> 计算属性默认只有 getter，不过在需要时也可以提供一个 setter </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-2&quot;&gt;</span><br><span class="line">    &lt;p&gt; &#123;&#123; fullName &#125;&#125; &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-2&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            firstName: &quot;Foo&quot;,</span><br><span class="line">            lastName: &quot;voo&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            fullName: &#123;</span><br><span class="line">                &#x2F;&#x2F; getter</span><br><span class="line">                get: function () &#123;</span><br><span class="line">                    return this.firstName + &#39; &#39; + this.lastName</span><br><span class="line">                &#125;,</span><br><span class="line">                &#x2F;&#x2F; setter</span><br><span class="line">                set: function (newValue) &#123;</span><br><span class="line">                    var names &#x3D; newValue.split(&#39; &#39;)</span><br><span class="line">                    this.firstName &#x3D; names[0]</span><br><span class="line">                    this.lastName &#x3D; names[names.length - 1]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>result:</p><p><img src="/2021/01/28/Vue/vue/image-20201114203253806.png" alt="image-20201114203253806"></p><p>运行vm.fullName=‘John Doe’ 调用setter，同时firstname和lastname也改变</p><p><img src="/2021/01/28/Vue/vue/image-20201114203244153.png" alt="image-20201114203244153"></p><p><img src="/2021/01/28/Vue/vue/image-20201114203248673.png" alt="image-20201114203248673"></p><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><blockquote><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-3&quot;&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        Ask a yes&#x2F;no question:</span><br><span class="line">        &lt;input v-model&#x3D;&quot;question&quot;&gt;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span><br><span class="line">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;axios@0.12.0&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;lodash@4.13.1&#x2F;lodash.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var watchExampleVM &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-3&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            question: &#39;&#39;,</span><br><span class="line">            answer: &#39;I cannot give you an answer until you ask a question!&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch: &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果 &#96;question&#96; 发生改变，这个函数就会运行</span><br><span class="line">            question: function (newQuestion, oldQuestion) &#123;</span><br><span class="line">                this.answer &#x3D; &#39;Waiting for you to stop typing...&#39;</span><br><span class="line">                this.debouncedGetAnswer()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        created: function () &#123;</span><br><span class="line">            &#x2F;&#x2F; &#96;_.debounce&#96; 是一个通过 Lodash 限制操作频率的函数。</span><br><span class="line">            &#x2F;&#x2F; 在这个例子中，我们希望限制访问 yesno.wtf&#x2F;api 的频率</span><br><span class="line">            &#x2F;&#x2F; AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span><br><span class="line">            &#x2F;&#x2F; &#96;_.debounce&#96; 函数 (及其近亲 &#96;_.throttle&#96;) 的知识，</span><br><span class="line">            &#x2F;&#x2F; 请参考：https:&#x2F;&#x2F;lodash.com&#x2F;docs#debounce</span><br><span class="line">            this.debouncedGetAnswer &#x3D; _.debounce(this.getAnswer, 500)</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            getAnswer: function () &#123;</span><br><span class="line">                if (this.question.indexOf(&#39;?&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">                    this.answer &#x3D; &#39;Questions usually contain a question mark. ;-)&#39;</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">                this.answer &#x3D; &#39;Thinking...&#39;</span><br><span class="line">                var vm &#x3D; this</span><br><span class="line">                axios.get(&#39;https:&#x2F;&#x2F;yesno.wtf&#x2F;api&#39;)</span><br><span class="line">                    .then(function (response) &#123;</span><br><span class="line">                    vm.answer &#x3D; _.capitalize(response.data.answer)</span><br><span class="line">                &#125;)</span><br><span class="line">                    .catch(function (error) &#123;</span><br><span class="line">                    vm.answer &#x3D; &#39;Error! Could not reach the API. &#39; + error</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在这个示例中，使用 <code>watch</code> 选项允许执行异步操作 (访问一个 API)，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的 </p></blockquote><h2 id="Class与Style绑定"><a href="#Class与Style绑定" class="headerlink" title="Class与Style绑定"></a>Class与Style绑定</h2><blockquote><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 <code>v-bind</code> 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组 </p></blockquote><h3 id="绑定HTML-Class"><a href="#绑定HTML-Class" class="headerlink" title="绑定HTML Class"></a>绑定HTML Class</h3><h4 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h4><ol><li><blockquote><ul><li><p>可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class </p></li><li><p><code>active</code> 这个 class 存在与否将取决于数据 property <code>isActive</code> 的 truthiness</p></li><li><p>可以在对象中传入更多字段来动态切换多个 class。此外，<code>v-bind:class</code> 指令也可以与普通的 class attribute 共存 </p></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-1&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;static&quot; v-bind:class&#x3D;&quot;&#123; active: isActive, &#39;text-danger&#39;: hasError &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-1&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            isActive: true,</span><br><span class="line">            hasError: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>result:</p><p><img src="/2021/01/28/Vue/vue/image-20201115132149429.png" alt="image-20201115132149429"></p></li><li><p>此外，绑定的数据对象不必内联定义在模板里：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-2&quot;&gt;</span><br><span class="line">    &lt;div v-bind:class&#x3D;&quot;classObject&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-2&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            classObject: &#123;</span><br><span class="line">                active: true,</span><br><span class="line">                &#39;text-danger&#39;: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>也可以在这里绑定一个返回对象的<strong>计算属性</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-3&quot;&gt;</span><br><span class="line">    &lt;div v-bind:class&#x3D;&quot;classObject&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-3&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            isActive: true,</span><br><span class="line">            error: null</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            classObject: function () &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    active: this.isActive &amp;&amp; !this.error,</span><br><span class="line">                    &#39;text-danger&#39;: this.error &amp;&amp; this.error.type &#x3D;&#x3D;&#x3D; &#39;fatal&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li></ol><h4 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h4><ul><li>可以把一个数组传给 <code>v-bind:class</code>，以应用一个 class 列表 </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-4&quot;&gt;</span><br><span class="line">    &lt;div v-bind:class&#x3D;&quot;[activeClass, errorClass]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-4&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            activeClass: &#39;active&#39;,</span><br><span class="line">            errorClass: &#39;text-danger&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>根据条件切换列表中的 class，可以用三元表达式 </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-4&quot;&gt;</span><br><span class="line">    &lt;div v-bind:class&#x3D;&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-4&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            activeClass: &#39;active&#39;,</span><br><span class="line">            errorClass: &#39;text-danger&#39;,</span><br><span class="line">            isActive: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法 </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:class&#x3D;&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h4 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上###################"></a>用在组件上###################</h4><p><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%94%A8%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A">https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%94%A8%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A</a></p><h3 id="绑定内联样式style"><a href="#绑定内联样式style" class="headerlink" title="绑定内联样式style"></a>绑定内联样式style</h3><h4 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h4><blockquote><p><code>v-bind:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-5&quot;&gt;</span><br><span class="line">    &lt;div v-bind:style&#x3D;&quot;&#123; color: activeColor, fontSize: fontSize + &#39;px&#39;&#125;&quot;&gt;123&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-5&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            activeColor: &#39;red&#39;,</span><br><span class="line">            fontSize: 30</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>直接绑定到一个样式对象通常更好，这会让模板更清晰 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-5&quot;&gt;</span><br><span class="line">    &lt;div v-bind:style&#x3D;&quot;styleObject&quot;&gt;123&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-5&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            activeColor: &#39;red&#39;,</span><br><span class="line">            fontSize: 30,</span><br><span class="line">            styleObject: &#123;</span><br><span class="line">                color: &#39;red&#39;,</span><br><span class="line">                fontSize: &#39;13px&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h4><blockquote><p><code>v-bind:style</code> 的数组语法可以将多个样式对象应用到同一个元素上 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:style&#x3D;&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h4 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀#################"></a>自动添加前缀#################</h4><blockquote><p>当 <code>v-bind:style</code> 使用需要添加<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix">浏览器引擎前缀</a>的 CSS property 时，如 <code>transform</code>，Vue.js 会自动侦测并添加相应的前缀 </p></blockquote><h4 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a>多重值</h4><blockquote><p>可以为 <code>style</code> 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值 </p></blockquote><p>如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这样写只会渲染数组中**<em>最后一个</em>被浏览器支持的值**。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 <code>display: flex</code> </p></blockquote><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><blockquote><p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-1&quot;&gt;</span><br><span class="line">    &lt;h1 v-if&#x3D;&quot;awesome&quot;&gt;AWESOME&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h1 v-else&gt; Oh no &lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-1&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            awesome: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>v-else</code> 元素必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素的后面，否则它将不会被识别 </p><p> 类似于 <code>v-else</code>，<code>v-else-if</code> 也必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素之后 </p></blockquote><h3 id="在template元素上使用-v-if-条件渲染分组"><a href="#在template元素上使用-v-if-条件渲染分组" class="headerlink" title="在template元素上使用 v-if 条件渲染分组"></a>在template元素上使用 v-if 条件渲染分组</h3><blockquote><p>因为 <code>v-if</code> 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个template元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 template 元素 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template v-if&#x3D;&quot;ok&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Title&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 1&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 2&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h3 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 <code>key</code> 管理可复用的元素</h3><blockquote><p>Vue 会尽可能高效地渲染元素，通常会<strong>复用已有元素而不是从头开始渲染</strong>。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果允许用户在不同的登录方式之间切换 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-2&quot;&gt;</span><br><span class="line">    &lt;template v-if&#x3D;&quot;loginType &#x3D;&#x3D;&#x3D; &#39;username&#39;&quot;&gt;</span><br><span class="line">&lt;label&gt;Username&lt;&#x2F;label&gt;</span><br><span class="line">&lt;input placeholder&#x3D;&quot;Enter your username&quot;&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;template v-else&gt;</span><br><span class="line">&lt;label&gt;Email&lt;&#x2F;label&gt;</span><br><span class="line">&lt;input placeholder&#x3D;&quot;Enter your email address&quot;&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;change&quot;&gt;&#123;&#123; content &#125;&#125;&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-2&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            loginType: &quot;username&quot;,</span><br><span class="line">            content: &quot;use email&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            change: function () &#123;</span><br><span class="line">                if (this.loginType &#x3D;&#x3D; &quot;username&quot;)&#123;</span><br><span class="line">                    this.loginType &#x3D; &quot;email&quot;</span><br><span class="line">                    this.content &#x3D; &quot;use username&quot;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    this.loginType &#x3D; &quot;username&quot;</span><br><span class="line">                    this.content &#x3D; &quot;use email&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的代码中切换 <code>loginType</code> 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code> 不会被替换掉——仅仅是替换了它的 <code>placeholder</code> </p><p>当然，如果不需要复用，  Vue 为提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 <code>key</code> attribute 即可 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-2&quot;&gt;</span><br><span class="line">    &lt;template v-if&#x3D;&quot;loginType &#x3D;&#x3D;&#x3D; &#39;username&#39;&quot;&gt;</span><br><span class="line">&lt;label&gt;Username&lt;&#x2F;label&gt;</span><br><span class="line">&lt;input placeholder&#x3D;&quot;Enter your username&quot; key&#x3D;&quot;username-input&quot;&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;template v-else&gt;</span><br><span class="line">&lt;label&gt;Email&lt;&#x2F;label&gt;</span><br><span class="line">&lt;input placeholder&#x3D;&quot;Enter your email address&quot; key&#x3D;&quot;email-input&quot;&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;change&quot;&gt;&#123;&#123; content &#125;&#125;&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app-2&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            loginType: &quot;username&quot;,</span><br><span class="line">            content: &quot;use email&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            change: function () &#123;</span><br><span class="line">                if (this.loginType &#x3D;&#x3D; &quot;username&quot;)&#123;</span><br><span class="line">                    this.loginType &#x3D; &quot;email&quot;</span><br><span class="line">                    this.content &#x3D; &quot;use username&quot;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    this.loginType &#x3D; &quot;username&quot;</span><br><span class="line">                    this.content &#x3D; &quot;use email&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>&lt;label&gt;</code> 元素仍然会被高效地复用，因为它们没有添加 <code>key</code> attribute </p></blockquote><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>根据表达值真假，切换元素的显示和隐藏</p><blockquote><p>带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code> 只是简单地切换元素的 CSS property <code>display</code> </p><p> <code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>&lt;v-else&gt;</code> </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-show&#x3D;&quot;ok&quot;&gt;Hello!&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><p>result:</p><p><img src="/2021/01/28/Vue/vue/image-20201116153233242.png" alt="image-20201116153233242"></p><blockquote><p>也可以是” “中写表达式，如age&lt;10</p></blockquote><h3 id="v-if-amp-v-show"><a href="#v-if-amp-v-show" class="headerlink" title="v-if &amp; v-show"></a>v-if &amp; v-show</h3><blockquote><p>操纵dom元素</p></blockquote><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，**<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销**。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好</p><h3 id="v-if与v-for"><a href="#v-if与v-for" class="headerlink" title="v-if与v-for"></a>v-if与v-for</h3><p> 当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级 , <strong>不推荐</strong>同时使用 <code>v-if</code> 和 <code>v-for</code> </p><p><a href="https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BF%85%E8%A6%81">https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BF%85%E8%A6%81</a></p><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="用-v-for-把一个数组对应为一组元素"><a href="#用-v-for-把一个数组对应为一组元素" class="headerlink" title="用 v-for 把一个数组对应为一组元素"></a>用 <code>v-for</code> 把一个数组对应为一组元素</h3><blockquote><p>可以用 <code>v-for</code> 指令基于一个<strong>数组([ ….. ])**来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的</strong>别名** </p><p> 在 <code>v-for</code> 块中，可以访问所有父作用域的 property </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-1&quot;&gt;</span><br><span class="line">    &lt;ul id&#x3D;&quot;example-1&quot;&gt;</span><br><span class="line">        &lt;li v-for&#x3D;&quot;item in items&quot; :key&#x3D;&quot;item.message&quot;&gt;</span><br><span class="line">            &#123;&#123; item.message &#125;&#125;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#example-1&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            items:[</span><br><span class="line">                &#123;message: &#39;Foo&#39;&#125;,</span><br><span class="line">                &#123;message: &#39;Bar&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>v-for</code> 还支持一个可选的第二个参数，即当前项的索引</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;example-1&quot;&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;(item, idx) in items&quot; :key&#x3D;&quot;item.message&quot;&gt;</span><br><span class="line">        &#123;&#123; item.message &#125;&#125; - &#123;&#123; idx &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><p>注： 也可以用 <code>of</code> 替代 <code>in</code> 作为分隔符，因为它更接近 JavaScript 迭代器的语法 </p><h3 id="在-v-for-里使用对象"><a href="#在-v-for-里使用对象" class="headerlink" title="在 v-for 里使用对象"></a>在 <code>v-for</code> 里使用对象</h3><blockquote><p>可以用 <code>v-for</code> 来遍历一个**对象({….})**的 property </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;v-for-object&quot; class&#x3D;&quot;demo&quot;&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;value of object&quot;&gt;</span><br><span class="line">        &#123;&#123; value &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm_2 &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#v-for-object&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            object: &#123;</span><br><span class="line">                title: &quot;how to do&quot;,</span><br><span class="line">                author: &quot;jane&quot;,</span><br><span class="line">                publishedAt: &quot;2016-04-10&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>若存在第二个参数，则为键名即v-for=”(value, key) in object”</p><p>若存在第三个参数，则为索引即v-for=”(value, key, idx) in object”</p></blockquote><p>在遍历对象时，会按 <code>Object.keys()</code> 的结果遍历，但是<strong>不能</strong>保证它的结果在不同的 JavaScript 引擎下都一致。</p><h3 id="维护状态"><a href="#维护状态" class="headerlink" title="维护状态"></a>维护状态</h3><blockquote><p>当 Vue 正在更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。 </p><p>这个默认的模式是高效的，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</strong>。</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 <code>key</code> attribute：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-for&#x3D;&quot;item in items&quot; v-bind:key&#x3D;&quot;item.id&quot;&gt;   </span><br><span class="line">    &lt;!-- 内容 --&gt; </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><strong>不要使用对象或数组之类的非基本类型值作为 <code>v-for</code> 的 <code>key</code>。请用字符串或数值类型的值</strong> ?</p></blockquote><h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><h4 id="变更方法"><a href="#变更方法" class="headerlink" title="变更方法"></a>变更方法</h4><blockquote><p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p></blockquote><ul><li><code>push()</code></li><li><code>pop()</code></li><li><code>shift()</code></li><li><code>unshift()</code></li><li><code>splice()</code></li><li><code>sort()</code></li><li><code>reverse()</code></li></ul><blockquote><p>打开控制台，然后对前面例子的 <code>items</code> 数组尝试调用变更方法。比如 <code>example1.items.push(&#123; message: &#39;Baz&#39; &#125;)</code>,视图会更新</p></blockquote><p> 变更方法，顾名思义，会变更调用了这些方法的原始数组 </p><h4 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h4><p> <code>filter()</code>、<code>concat()</code> 和 <code>slice()</code>。它们不会变更原始数组，而<strong>总是返回一个新数组</strong>。当使用非变更方法时，可以用新数组替换旧数组 </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.items = vm.items.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;<span class="keyword">return</span> item.message.match(<span class="regexp">/Foo/</span>)&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。 </p></blockquote><p>注：由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化 </p><h3 id="显示过滤-排序后的结果"><a href="#显示过滤-排序后的结果" class="headerlink" title="显示过滤/排序后的结果"></a>显示过滤/排序后的结果</h3><blockquote><p>显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;ul id&#x3D;&quot;filter&quot;&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#filter&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            numbers: [1, 2, 3, 4, 5]</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            evenNumbers: function() &#123;</span><br><span class="line">                return this.numbers.filter(function(number)&#123;</span><br><span class="line">                    return number%2 &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>在计算属性不适用的情况下 (例如，在嵌套 <code>v-for</code> 循环中) 可以使用一个<strong>方法</strong> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;qiantao&quot;&gt;</span><br><span class="line">    &lt;ul v-for&#x3D;&quot;set in sets&quot;&gt;</span><br><span class="line">        &lt;li v-for&#x3D;&quot;n in even(set)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#qiantao&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            sets: [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">        methods: &#123;</span><br><span class="line">            even: function (numbers) &#123;</span><br><span class="line">                return numbers.filter(function (number) &#123;</span><br><span class="line">                    return number % 2 &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="在-v-for-里使用值范围"><a href="#在-v-for-里使用值范围" class="headerlink" title="在 v-for 里使用值范围"></a>在 <code>v-for</code> 里使用值范围</h3><p><code>v-for</code> 也可以接受整数。在这种情况下，它会把模板重复对应次数。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 10&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在-lt-template-gt-上使用v-for"><a href="#在-lt-template-gt-上使用v-for" class="headerlink" title="在&lt;template&gt;上使用v-for"></a>在<code>&lt;template&gt;</code>上使用v-for</h3><p>类似于 <code>v-if</code>，也可以利用带有 <code>v-for</code> 的 <code>&lt;template&gt;</code>来循环渲染一段包含多个元素的内容。比如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;divider&quot;</span> <span class="attr">role</span>=<span class="string">&quot;presentation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-for与v-if"><a href="#v-for与v-if" class="headerlink" title="v-for与v-if"></a>v-for与v-if</h3><p> <strong>不</strong>推荐在<strong>同一元素</strong>上使用 <code>v-if</code> 和 <code>v-for</code> </p><blockquote><p>当它们处于<strong>同一节点</strong>，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中。当只想为<em>部分</em>项渲染节点时，这种优先级的机制会十分有用 </p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>上面的代码将只渲染未完成的 todo</strong></p><p>而目的是有条件地跳过循环的执行，那么可以将 <code>v-if</code> 置于外层元素 (或 <code>&lt;template&gt;</code>) 上。如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;todos.length&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No todos left!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在组件上使用v-for"><a href="#在组件上使用v-for" class="headerlink" title="在组件上使用v-for######################################"></a>在组件上使用v-for######################################</h3><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><p> 用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-1&quot;&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;counter +&#x3D; 1&quot;&gt;Add 1&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var example1 &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#example-1&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            counter: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h3><blockquote><p>许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 <code>v-on</code> 指令中是不可行的。因此 <code>v-on</code> 还可以接收一个需要调用的方法名称 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-2&quot;&gt;</span><br><span class="line">    &lt;!-- &#96;greet&#96; 是在下面定义的方法名 --&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;greet&quot;&gt;Greet&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var example2 &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#example-2&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            name: &#39;Vue.js&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 在 &#96;methods&#96; 对象中定义方法</span><br><span class="line">        methods: &#123;</span><br><span class="line">            greet: function (event) &#123;</span><br><span class="line">                &#x2F;&#x2F; &#96;this&#96; 在方法里指向当前 Vue 实例</span><br><span class="line">                alert(&#39;Hello &#39; + this.name + &#39;!&#39;)</span><br><span class="line">                &#x2F;&#x2F; &#96;event&#96; 是原生 DOM 事件</span><br><span class="line">                if (event) &#123;</span><br><span class="line">                    alert(event.target.tagName + &quot; yes&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 也可以用 JavaScript 直接调用方法 此时event为false</span><br><span class="line">    example2.greet() &#x2F;&#x2F; &#x3D;&gt; &#39;Hello Vue.js!&#39;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h3><blockquote><p>除了绑定方法，也可以在内联javascript语句中直接调用</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-3&quot;&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;say(&#39;hi&#39;)&quot;&gt;Say hi&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;say(&#39;what&#39;)&quot;&gt;Say what&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &#39;#example-3&#39;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            say: function (message) &#123;</span><br><span class="line">                alert(message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p> ?有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: <span class="function"><span class="keyword">function</span> (<span class="params">message, event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 现在我们可以访问原生事件对象</span></span><br><span class="line">    <span class="keyword">if</span> (event) &#123;</span><br><span class="line">      event.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p> 更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 </p><blockquote><p>Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。修饰符是由点开头的指令后缀来表示的 </p></blockquote><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent&#x3D;&quot;doThat&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture&#x3D;&quot;doThis&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="line">&lt;div v-on:click.self&#x3D;&quot;doThat&quot;&gt;...&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。 </p></blockquote><h4 id="新增-3"><a href="#新增-3" class="headerlink" title="新增###########################3"></a>新增###########################3</h4><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><blockquote><p>在监听键盘事件时，经常需要检查详细的按键。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符： </p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 可以直接将 <code>KeyboardEvent.key</code> 暴露的任意有效按键名转换为 kebab-case 来作为修饰符 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 处理函数只会在 $event.key 等于 PageDown 时被调用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.page-down</span>=<span class="string">&quot;onPageDown&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="按键码"><a href="#按键码" class="headerlink" title="按键码"></a>按键码</h4><p> <code>keyCode</code> 的事件用法已经废弃了并可能不会被最新的浏览器支持。 </p><p> 使用 <code>keyCode</code> attribute 也是允许的 ：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名： </p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><blockquote><p>可以通过全局 <code>config.keyCodes</code> 对象自定义按键修饰符别名 </p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以使用 `v-on:keyup.f1`</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br></pre></td></tr></table></figure><h3 id="系统修饰符"><a href="#系统修饰符" class="headerlink" title="系统修饰符"></a>系统修饰符</h3><p> 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.alt.67</span>=<span class="string">&quot;clear&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="exact修饰符"><a href="#exact修饰符" class="headerlink" title=".exact修饰符"></a>.exact修饰符</h4><p> <code>.exact</code> 修饰符允许控制由精确的系统修饰符组合触发的事件 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h4><ul><li><p><code>.left</code></p></li><li><p><code>.right</code></p></li><li><p><code>.middle</code></p><p>这些修饰符会限制处理函数仅响应特定的鼠标按钮</p></li></ul><h3 id="HTML中监听事件"><a href="#HTML中监听事件" class="headerlink" title="HTML中监听事件"></a>HTML中监听事件</h3><p> 所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 <code>v-on</code> 有几个好处： </p><ol><li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li><li>因为无须在 JavaScript 里手动绑定事件， ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li><li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。无须担心如何清理它们。</li></ol><h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><p>可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code> 及 <code>&lt;textarea&gt;</code> <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。 <code>v-model</code> 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p><p><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> attribute 的初始值而总是将 Vue 实例的数据作为数据来源。应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</p><p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li><li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li><li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li></ul><p>对于需要使用输入法(如中文、日文、韩文等) 的语言， <code>v-model</code> 不会在输入法组合文字过程中得到更新。如果需要处理这个过程，可以使用 <code>input</code> 事件。</p><blockquote><p><strong>双向数据绑定</strong></p></blockquote><h4 id="文本-1"><a href="#文本-1" class="headerlink" title="文本"></a>文本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-1&quot;&gt;</span><br><span class="line">    &lt;input v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;edit me&quot;&gt;</span><br><span class="line">    &lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#example-1&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;Multiline message is:&lt;&#x2F;span&gt;</span><br><span class="line">&lt;p style&#x3D;&quot;white-space: pre-line;&quot;&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;textarea v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;add multiple lines&quot;&gt;&lt;&#x2F;textarea&gt;</span><br></pre></td></tr></table></figure><blockquote><p>同样需要在js中初始化message</p></blockquote><h4 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-2&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;checked&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;&#x2F;label&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#example-2&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            checked: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><img src="/2021/01/28/Vue/vue/image-20201119165917686.png" alt="image-20201119165917686"></p><blockquote><p><strong>多个复选框</strong>，绑定到同一个数组： </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-3&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;jack&quot; value&#x3D;&quot;Jack&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;jack&quot;&gt;Jack&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;john&quot; value&#x3D;&quot;John&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;john&quot;&gt;John&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;mike&quot; value&#x3D;&quot;Mike&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;mike&quot;&gt;Mike&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#example-3&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            checkedNames: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>value为加入数组的值</p></blockquote><h4 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-4&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;one&quot; value&#x3D;&quot;One&quot; v-model&#x3D;&quot;picked&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;one&quot;&gt;One&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;two&quot; value&#x3D;&quot;Two&quot; v-model&#x3D;&quot;picked&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;two&quot;&gt;Two&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#example-4&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            picked: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>value为picked的值</p></blockquote><h4 id="选择框"><a href="#选择框" class="headerlink" title="选择框"></a>选择框</h4><h5 id="单选："><a href="#单选：" class="headerlink" title="单选："></a>单选：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-5&quot;&gt;</span><br><span class="line">    &lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">        &lt;option disabled value&#x3D;&quot;&quot;&gt;请选择&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;A&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;B&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;C&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#example-5&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            selected: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果 <code>v-model</code> 表达式的初始值未能匹配任何选项，<code>&lt;select&gt;</code> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。 </p></blockquote><h5 id="多选时绑定至一个数组："><a href="#多选时绑定至一个数组：" class="headerlink" title="多选时绑定至一个数组："></a>多选时绑定至一个数组：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-6&quot;&gt;</span><br><span class="line">    &lt;select v-model&#x3D;&quot;selected&quot; multiple style&#x3D;&quot;width: 50px;&quot;&gt;</span><br><span class="line">        &lt;option&gt;A&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;B&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;C&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#example-6&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            selected: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p> 用 <code>v-for</code> 渲染的动态选项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-7&quot;&gt;</span><br><span class="line">    &lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">        &lt;option v-for&#x3D;&quot;option in options&quot; v-bind:value&#x3D;&quot;option.value&quot;&gt;</span><br><span class="line">            &#123;&#123; option.text &#125;&#125;</span><br><span class="line">        &lt;&#x2F;option&gt;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#example-7&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            selected: &#39;A&#39;,</span><br><span class="line">            options: [</span><br><span class="line">                &#123;text: &#39;One&#39;, value: &#39;A&#39;&#125;,</span><br><span class="line">                &#123;text: &#39;Two&#39;, value: &#39;B&#39;&#125;,</span><br><span class="line">                &#123;text: &#39;Three&#39;, value: &#39;C&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><img src="/2021/01/28/Vue/vue/image-20201119171613231.png"></p><h3 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h3><p> 对于单选按钮，复选框及选择框的选项，<code>v-model</code> 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)， 但是有时可能想把值绑定到 Vue 实例的一个动态 property 上，这时可以用 <code>v-bind</code> 实现，并且这个 property 的值可以不是字符串。 </p><blockquote><p>v-bind设置元素属性</p></blockquote><h4 id="复选框-1"><a href="#复选框-1" class="headerlink" title="复选框"></a>复选框</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-8&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;toggle&quot; true-value&#x3D;&quot;yes&quot; false-value&#x3D;&quot;no&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#example-8&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            toggle: &#39;yes&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>// 当选中时 </p><p>vm.toggle === ‘yes’ </p><p>// 当没有选中时 </p><p>vm.toggle === ‘no </p></blockquote><p>这里的 <code>true-value</code> 和 <code>false-value</code> attribute 并不会影响输入控件的 <code>value</code> attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(即“yes”或“no”)，请换用单选按钮。</p><h4 id="单选按钮-1"><a href="#单选按钮-1" class="headerlink" title="单选按钮"></a>单选按钮</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-8&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;radio&quot; v-model&#x3D;&quot;pick&quot; v-bind:value&#x3D;&quot;a&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#example-8&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            a: &quot;12&quot;,</span><br><span class="line">            pick: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line">vm.pick === vm.a</span><br></pre></td></tr></table></figure><h4 id="选择框选项"><a href="#选择框选项" class="headerlink" title="选择框选项"></a>选择框选项</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-8&quot;&gt;</span><br><span class="line">    &lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">        &lt;!-- 内联对象字面量 --&gt;</span><br><span class="line">        &lt;option v-bind:value&#x3D;&quot;&#123; number: 123 &#125;&quot;&gt;123&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#example-8&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            selected: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line"><span class="keyword">typeof</span> vm.selected <span class="comment">// =&gt; &#x27;object&#x27;</span></span><br><span class="line">vm.selected.number <span class="comment">// =&gt; 123</span></span><br></pre></td></tr></table></figure><h3 id="修饰符-1"><a href="#修饰符-1" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h4><p> 在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 <code>lazy</code> 修饰符，从而转为在 <code>change</code> 事件_之后_进行同步： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-9&quot;&gt;</span><br><span class="line">    &lt;!-- 在“change”时而非“input”时更新 --&gt;</span><br><span class="line">    &lt;input v-model.lazy&#x3D;&quot;msg&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#example-9&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            msg: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h4><p> 如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-9&quot;&gt;</span><br><span class="line">    &lt;textarea&gt;&#123;&#123; age &#125;&#125;&lt;&#x2F;textarea&gt;</span><br><span class="line">    &lt;input v-model.number&#x3D;&quot;age&quot; type&#x3D;&quot;number&quot;&gt;</span><br><span class="line">    &lt;input v-model.trim&#x3D;&quot;msg&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#example-9&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            msg: &quot;&quot;,</span><br><span class="line">            age: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这通常很有用，因为即使在 <code>type=&quot;number&quot;</code> 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 <code>parseFloat()</code> 解析，则会返回原始的值。 </p></blockquote><h4 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h4><blockquote><p>如果要自动过滤用户输入的<strong>首尾</strong>空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符： </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input v-model.trim&#x3D;&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="在组件上使用v-model"><a href="#在组件上使用v-model" class="headerlink" title="在组件上使用v-model"></a>在组件上使用v-model</h3><h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><p>如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义一个名为 button-counter 的新组件</span></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">        data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line">                count: 0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="handlebars"><span class="xml">        template: &#x27;<span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>You clicked me </span><span class="template-variable">&#123;&#123; <span class="name">count</span> &#125;&#125;</span><span class="xml"> times.<span class="tag">&lt;/<span class="name">button</span>&gt;</span>&#x27;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">&#x27;#components-demo&#x27;</span> &#125;)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 <code>&lt;button-counter&gt;</code>。</p><p><strong>可以在一个通过 <code>new Vue</code> 创建的 Vue 根实例中，把这个组件作为自定义元素来使用</strong> </p><blockquote><p>因为组件是可复用的 Vue 实例，所以它们与 <code>new Vue</code> 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code> 以及生命周期钩子等。仅有的例外是像 <code>el</code> 这样根实例特有的选项。 </p></blockquote><h3 id="组件复用"><a href="#组件复用" class="headerlink" title="组件复用"></a>组件复用</h3><p> 可以将组件进行任意次数的复用 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 注意当点击按钮时，每个组件都会各自独立维护它的 <code>count</code>。因为每用一次组件，就会有一个它的<strong>新实例</strong>被创建。 </p><h4 id="data必须为一个函数"><a href="#data必须为一个函数" class="headerlink" title="data必须为一个函数"></a>data必须为一个函数</h4><p> <strong>一个组件的 <code>data</code> 选项必须是一个函数</strong>，因此每个实例可以维护一份被返回对象的独立的拷贝： </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则 点击一个按钮  可能会影响其他实例</p><h3 id="组件组织"><a href="#组件组织" class="headerlink" title="组件组织"></a>组件组织</h3><p> 通常一个应用会以一棵嵌套的组件树的形式来组织， 可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。 </p><img src="/2021/01/28/Vue/vue/image-20201120200651704.png" alt="image-20201120200651704" style="zoom:50%;"><p> 为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型 <strong>全局注册</strong>和<strong>局部注册</strong> </p><blockquote><p>全局注册的组件可以用在其被注册之后的任何 (通过 <code>new Vue</code>) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。 </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component-name&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// ... options ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="通过Prop向子组件传递数据"><a href="#通过Prop向子组件传递数据" class="headerlink" title="通过Prop向子组件传递数据"></a>通过Prop向子组件传递数据</h3><p>Prop 是可以在组件上注册的一些自定义 attribute。当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。为了给博文组件传递一个标题，可以用一个 <code>props</code> 选项将其包含在该组件可接受的 prop 列表中：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;My journey with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;Blogging with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;Why Vue is so fun&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop。能够在组件实例中访问这个值，就像访问 <code>data</code> 中的值一样。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">    props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">    template: <span class="string">&#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;<span class="attr">el</span>: <span class="string">&#x27;#example-2&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>一个 prop 被注册之后，就可以把数据作为一个自定义 attribute 传递进来</p></blockquote><h4 id="v-bind-动态传递-prop"><a href="#v-bind-动态传递-prop" class="headerlink" title="v-bind 动态传递 prop"></a><code>v-bind</code> 动态传递 prop</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;blog-post-demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span> <span class="attr">v-bind:key</span>=<span class="string">&quot;post.id&quot;</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;post.title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#blog-post-demo&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        posts: [</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&#x27;My journey with Vue&#x27;</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&#x27;Blogging with Vue&#x27;</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">&#x27;Why Vue is so fun&#x27;</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>####################</p><h3 id="单个根元素"><a href="#单个根元素" class="headerlink" title="单个根元素"></a>单个根元素</h3><p> 当构建一个组件时，模板最终会包含的东西远不止一个标题，如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">            props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">            template: <span class="string">&#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&lt;div v-html=&quot;content&quot;&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p><img src="/2021/01/28/Vue/vue/image-20201120221326902.png" alt="image-20201120221326902"></p><p>但 <strong>每个组件必须只有一个根元素</strong> ，因此可以将模板的内容包裹在一个父元素内，来修复这个问题，如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">            props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">            template: <span class="string">&#x27;&lt;div class=&quot;blog-post&quot;&gt;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&lt;div v-html=&quot;content&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>当组件变得越来越复杂的时候，不只需要标题和内容，还需要发布日期、评论等等。为每个相关的信息定义一个 prop 会变得很麻烦： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-for=&quot;post in posts&quot;</span><br><span class="line">  v-bind:key=&quot;post.id&quot;</span><br><span class="line">  v-bind:title=&quot;post.title&quot;</span><br><span class="line">  v-bind:content=&quot;post.content&quot;</span><br><span class="line">  v-bind:publishedAt=&quot;post.publishedAt&quot;</span><br><span class="line">  v-bind:comments=&quot;post.comments&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以可以重构该组件,变成接受一个单独的post prop：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-for=&quot;post in posts&quot;</span><br><span class="line">  v-bind:key=&quot;post.id&quot;</span><br><span class="line">  v-bind:post=&quot;post&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;post&#x27;</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;blog-post&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h3><p>在开发一个组件时， 一些功能可能要求和父级组件进行沟通。例如可能会引入一个辅助功能来放大博文的字号，同时让页面的其它部分保持默认的字号 </p><p> <strong>父组件中，可以通过添加一个 <code>postFontSize</code> 数据 property 来支持这个功能</strong> </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;blog-posts-events-demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; fontSize: postFontSize + &#x27;em&#x27; &#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span> <span class="attr">v-bind:key</span>=<span class="string">&quot;post.id&quot;</span> <span class="attr">v-bind:post</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件blog-posts-events-demo</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#blog-posts-events-demo&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        posts: [<span class="comment">/* ... */</span></span><br><span class="line">            &#123;<span class="attr">title</span>: <span class="string">&quot;My journey with Vue&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;...content...&quot;</span>&#125;</span><br><span class="line">        ],</span><br><span class="line">        postFontSize: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>postFontSize为一个属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">    props: [<span class="string">&#x27;post&#x27;</span>],</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;blog-post&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">            &lt;button&gt;</span></span><br><span class="line"><span class="string">            Enlarge text</span></span><br><span class="line"><span class="string">            &lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述按钮并不会做任何事， 当点击这个按钮时，需要告诉父级组件放大所有博文的文本。 Vue 实例提供了一个自定义事件的系统来解决这个问题。父级组件可以像处理 native DOM 事件一样通过 <code>v-on</code> 监听子组件实例的任意事件： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span> <span class="attr">v-bind:key</span>=<span class="string">&quot;post.id&quot;</span> <span class="attr">v-bind:post</span>=<span class="string">&quot;post&quot;</span>  <span class="attr">v-on:enlarge-text</span>=<span class="string">&quot;postFontSize += 0.1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 同时子组件button可以通过调用内建的 <strong><code>$emit</code></strong> 方法并传入事件名称来触发一个事件： </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">    props: [<span class="string">&#x27;post&#x27;</span>],</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;blog-post&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">            &lt;button v-on:click=&quot;$emit(&#x27;enlarge-text&#x27;)&quot;&gt;</span></span><br><span class="line"><span class="string">            Enlarge text</span></span><br><span class="line"><span class="string">            &lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 有了这个 <code>v-on:enlarge-text=&quot;postFontSize += 0.1&quot;</code> 监听器，父级组件就会接收该事件并更新 <code>postFontSize</code> 的值。 </p><h4 id="使用事件抛出一个值"><a href="#使用事件抛出一个值" class="headerlink" title="使用事件抛出一个值"></a>使用事件抛出一个值</h4><p>有的时候用一个事件来抛出一个特定的值是非常有用的。例如可能想让 <code>&lt;blog-post&gt;</code> 组件决定它的文本要放大多少。这时可以使用 <code>$emit</code> 的第二个参数来提供这个值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button v-on:click=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;, 0.1)&quot;</span>&gt;</span><br><span class="line">  Enlarge text</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><ul><li><p>当在父级组件监听这个事件的时候，可以通过 <code>$event</code> 访问到被抛出的这个值 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  ...</span><br><span class="line">  v-on:enlarge-text=&quot;postFontSize += $event&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>或者，事件处理函数也可以是一个方法， 那么这个值将会作为<strong>第一个参数</strong>传入这个方法 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  ...</span><br><span class="line">  v-on:enlarge-text=&quot;onEnlargeText&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  onEnlargeText: <span class="function"><span class="keyword">function</span> (<span class="params">enlargeAmount</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.postFontSize += enlargeAmount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="在组件上使用v-model-1"><a href="#在组件上使用v-model-1" class="headerlink" title="在组件上使用v-model"></a>在组件上使用v-model</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event.target.value&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>在组件上时，</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>script中定义：</p><blockquote><p>为了让它正常工作，这个组件内的 <code>&lt;input&gt;</code>必须：</p><ul><li> 将其 <code>value</code> attribute 绑定到一个名叫 <code>value</code> 的 prop 上</li><li>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>input</code> 事件抛出</li></ul></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;custom-input&#x27;</span>, &#123;</span><br><span class="line">    props:[<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">    v-bind:value=&#x27;value&#x27; </span></span><br><span class="line"><span class="string">    v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&quot;#ex1&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        searchText: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时 <code>v-model</code> 就应该可以在这个组件上完美地工作起来了： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通过插槽分发内容"><a href="#通过插槽分发内容" class="headerlink" title="通过插槽分发内容"></a>通过插槽分发内容</h3><p>当需要向一个组件传递内容，如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alert-box</span>&gt;</span></span><br><span class="line">  Something bad happened.</span><br><span class="line"><span class="tag">&lt;/<span class="name">alert-box</span>&gt;</span></span><br></pre></td></tr></table></figure><p>希望：</p><img src="/2021/01/28/Vue/vue/image-20201122142118683.png" alt="image-20201122142118683" style="zoom:50%;"><p>Vue提供了<code>&lt;slot&gt;</code>元素：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;alert-box&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;demo-alert-box&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;strong&gt;Error!&lt;/strong&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p> 不同组件之间进行动态切换可以通过Vue的<code>&lt;component&gt;</code>元素加一个特殊的<code>&lt;is&gt;</code> attribute来实现</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>currentTabComponent</code> 可以包括</p><ul><li><p>已注册组件的名字，或</p></li><li><p>一个组件的选项对象</p></li></ul><p>这个 attribute 可以用于常规 HTML 元素，但这些元素将被视为组件，这意味着所有的 attribute <strong>都会作为 DOM attribute 被绑定</strong>。对于像 <code>value</code> 这样的 property，若想让其如预期般工作，需要使用 <code>.prop</code> 修饰器 </p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dynamic-component-demo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-for</span>=<span class="string">&quot;tab in tabs&quot;</span> <span class="attr">v-bind:key</span>=<span class="string">&quot;tab&quot;</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[&#x27;tab-button&#x27;, &#123; active: currentTab === tab &#125;]&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">v-on:click</span>=<span class="string">&quot;currentTab = tab&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; tab &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">&quot;currentTabComponent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tab&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">&quot;tab-home&quot;</span>, &#123;</span><br><span class="line">    template: <span class="string">&quot;&lt;div&gt;Home component&lt;/div&gt;&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line">Vue.component(<span class="string">&quot;tab-posts&quot;</span>, &#123;</span><br><span class="line">    template: <span class="string">&quot;&lt;div&gt;Posts component&lt;/div&gt;&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line">    Vue.component(<span class="string">&quot;tab-archive&quot;</span>, &#123;</span><br><span class="line">        template: <span class="string">&quot;&lt;div&gt;Archive component&lt;/div&gt;&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">&quot;#dynamic-component-demo&quot;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            currentTab: <span class="string">&quot;Home&quot;</span>,</span><br><span class="line">            tabs: [<span class="string">&quot;Home&quot;</span>, <span class="string">&quot;Posts&quot;</span>, <span class="string">&quot;Archive&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            currentTabComponent: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;tab-&quot;</span> + <span class="built_in">this</span>.currentTab.toLowerCase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="解析DOM模板注意事项"><a href="#解析DOM模板注意事项" class="headerlink" title="解析DOM模板注意事项"></a>解析DOM模板注意事项</h3><p>有些 HTML 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;</code>、 <code>&lt;tr&gt;</code>和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。  这会导致使用这些有约束条件的元素时遇到一些问题。例如： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">blog-post-row</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这个自定义组件 <code>&lt;blog-post-row&gt;</code> 会被作为无效的内容提升到外部，并导致最终渲染结果出错</p><p> <code>is</code> attribute 给出一个变通的办法： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">&quot;blog-post-row&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是<strong>如果从以下来源使用模板的话，这条限制是不存在的</strong>：</p><ul><li>字符串 (例如：<code>template: &#39;...&#39;</code>)</li><li>单文件组件 (<code>.vue</code>)</li><li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li></ul></blockquote><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;my-component-name&quot;</span>, &#123;</span><br><span class="line">template: <span class="string">&quot;&lt;div&gt;...&lt;/div&gt;&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>组件名大小写：</p><ol><li><p>使用kebab-case 短横线分隔命名 ,同上</p><p>引用这个自定义元素时使用 kebab-case，例如 <code>&lt;my-component-name&gt;</code> </p></li><li><p>使用PascalCase 首字母大写命名 </p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;MyComponentName&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure><p> 引用这个自定义元素时两种命名法都可以使用。也就是说 <code>&lt;my-component-name&gt;</code> 和 <code>&lt;MyComponentName&gt;</code> 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。 </p></blockquote><p>以上定义方式为全局注册，也就是说在注册之后可以用在任何新创建的 Vue 根实例 (<code>new Vue</code>) 的模板中， <strong>在所有子组件中也是如此，也就是说这三个组件<em>在各自内部</em>也都可以相互使用</strong> </p><p><img src="/2021/01/28/Vue/vue/image-20201130165208745.png" alt="image-20201130165208745"></p><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p> 可以通过一个普通的 JavaScript 对象来定义组件 </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentC = &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p> 在 <code>components</code> 选项中定义想要使用的组件 </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>: ComponentA,</span><br><span class="line">    <span class="string">&#x27;component-b&#x27;</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>对于 <code>components</code> 对象中的每个 property 来说，其 <strong>property 名就是自定义元素的名字</strong>，其 <strong>property 值就是这个组件的选项对象</strong> </p></blockquote><blockquote><p>对于局部注册的组件互相可用问题：</p><p>可如下定义</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>: ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统########"></a>模块系统########</h4><h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><h4 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h4><p>HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名： </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 在 JavaScript 中是 camelCase 的</span></span><br><span class="line">  props: [<span class="string">&#x27;postTitle&#x27;</span>],</span><br><span class="line">  template: <span class="string">&#x27;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">post-title</span>=<span class="string">&quot;hello!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p> 可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型： </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span>,</span><br><span class="line">  callback: <span class="built_in">Function</span>,</span><br><span class="line">  contactsPromise: <span class="built_in">Promise</span> <span class="comment">// or any other constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传递静态或动态Prop"><a href="#传递静态或动态Prop" class="headerlink" title="传递静态或动态Prop"></a>传递静态或动态Prop</h4><ul><li><p>静态</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;My journey with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>动态</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态赋予一个变量的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;post.title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态赋予一个复杂表达式的值 --&gt;</span></span><br><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:title=&quot;post.title + &#x27; by &#x27; + post.author.name&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以传递其他类型：</p></li><li><p>传入一个数字</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便 `42` 是静态的，仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:likes</span>=<span class="string">&quot;42&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:likes</span>=<span class="string">&quot;post.likes&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>传入一个布尔值</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">is-published</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 即便 `false` 是静态的，仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:is-published</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:is-published</span>=<span class="string">&quot;post.isPublished&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>传入一个数组</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便数组是静态的，仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:comment-ids</span>=<span class="string">&quot;[234, 266, 273]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:comment-ids</span>=<span class="string">&quot;post.commentIds&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>传入一个对象</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便对象是静态的，仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:author=&quot;&#123;</span><br><span class="line">    name: &#x27;Veronica&#x27;,</span><br><span class="line">    company: &#x27;Veridian Dynamics&#x27;</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:author</span>=<span class="string">&quot;post.author&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>传入一个对象的所有 property</li></ul><p>如果想要将一个对象的所有 property 都作为 prop 传入，可以使用不带参数的 <code>v-bind</code> (取代 <code>v-bind:prop-name</code>)。例如，对于一个给定的对象 <code>post</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">post: &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  title: <span class="string">&#x27;My Journey with Vue&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的模板：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:id=&quot;post.id&quot;</span><br><span class="line">  v-bind:title=&quot;post.title&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><blockquote><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致应用的数据流向难以理解。</p><p>额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着<strong>不</strong>应该在一个子组件内部改变 prop。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p></blockquote><ol><li><p><strong>prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong>在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值： </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">&#x27;initialCounter&#x27;</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="built_in">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>prop 以一种原始的值传入且需要进行转换。</strong>在这种情况下，最好使用这个 prop 的值来定义一个计算属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">&#x27;size&#x27;</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身<strong>将会</strong>影响到父组件的状态。 </p></blockquote></li></ol><h4 id="Prop验证"><a href="#Prop验证" class="headerlink" title="Prop验证"></a>Prop验证</h4><p>为了定制 prop 的验证方式，可以为 <code>props</code> 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如 </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;danger&#x27;</span>].indexOf(value) !== -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。 </p><p> 注意那些 prop 会在一个组件实例创建<strong>之前</strong>进行验证，所以实例的 property (如 <code>data</code>、<code>computed</code> 等) 在 <code>default</code> 或 <code>validator</code> 函数中是不可用的。 </p></blockquote><h5 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h5><p><code>type</code> 可以是下列原生构造函数中的一个：</p><ul><li><code>String</code></li><li><code>Number</code></li><li><code>Boolean</code></li><li><code>Array</code></li><li><code>Object</code></li><li><code>Date</code></li><li><code>Function</code></li><li><code>Symbol</code></li></ul><p>额外的，<code>type</code> 还可以是一个自定义的构造函数，并且通过 <code>instanceof</code> 来进行检查确认。例如，给定下列现成的构造函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.firstName = firstName</span><br><span class="line">  <span class="built_in">this</span>.lastName = lastName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用如下来验证 <code>author</code> prop 的值是否是通过 <code>new Person</code> 创建的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    author: Person</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="非Prop的Attribute"><a href="#非Prop的Attribute" class="headerlink" title="非Prop的Attribute"></a>非Prop的Attribute</h4><p>一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的 attribute，而这些 attribute 会被添加到这个组件的根元素上。</p><p>例如，通过一个 Bootstrap 插件使用了一个第三方的 <code>&lt;bootstrap-date-input&gt;</code> 组件，这个插件需要在其 <code>&lt;input&gt;</code> 上用到一个 <code>data-date-picker</code> attribute。可以将这个 attribute 添加到组件实例上：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bootstrap-date-input</span> <span class="attr">data-date-picker</span>=<span class="string">&quot;activated&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bootstrap-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>然后这个 <code>data-date-picker=&quot;activated&quot;</code> attribute 就会自动添加到 <code>&lt;bootstrap-date-input&gt;</code> 的根元素上。</strong></p></blockquote><h5 id="替换-合并已有attribute"><a href="#替换-合并已有attribute" class="headerlink" title="替换/合并已有attribute"></a>替换/合并已有attribute</h5><p>如 <code>&lt;bootstrap-date-input&gt;</code> 的模板是这样的：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了给日期选择器插件定制一个主题，可能需要像这样添加一个特别的类名：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;bootstrap-date-input</span><br><span class="line">  data-date-picker=&quot;activated&quot;</span><br><span class="line">  class=&quot;date-picker-theme-dark&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">bootstrap-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在这种情况下，定义了两个不同的 <code>class</code> 的值：</p><ul><li><code>form-control</code>，这是在组件的模板内设置好的</li><li><code>date-picker-theme-dark</code>，这是从组件的父级传入的</li></ul></blockquote><p>对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 <code>type=&quot;text&quot;</code> 就会替换掉 <code>type=&quot;date&quot;</code> 并把它破坏！庆幸的是，<code>class</code> 和 <code>style</code> attribute 会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：<code>form-control date-picker-theme-dark</code>。</p><h5 id="禁用attribute继承"><a href="#禁用attribute继承" class="headerlink" title="禁用attribute继承"></a>禁用attribute继承</h5><p>如果<strong>不</strong>希望组件的根元素继承 attribute，可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这尤其适合配合实例的 <strong><code>$attrs</code> property</strong> 使用，该 property 包含了传递给一个组件的 attribute 名和 attribute 值，例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  required: <span class="literal">true</span>,</span><br><span class="line">  placeholder: <span class="string">&#x27;Enter your username&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 <code>inheritAttrs: false</code> 和 <code>$attrs</code>，就可以手动决定这些 attribute 会被赋予哪个元素</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;base-input&#x27;</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind=&quot;$attrs&quot;</span></span><br><span class="line"><span class="string">        v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">        v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意 <code>inheritAttrs: false</code> 选项<strong>不会</strong>影响 <code>style</code> 和 <code>class</code> 的绑定。</p></blockquote><p>这个模式允许在使用基础组件的时候更像是使用原始的 HTML 元素，而不会担心哪个元素是真正的根元素：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;base-input</span><br><span class="line">  v-model=&quot;username&quot;</span><br><span class="line">  required</span><br><span class="line">  placeholder=&quot;Enter your username&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><h4 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h4><p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p><p>因此，推荐<strong>始终使用 kebab-case 的事件名</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;myEvent&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 没有效果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-on:my-event</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义组件的v-model"><a href="#自定义组件的v-model" class="headerlink" title="自定义组件的v-model"></a>自定义组件的v-model</h4><blockquote><p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于不同的目的。<code>model</code> 选项可以用来避免这样的冲突： </p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;base-checkbox&#x27;</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">&#x27;checked&#x27;</span>,</span><br><span class="line">    event: <span class="string">&#x27;change&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type=&quot;checkbox&quot;</span></span><br><span class="line"><span class="string">      v-bind:checked=&quot;checked&quot;</span></span><br><span class="line"><span class="string">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在该组件使用v-model：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-checkbox</span> <span class="attr">v-model</span>=<span class="string">&quot;lovingVue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的 property 将会被更新。 </p></blockquote><h4 id="将原生事件绑定到组件⭐"><a href="#将原生事件绑定到组件⭐" class="headerlink" title="将原生事件绑定到组件⭐"></a>将原生事件绑定到组件⭐</h4><p>使用 <code>v-on</code> 的 <code>.native</code> 修饰符，监听原生事件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">v-on:focus.native</span>=<span class="string">&quot;onFocus&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但当定义如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  &#123;&#123; label &#125;&#125;</span><br><span class="line">  &lt;input</span><br><span class="line">    v-bind=&quot;$attrs&quot;</span><br><span class="line">    v-bind:value=&quot;value&quot;</span><br><span class="line">    v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="line">  &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时根元素为label，则父级的 <code>.native</code> 监听器将静默失败 </p><blockquote><p><strong>Vue提供了一个 <code>$listeners</code> property，它是一个对象，里面包含了作用在这个组件上的所有监听器</strong> </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  focus: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  input: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素 </p></blockquote><p> 对于类似 <code>&lt;input&gt;</code> 的希望它也可以配合 <code>v-model</code> 工作的组件来说，为这些监听器创建一个类似下述 <code>inputListeners</code> 的计算属性通常是非常有用的： </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;base-input&#x27;</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    inputListeners: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="built_in">this</span></span><br><span class="line">      <span class="comment">// `Object.assign` 将所有的对象合并为一个新对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,</span><br><span class="line">        <span class="comment">// 我们从父级添加所有的监听器</span></span><br><span class="line">        <span class="built_in">this</span>.$listeners,</span><br><span class="line">        <span class="comment">// 然后我们添加自定义监听器，</span></span><br><span class="line">        <span class="comment">// 或覆写一些监听器的行为</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 这里确保组件配合 `v-model` 的工作</span></span><br><span class="line">          input: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            vm.$emit(<span class="string">&#x27;input&#x27;</span>, event.target.value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind=&quot;$attrs&quot;</span></span><br><span class="line"><span class="string">        v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">        v-on=&quot;inputListeners&quot;</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>现在 <code>&lt;base-input&gt;</code> 组件是一个<strong>完全透明的包裹器</strong>了，也就是说它可以完全像一个普通的 <code>&lt;input&gt;</code> 元素一样使用了：所有跟它相同的 attribute 和监听器都可以工作，不必再使用 <code>.native</code> 监听器 </p></blockquote><h4 id="sync修饰符⭐"><a href="#sync修饰符⭐" class="headerlink" title=".sync修饰符⭐"></a>.sync修饰符⭐</h4><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口，允许像这样合成组件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其模板可以为：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  v-bind:href=&quot;url&quot;</span><br><span class="line">  class=&quot;nav-link&quot;</span><br><span class="line">&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当组件渲染的时候，<code>&lt;slot&gt;&lt;/slot&gt;</code> 将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML，甚至可以包含其他组件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加一个 Font Awesome 图标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加一个图标的组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">font-awesome-icon</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">font-awesome-icon</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果 <code>&lt;navigation-link&gt;</code> 的 <code>template</code> 中<strong>没有</strong>包含一个 <code>&lt;slot&gt;</code> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。 </p></blockquote></blockquote><h4 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h4><p> 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  Logged in as &#123;&#123; user.name &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 该插槽跟模板的其它地方一样可以访问相同的实例 property (也就是相同的“作用域”)，而<strong>不能</strong>访问 <code>&lt;navigation-link&gt;</code> 的作用域。例如 <code>url</code> 是访问不到的： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  Clicking here will send you to: &#123;&#123; url &#125;&#125;</span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  这里的 `url` 会是 undefined，因为其 (指该插槽的) 内容是</span></span><br><span class="line"><span class="comment">  _传递给_ &lt;navigation-link&gt; 的而不是</span></span><br><span class="line"><span class="comment">  在 &lt;navigation-link&gt; 组件*内部*定义的。</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h4><blockquote><p>默认内容，当存在内容了则不需要</p></blockquote><p>只会在没有提供内容的时候被渲染。例如在一个 <code>&lt;submit-button&gt;</code> 组件中： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可能希望这个 <code>&lt;button&gt;</code> 内绝大多数情况下都渲染文本“Submit”。为了将“Submit”作为后备内容，可以将它放在 <code>&lt;slot&gt;</code> 标签内：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当在一个父级组件中使用 <code>&lt;submit-button&gt;</code> 并且不提供任何插槽内容时：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">submit-button</span>&gt;</span><span class="tag">&lt;/<span class="name">submit-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后备内容“Submit”将会被渲染：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是如果提供内容：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">submit-button</span>&gt;</span></span><br><span class="line">  Save</span><br><span class="line"><span class="tag">&lt;/<span class="name">submit-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>则这个提供的内容将会被渲染从而取代后备内容：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  Save</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>对于多个插槽， <code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：<code>name</code>。这个 attribute 可以用来定义额外的插槽 </p><blockquote><p>一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default” </p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="comment">&lt;!-- 默认 !--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当向具体的插槽提供内容时，可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称</p><blockquote><p><strong><code>v-slot</code> 只能添加在<code>&lt;template&gt;</code> 上</strong> </p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 <code>v-slot</code> 的 <code>&lt;template&gt;</code> 中的内容都会被视为默认插槽的内容。 </p><p>因此也可以用显示的default来定义</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终渲染：</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>有时让插槽内容能够访问子组件中才有的数据是很有用的。例如，设想一个带有如下模板的 <code>&lt;current-user&gt;</code> 组件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>&#123;&#123; user.lastName &#125;&#125;<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可能想换掉备用内容，用名而非姓来显示。如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而上述代码不会正常工作，因为只有 <code>&lt;current-user&gt;</code> 组件可以访问到 <code>user</code> 而提供的内容是在父级渲染的。</p><p>为了让 <code>user</code> 在父级的插槽内容中可用，可以将 <code>user</code> 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为<strong>插槽 prop</strong>。现在在父级作用域中，可以使用带值的 <code>v-slot</code> 来定义提供的插槽 prop 的名字：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>选择将包含所有插槽 prop 的对象命名为 <code>slotProps</code>，但也可以使用任意名字。</p></blockquote><h5 id="独占默认插槽的缩写语法"><a href="#独占默认插槽的缩写语法" class="headerlink" title="独占默认插槽的缩写语法"></a>独占默认插槽的缩写语法</h5><p>当被提供的内容<em>只有</em>默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样就可以把 <code>v-slot</code> 直接用在组件上： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>更简单的写法， 不带参数的 <code>v-slot</code> 被假定对应默认插槽： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>： 默认插槽的缩写语法<strong>不能</strong>和具名插槽混用，因为它会导致作用域不明确： </p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 无效，会导致警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">&quot;otherSlotProps&quot;</span>&gt;</span></span><br><span class="line">    slotProps is NOT available here</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>只要出现多个插槽，请始终为<em>所有的</em>插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">&quot;otherSlotProps&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="解构插槽Prop"><a href="#解构插槽Prop" class="headerlink" title="解构插槽Prop"></a>解构插槽Prop</h5><p><strong>作用域插槽的内部工作原理是将插槽内容包裹在一个拥有单个参数的函数里：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">slotProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 插槽内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着 <code>v-slot</code> 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。所以在支持的环境下 也可以使用 ES2015 解构来传入具体的插槽 prop，如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样可以使模板更简洁，尤其是在该插槽提供了多个 prop 的时候。它同样开启了 prop 重命名等其它可能，例如将 <code>user</code> 重命名为 <code>person</code>：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user: person &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; person.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user = &#123; firstName: &#x27;Guest&#x27; &#125; &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h4><p>可以用方括号括起来的 JavaScript 表达式作为一个指令的参数 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="具名插槽缩写"><a href="#具名插槽缩写" class="headerlink" title="具名插槽缩写"></a>具名插槽缩写</h4><p>跟 <code>v-on</code> 和 <code>v-bind</code> 一样，<code>v-slot</code> 也有缩写，即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code>：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这样会触发一个警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">current-user</span> #=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果希望使用缩写的话，必须始终以明确插槽名取而代之：</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> #<span class="attr">default</span>=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>插槽 prop 允许将插槽转换为可复用的模板，这些模板可以基于输入的 prop 渲染出不同的内容。</strong>这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的。</p><p>例如，要实现一个 <code>&lt;todo-list&gt;</code> 组件，它是一个列表且包含布局和过滤逻辑：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  &lt;li</span><br><span class="line">    v-for=&quot;todo in filteredTodos&quot;</span><br><span class="line">    v-bind:key=&quot;todo.id&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以将每个 todo 作为父级组件的插槽，以此通过父级组件对其进行控制，然后将 <code>todo</code> 作为一个插槽 prop 进行绑定：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  &lt;li</span><br><span class="line">    v-for=&quot;todo in filteredTodos&quot;</span><br><span class="line">    v-bind:key=&quot;todo.id&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    我们为每个 todo 准备了一个插槽，</span></span><br><span class="line"><span class="comment">    将 `todo` 对象作为一个插槽的 prop 传入。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;todo&quot;</span> <span class="attr">v-bind:todo</span>=<span class="string">&quot;todo&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 后备内容 --&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在当使用 <code>&lt;todo-list&gt;</code> 组件的时候，可以选择为 todo 定义一个不一样的 <code>&lt;template&gt;</code> 作为替代方案，并且可以从子组件获取数据：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-list</span> <span class="attr">v-bind:todos</span>=<span class="string">&quot;todos&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:todo</span>=<span class="string">&quot;&#123; todo &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;todo.isComplete&quot;</span>&gt;</span>✓<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="废弃"><a href="#废弃" class="headerlink" title="废弃##################"></a>废弃##################</h4><h3 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件&amp;异步组件"></a>动态组件&amp;异步组件</h3><h4 id="动态组件上使用keep-alive"><a href="#动态组件上使用keep-alive" class="headerlink" title="动态组件上使用keep-alive"></a>动态组件上使用keep-alive</h4><p> 每次切换新标签的时候，Vue 都创建了一个新的 <code>currentTabComponent</code> 实例， 更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来。为了解决这个问题，可以用一个 <code>&lt;keep-alive&gt;</code> 元素将其动态组件包裹起来。 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 失活的组件将会被缓存！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意这个 <code>&lt;keep-alive&gt;</code> 要求被切换到的组件都有自己的名字，不论是通过组件的 <code>name</code> 选项还是局部/全局注册。 </p></blockquote><h4 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h4><p>有时需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许<strong>以一个工厂函数的方式定义组件</strong>，这个工厂函数会异步解析组件定义。<strong>只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染</strong>。例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;async-example&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 向 `resolve` 回调传递组件定义</span></span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: <span class="string">&#x27;&lt;div&gt;I am async!&lt;/div&gt;&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此处这个工厂函数会收到一个 <code>resolve</code> 回调，这个回调函数会在从服务器得到组件定义的时候被调用。也可以调用 <code>reject(reason)</code> 来表示加载失败。这里的 <code>setTimeout</code> 是示例的，获取组件取决于自己。一个推荐的做法是将异步组件和 webpack 的 code-splitting 功能一起配合使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;async-webpack-example&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个特殊的 `require` 语法将会告诉 webpack</span></span><br><span class="line">  <span class="comment">// 自动将你的构建代码切割成多个包，这些包</span></span><br><span class="line">  <span class="comment">// 会通过 Ajax 请求加载</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&#x27;./my-async-component&#x27;</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也可以在工厂函数中返回一个 <code>Promise</code>，所以把 webpack 2 和 ES2015 语法加在一起，可以这样使用动态导入：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">&#x27;async-webpack-example&#x27;</span>,</span><br><span class="line">  <span class="comment">// 这个动态导入会返回一个 `Promise` 对象。</span></span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./my-async-component&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当使用局部注册的时候，也可以直接提供一个返回 <code>Promise</code> 的函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">&#x27;my-component&#x27;</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./my-async-component&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="处理加载状态"><a href="#处理加载状态" class="headerlink" title="处理加载状态"></a>处理加载状态</h5><p>这里的异步组件工厂函数也可以返回一个如下格式的对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComponent = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">&#x27;./MyComponent.vue&#x27;</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  loading: LoadingComponent,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class="line">  <span class="comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h3><h4 id="访问元素-amp-组件"><a href="#访问元素-amp-组件" class="headerlink" title="访问元素&amp;组件"></a>访问元素&amp;组件</h4><h5 id="访问根实例"><a href="#访问根实例" class="headerlink" title="访问根实例"></a>访问根实例</h5><p>在每个 <code>new Vue</code> 实例的子组件中，其根实例可以通过 <code>$root</code> property 进行访问。</p><img src="/2021/01/28/Vue/vue/image-20201205114053023.png" alt="image-20201205114053023" style="zoom:50%;"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    foo: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    baz: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>所有子组件都可以将这个实例作为一个全局store来访问或使用</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取根组件的数据</span></span><br><span class="line"><span class="built_in">this</span>.$root.foo</span><br><span class="line"><span class="comment">// 写入根组件的数据</span></span><br><span class="line"><span class="built_in">this</span>.$root.foo = <span class="number">2</span></span><br><span class="line"><span class="comment">// 访问根组件的计算属性</span></span><br><span class="line"><span class="built_in">this</span>.$root.bar</span><br><span class="line"><span class="comment">// 调用根组件的方法</span></span><br><span class="line"><span class="built_in">this</span>.$root.baz()</span><br></pre></td></tr></table></figure><h5 id="访问父级组件实例"><a href="#访问父级组件实例" class="headerlink" title="访问父级组件实例"></a>访问父级组件实例</h5><blockquote><p>和 <code>$root</code> 类似，<code>$parent</code> property 可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。 </p><p>另外在一些<em>可能</em>适当的时候，需要特别地共享一些组件库。举个例子，在和 JavaScript API 进行交互而不渲染 HTML 的抽象组件内，诸如这些假设性的 Google 地图组件一样：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">google-map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">google-map-markers</span> <span class="attr">v-bind:places</span>=<span class="string">&quot;iceCreamShops&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">google-map-markers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">google-map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 <code>&lt;google-map&gt;</code> 组件可以定义一个 <code>map</code> property，所有的子组件都需要访问它。在这种情况下 <code>&lt;google-map-markers&gt;</code> 可能想要通过类似 <code>this.$parent.getMap</code> 的方式访问那个地图，以便为其添加一组标记。</p><p>请留意，尽管如此，通过这种模式构建出来的那个组件的内部仍然是容易出现问题的。比如，设想一下添加一个新的 <code>&lt;google-map-region&gt;</code> 组件，当 <code>&lt;google-map-markers&gt;</code> 在其内部出现的时候，只会渲染那个区域内的标记：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">google-map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">google-map-region</span> <span class="attr">v-bind:shape</span>=<span class="string">&quot;cityBoundaries&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">google-map-markers</span> <span class="attr">v-bind:places</span>=<span class="string">&quot;iceCreamShops&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">google-map-markers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">google-map-region</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">google-map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么在 <code>&lt;google-map-markers&gt;</code> 内部可能发现自己需要一些类似这样的 hack：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="built_in">this</span>.$parent.map || <span class="built_in">this</span>.$parent.$parent.map</span><br></pre></td></tr></table></figure><p>很快它就会失控。</p></blockquote><p><strong>针对需要向任意更深层级的组件提供上下文信息时推荐依赖注入</strong></p><h5 id="访问子组件实例或子元素"><a href="#访问子组件实例或子元素" class="headerlink" title="访问子组件实例或子元素"></a>访问子组件实例或子元素</h5><blockquote><p>为了直接访问一个子组件，为了达到这个目的，可以通过 <code>ref</code> 这个 attribute 为子组件赋予一个 ID 引用</p></blockquote><ul><li>定义</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">ref</span>=<span class="string">&quot;usernameInput&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>引用，访问<code>&lt;base_input&gt;</code>实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$refs.usernameInput</span><br><span class="line"><span class="built_in">this</span>.$refs.usernameInput.focus()</span><br></pre></td></tr></table></figure><blockquote><p>注意： </p><ul><li>当 <code>ref</code> 和 <code>v-for</code> 一起使用的时候，得到的 ref 将会是一个包含了对应数据源的这些子组件的数组</li><li> <code>$refs</code> 只会在组件<strong>渲染完成之后生效</strong>，并且它们<strong>不是响应式</strong>的。这仅作为一个用于直接操作子组件的“逃生舱”——应该避免在模板或计算属性中访问 <code>$refs</code></li></ul></blockquote><h5 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h5><p>提供了两个新的实例选项：<code>provide</code> 和 <code>inject</code>。 </p><p>举例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">google-map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">google-map-region</span> <span class="attr">v-bind:shape</span>=<span class="string">&quot;cityBoundaries&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">google-map-markers</span> <span class="attr">v-bind:places</span>=<span class="string">&quot;iceCreamShops&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">google-map-markers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">google-map-region</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">google-map</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>provide</code> 选项允许指定想要<strong>提供</strong>给后代组件的数据/方法。在这个例子中，就是 <code>&lt;google-map&gt;</code> 内部的 <code>getMap</code> 方法：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">provide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getMap: <span class="built_in">this</span>.getMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后在任何后代组件里，都可以使用 <code>inject</code> 选项来接收指定的想要添加在这个实例上的 property：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">inject: [<span class="string">&#x27;getMap&#x27;</span>]</span><br></pre></td></tr></table></figure><p>相比 <code>$parent</code> 来说，这个用法可以在<em>任意</em>后代组件中访问 <code>getMap</code>，而不需要暴露整个 <code>&lt;google-map&gt;</code> 实例。允许更好的持续研发该组件，而不需要担心可能会改变/移除一些子组件依赖的东西。同时这些组件之间的接口是始终明确定义的，就和 <code>props</code> 一样。</p><p>实际上，可以把依赖注入看作一部分“大范围有效的 prop”，除了：</p><ul><li>祖先组件不需要知道哪些后代组件使用它提供的 property</li><li>后代组件不需要知道被注入的 property 来自哪里</li></ul><blockquote><p>然而，依赖注入还是有负面影响的。它将应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的 property 是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 <code>$root</code>做这件事都是不够好的。如果想要共享的这个 property 是应用特有的，而不是通用化的，或者如果想在祖先组件中更新所提供的数据，那么这意味着可能需要换用一个像 Vuex 这样真正的状态管理方案</p></blockquote><h4 id="程序化的事件侦听器"><a href="#程序化的事件侦听器" class="headerlink" title="程序化的事件侦听器"></a>程序化的事件侦听器</h4><p>已经知道了 <code>$emit</code> 的用法，可以被 <code>v-on</code> 侦听，但是 Vue 实例同时在其事件接口中提供了其它的方法。可以：</p><ul><li><p>通过 <code>$on(eventName, eventHandler)</code> 侦听一个事件</p><blockquote><img src="/2021/01/28/Vue/vue/image-20201205202641441.png" alt="image-20201205202641441" style="zoom: 50%;"></blockquote></li><li><p>通过 <code>$once(eventName, eventHandler)</code> 一次性侦听一个事件</p><blockquote><img src="/2021/01/28/Vue/vue/image-20201205202705100.png" alt="image-20201205202705100" style="zoom:50%;"></blockquote></li><li><p>通过 <code>$off(eventName, eventHandler)</code> 停止侦听一个事件</p><blockquote><img src="/2021/01/28/Vue/vue/image-20201205202746517.png" alt="image-20201205202746517" style="zoom:50%;"></blockquote></li></ul><p>通常不会用到这些，但是当需要在一个组件实例上手动侦听事件时，它们是派得上用场的。也可以用于代码组织工具。例如，可能经常看到这种集成一个第三方库的模式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性将这个日期选择器附加到一个输入框上</span></span><br><span class="line"><span class="comment">// 它会被挂载到 DOM 上。</span></span><br><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Pikaday 是一个第三方日期选择器的库</span></span><br><span class="line">  <span class="built_in">this</span>.picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    field: <span class="built_in">this</span>.$refs.input,</span><br><span class="line">    format: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 在组件被销毁之前，</span></span><br><span class="line"><span class="comment">// 也销毁这个日期选择器。</span></span><br><span class="line">beforeDestroy: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.picker.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个潜在的问题：</p><ul><li>它需要在这个组件实例中保存这个 <code>picker</code>，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物</li><li>建立代码独立于清理代码，这使得比较难于程序化地清理建立的所有东西</li></ul><p>应该通过一个程序化的侦听器解决这两个问题：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    field: <span class="built_in">this</span>.$refs.input,</span><br><span class="line">    format: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    picker.destroy()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了这个策略，甚至可以让多个输入框元素同时使用不同的 Pikaday，每个新的实例都程序化地在后期清理它自己：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.attachDatepicker(<span class="string">&#x27;startDateInput&#x27;</span>)</span><br><span class="line">  <span class="built_in">this</span>.attachDatepicker(<span class="string">&#x27;endDateInput&#x27;</span>)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  attachDatepicker: <span class="function"><span class="keyword">function</span> (<span class="params">refName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">      field: <span class="built_in">this</span>.$refs[refName],</span><br><span class="line">      format: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      picker.destroy()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不得不在单个组件里做很多建立和清理的工作，最好的方式通常还是创建更多的模块化组件。在这个例子中，可创建一个可复用的 <code>&lt;input-datepicker&gt;</code> 组件。</p><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><h5 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h5><p>组件可以在它们自己的模板中调用自身的。不过它们只能通过 <code>name</code> 选项来做这件事：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name: <span class="string">&#x27;unique-name-of-my-component&#x27;</span></span><br></pre></td></tr></table></figure><p>当使用 <code>Vue.component</code> 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 <code>name</code> 选项。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;unique-name-of-my-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>稍有不慎，递归组件就可能导致无限循环：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name: <span class="string">&#x27;stack-overflow&#x27;</span>,</span><br><span class="line">template: <span class="string">&#x27;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>类似上述的组件将会导致“max stack size exceeded”错误，所以要确保递归调用是条件性的 (例如使用一个最终会得到 <code>false</code> 的 <code>v-if</code>)。</p><h5 id="组件之间的循环引用"><a href="#组件之间的循环引用" class="headerlink" title="组件之间的循环引用"></a>组件之间的循环引用</h5><p>假设需要构建一个文件目录树，像访达或资源管理器那样的。可能有一个 <code>&lt;tree-folder&gt;</code> 组件，模板是这样的：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tree-folder-contents</span> <span class="attr">:children</span>=<span class="string">&quot;folder.children&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有一个 <code>&lt;tree-folder-contents&gt;</code> 组件，模板是这样的：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;child in children&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tree-folder</span> <span class="attr">v-if</span>=<span class="string">&quot;child.children&quot;</span> <span class="attr">:folder</span>=<span class="string">&quot;child&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>发现这些组件在渲染树中互为对方的后代<em>和</em>祖先——一个悖论！当通过 <code>Vue.component</code> 全局注册组件的时候，这个悖论会被自动解开。然而，如果使用一个<em>模块系统</em>依赖/导入组件，例如通过 webpack 或 Browserify，会遇到一个错误：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Failed to mount component: template or render function not defined.</span><br></pre></td></tr></table></figure><p>把两个组件称为 A 和 B。模块系统发现它需要 A，但是首先 A 依赖 B，但是 B 又依赖 A，但是 A 又依赖 B，如此往复。这变成了一个循环，不知道如何不经过其中一个组件而完全解析出另一个组件。为了解决这个问题，需要给模块系统一个点，在那里“A <em>反正</em>是需要 B 的，但是不需要先解析 B。”</p><p>把 <code>&lt;tree-folder&gt;</code> 组件设为了那个点。产生悖论的子组件是 <code>&lt;tree-folder-contents&gt;</code> 组件，所以等到生命周期钩子 <code>beforeCreate</code> 时去注册它：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">&#x27;./tree-folder-contents.vue&#x27;</span>).default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，在本地注册组件的时候，可以使用 webpack 的异步 <code>import</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  TreeFolderContents: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./tree-folder-contents.vue&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板定义的替代品"><a href="#模板定义的替代品" class="headerlink" title="模板定义的替代品"></a>模板定义的替代品</h4><h5 id="内联模板"><a href="#内联模板" class="headerlink" title="内联模板"></a>内联模板</h5><p>当 <code>inline-template</code> 这个特殊的 attribute 出现在一个子组件上时，这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容。这使得模板的撰写工作更加灵活。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>These are compiled as the component&#x27;s own template.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Not parent&#x27;s transclusion content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>内联模板需要定义在 Vue 所属的 DOM 元素内。<code>inline-template</code> 会让模板的作用域变得更加难以理解。所以作为最佳实践，在组件内优先选择 <code>template</code> 选项或 <code>.vue</code> 文件里的一个 <code>&lt;template&gt;</code> 元素来定义模板。</p><h5 id="X-Template"><a href="#X-Template" class="headerlink" title="X-Template"></a>X-Template</h5><p>另一个定义模板的方式是在一个 <code> &lt;script&gt;</code> 元素中，为其带上 <code>text/x-template</code> 的类型，然后通过一个 id 将模板引用过去。例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/x-template&quot;</span> id=<span class="string">&quot;hello-world-template&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;Hello hello hello&lt;/p&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">Vue.component(<span class="string">&#x27;hello-world&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">&#x27;#hello-world-template&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>x-template 需要定义在 Vue 所属的 DOM 元素外。</p><p>这些可以用于模板特别大的 demo 或极小型的应用，但是其它情况下避免使用，因为这会将模板和该组件的其它定义分离开。</p><h4 id="控制更新"><a href="#控制更新" class="headerlink" title="控制更新"></a>控制更新</h4><blockquote><p>对于在Vue中的强制更新情况，一般是某个地方出了错，当处理后仍有问题，可以通过<code>$forceUpdate</code>来做这件事</p></blockquote><h5 id="通过v-once创建低开销的静态组件"><a href="#通过v-once创建低开销的静态组件" class="headerlink" title="通过v-once创建低开销的静态组件"></a>通过v-once创建低开销的静态组件</h5><p>渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候可能有一个组件，这个组件包含了<strong>大量</strong>静态内容。在这种情况下，可以在根元素上添加 <code>v-once</code> attribute 以确保这些内容只计算一次然后缓存起来，就像这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;terms-of-service&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div v-once&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Terms of Service&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      ... a lot of static content ...</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>不要过度使用这个模式。当需要渲染大量静态内容时，极少数的情况下这种模式会带来便利，除非非常留意渲染变慢了，不然完全是没有必要的——再加上其在后期会带来很多困惑。例如，当不熟悉 <code>v-once</code> 或漏看了它在模板中，可能会花很多个小时去找出模板为什么无法正确更新。</p></blockquote><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue&quot;&gt;&lt;a href=&quot;#vue&quot; class=&quot;headerlink&quot; title=&quot;vue&quot;&gt;&lt;/a&gt;vue&lt;/h1&gt;&lt;h2 id=&quot;vue实例&quot;&gt;&lt;a href=&quot;#vue实例&quot; class=&quot;headerlink&quot; title=&quot;vue实例&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="Vue" scheme="https://www.gtxhjh.cn/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>大数据</title>
    <link href="https://www.gtxhjh.cn/2021/01/28/BigData/bigdata/"/>
    <id>https://www.gtxhjh.cn/2021/01/28/BigData/bigdata/</id>
    <published>2021-01-28T05:46:30.000Z</published>
    <updated>2021-02-03T08:03:04.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大数据概述"><a href="#大数据概述" class="headerlink" title="大数据概述"></a>大数据概述</h1><h2 id="大数据概念和影响"><a href="#大数据概念和影响" class="headerlink" title="大数据概念和影响"></a>大数据概念和影响</h2><h3 id="大数据特点："><a href="#大数据特点：" class="headerlink" title="大数据特点："></a>大数据特点：</h3><ul><li>大量化（volume）：大数据摩尔定律</li><li>快速化（velocity）：数据处理速度快</li><li>多样化（variety）：大数据由结构化和非结构化数据组成</li><li>价值密度低（value）</li></ul><h3 id="大数据影响"><a href="#大数据影响" class="headerlink" title="大数据影响"></a>大数据影响</h3><p>四种数据范式：实验、理论、计算、数据</p><p>在思维方式方面，大数据完全颠覆了传统的思维方式：</p><p>全样而非抽样（抽取数据计算分析）众多服务器的集群出现使得不需要抽样</p><p>效率而非精确：抽样分析追求精确度是因为如果抽样精确度不高放在全样将被放大</p><p>相关而非因果：</p><h2 id="大数据关键技术"><a href="#大数据关键技术" class="headerlink" title="大数据关键技术"></a>大数据关键技术</h2><p>大数据技术层次：</p><ul><li>数据采集</li><li>数据存储与管理</li><li>数据处理与分析</li><li>数据隐私与安全</li></ul><blockquote><p>分布式存储：解决海量数据存储问题</p><p>分布式处理：解决海量数据处理问题</p></blockquote><p>不同的计算模式需要不同的产品如：</p><p>批处理：时效性要求无法满足</p><ul><li>MapReduce</li><li>Spark—时效性比mapreduce高，可以高效迭代计算，适合数据挖掘</li></ul><p>流计算：实时处理给出实时响应</p><p>图计算：高效处理图结构数据比如社交网络数据</p><p>查询分析计算：交互式查询，大数据查询分析软件</p><ul><li>Hive</li></ul><img src="images/image-20201024171750098.png" alt="image-20201024171750098" style="zoom:50%;"><h2 id="大数据与云计算、物联网"><a href="#大数据与云计算、物联网" class="headerlink" title="大数据与云计算、物联网"></a>大数据与云计算、物联网</h2><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><blockquote><p>通过网络以服务的方式为用户提供非常廉价的IT资源</p></blockquote><p>云计算解决两个核心问题：海量数据分布式存储和处理</p><p>云计算特征：虚拟化、多租户</p><ol><li>公有云：面向所有用户</li><li>混合云</li><li>私有云：面向企业内部</li></ol><p>云计算层次模型：</p><ul><li><p>基础设施层 IaaS：面向网络架构师</p><p>将基础设施作为服务出租</p></li><li><p>平台层PaaS：面向应用开发者，平台即服务</p><p>开发云计算产品，平台作为服务</p></li><li><p>应用层SaaS：面向用户，软件即服务</p><p>云财务软件</p></li></ul><h4 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h4><img src="images/image-20201024172609608.png" alt="image-20201024172609608" style="zoom:50%;"><blockquote><p>VPN</p></blockquote><h4 id="云计算数据中心"><a href="#云计算数据中心" class="headerlink" title="云计算数据中心"></a>云计算数据中心</h4><h3 id="物联网-IoT"><a href="#物联网-IoT" class="headerlink" title="物联网 IoT"></a>物联网 IoT</h3><p>物物相连互联网</p><h4 id="层次架构"><a href="#层次架构" class="headerlink" title="层次架构"></a>层次架构</h4><img src="images/image-20201024173233515.png" alt="image-20201024173233515" style="zoom:50%;"><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><img src="images/image-20201024173652900.png" alt="image-20201024173652900" style="zoom:50%;"><h1 id="大数据处理架构Hadoop"><a href="#大数据处理架构Hadoop" class="headerlink" title="大数据处理架构Hadoop"></a>大数据处理架构Hadoop</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>分布式计算平台，java语言开发，跨平台，支持多种编程语言</p></blockquote><p><strong>两大核心：HDFS（分布式存储） + MapReduce（分布式处理）</strong></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>高可靠性：多台机器构成集群，部分机器发生故障，剩余机器可以继续对外提供服务</li><li>高效性</li><li>高可扩展性</li><li>成本低：采用普通pc机构成一个集群</li></ul><p>架构：</p> <img src="images/image-20201024175515267.png" alt="image-20201024175515267" style="zoom:50%;"><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><ul><li><p>1.0：</p><p><img src="images/image-20201024175758834.png" alt="image-20201024175758834"></p><p>mapreduce:需要数据处理分析以及集群资源调度</p><p>因此2.0把任务分解，使得mapreduce只进行数据处理，由yarn来进行资源调度</p></li><li><p>2.0</p><p>HDFS在1.0可扩展性并不好，因此2.0实现多个namenode分区管理</p><p><img src="images/image-20201024175918318.png" alt="image-20201024175918318"></p></li></ul><h2 id="各组件、功能"><a href="#各组件、功能" class="headerlink" title="各组件、功能"></a>各组件、功能</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>HDFS + MapReduce</p><p><img src="images/image-20201024180808668.png" alt="image-20201024180808668"></p><blockquote><p>HDFS：分布式文件存储；YARN：计算资源调度；MapReduce：离线计算，基于磁盘；Tez：MapReduce作业进行分析优化，构建有向无环图，实现高效；Spark：通用并行框架，基于内存计算，性能优于MapReduce；Hive：数据仓库功能，用于企业决策分析，可以把sql语句转成MapReduce作业；Pig：实现流数据处理，基于大规模数据分析平台，轻量级分析；Oozie：作业流调度系统，工作流管理；zookeeper：提供分布式协调一致性服务，协同工作系统，分布式锁；HBase：列族数据库，支持随机读写，非关系型分布式数据库；Flume：日志收集分析框架；Sqoop：数据导入导出，用于在Hadoop与传统数据库之间进行数据传递；Ambari：部署工具</p></blockquote><h1 id="分布式文件系统HDFS"><a href="#分布式文件系统HDFS" class="headerlink" title="分布式文件系统HDFS"></a>分布式文件系统HDFS</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>HDFS-Hadoop Distributed File System</p><blockquote><p>大数据时代，海量数据需要集群分布式存储</p></blockquote><p><strong>集群基本架构：</strong></p><img src="images/image-20201024211057840.png" alt="image-20201024211057840" style="zoom:50%;"><blockquote><p>机架内部机器通过光纤高速交换机连接，机架与机架之间由带宽更高的光纤交换机连接</p></blockquote><p><strong>文件系统结构：</strong></p><p>文件分布式存储</p><img src="images/image-20201024211350548.png" alt="image-20201024211350548" style="zoom:50%;"><h3 id="HDFS实现目标"><a href="#HDFS实现目标" class="headerlink" title="HDFS实现目标"></a>HDFS实现目标</h3><ul><li>兼容廉价的硬件设备（需要成本低，普通的pc机）</li><li>流数据读写（传统文件系统一般块为单位，HDFS是全部数据全部读写，批量处理）</li><li>支持大数据集</li><li>支持简单的文件模型（对文件简化，牺牲相关性能，获取批量处理特性，只允许追加不允许修改）</li><li>跨平台兼容性</li></ul><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul><li>不适合低延迟数据访问（面向大规模数据流式读写，无法精确定位某个数据，不适合实时处理需求，而hbase可以）</li><li>无法高效储存大量小文件（使用元数据指引，其保存在的namenode中，内存中检索，需要建立索引结构，小文件多索引结构将变庞大从而耗时大）</li><li>不支持多用户写入及任意修改文件（只允许追加）</li></ul><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="块"><a href="#块" class="headerlink" title="块"></a>块</h4><p>为了分摊磁盘读写开销，即在大量数据间分摊磁盘寻址开销</p><p>但是HDFS的一个块比普通文件系统的块大很多，一般64MB甚至128MB</p><blockquote><p>这样可以支持面向大规模数据存储、降低分布式节点的寻址开销（三级寻址：元数据、数据节点、取数据）</p><p>缺点：块过大将导致mapreduce只有一两个任务执行，牺牲了并行度发挥不了分布式并行处理效果</p><p>好处：支持大规模文件存储；简化系统设计；适合数据备份</p></blockquote><h4 id="两大组件"><a href="#两大组件" class="headerlink" title="两大组件"></a>两大组件</h4><p>—名称节点namenode、 数据节点datanode</p><img src="images/image-20201024213142752.png" alt="image-20201024213142752" style="zoom:50%;"><p>名称节点承担整个HDFS集群的管家任务</p><p>数据节点具体负责存储实际数据，存在磁盘中，本地的linux文件系统中</p><h5 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h5><ol><li>文件是什么</li><li>文件被分成多少块</li><li>块和文件的映射关系</li><li>每个块被存储在哪个服务器上</li></ol><h5 id="名称节点"><a href="#名称节点" class="headerlink" title="名称节点"></a>名称节点</h5><h6 id="FsImage"><a href="#FsImage" class="headerlink" title="FsImage"></a>FsImage</h6><p>保存系统文件树以及文件树中所有文件数据</p><p>文件复制等级、修改和访问时间、访问权限、块大小以及组成文件的块（不记录在哪块数据节点，而是单独维护）</p><blockquote><p> 数据节点会向管家汇报保存了什么数据块，即实时沟通维护保存在内存中</p></blockquote><h6 id="EditLog"><a href="#EditLog" class="headerlink" title="EditLog"></a>EditLog</h6><p>记录对数据进行的操作，也在内存中，规模小，操作效率高</p><h6 id="如何处理"><a href="#如何处理" class="headerlink" title="如何处理"></a>如何处理</h6><img src="images/image-20201024214455169.png" alt="image-20201024214455169" style="zoom:50%;"><p>每次启动，后台将FsImage从底层磁盘读到内存，元数据信息都要保存到内存，与EditLog各项操作合并，FsImage记录历史数据结构信息，而修改由EditLog记录，合并后才能得到最新的元数据，从而得到新版的FsImage，然后创建一个空的EditLog</p><blockquote><p>因此每次更新用EditLog记录，如果直接修改FsImage将会运行很慢</p></blockquote><h6 id="第二名称节点"><a href="#第二名称节点" class="headerlink" title="第二名称节点"></a>第二名称节点</h6><p>对于不断的操作EditLog会不断增大，第二名称节点可以解决这个问题，当然它也有对名称节点冷备份的功能</p><img src="images/image-20201024214906025.png" alt="image-20201024214906025" style="zoom: 67%;"><blockquote><p>EditLog会不断增大，第二名称节点定期和名称节点通信，某个阶段让名称节点停止使用EditLog文件，将EditLog、Fsimage存入自己机器，名称节点会建立新的Edits（记录维护期间操作），第二名称节点把editlog和fsimage导入本地后合并成新的fsimage再发送给名称节点，名称节点得到合并后的大的fsimage，然后把edit.new更改为editlog，维护期间editnew记录了维护期间操作，从而实现了edit fsimage合并也实现了冷备份效果</p></blockquote><h5 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h5><p>负责具体数据存储，每个数据节点数据保存到各自本地的linux文件系统中</p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>HDFS采用主从架构</p><h3 id="HDFS命名空间管理"><a href="#HDFS命名空间管理" class="headerlink" title="HDFS命名空间管理"></a>HDFS命名空间管理</h3><p>包含目录、文件、块</p><p>访问HDFS文件系统/ + 目录名称</p><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>所有HDFS通信协议都构建在TCP/IP基础之上</p><p>客户端使用客户端协议和名称节点交互</p><p>名称节点和数据节点交互用数据节点协议</p><p>客户端和数据节点通过远程调用RPC实现</p><h3 id="局限性（1-0）"><a href="#局限性（1-0）" class="headerlink" title="局限性（1.0）"></a>局限性（1.0）</h3><ul><li>命名空间限制：名称节点保存在内存中，名称节点能够容纳对象个数受到空间大小限制</li><li>性能瓶颈：整个分布式文件吞吐量受限于单个名称节点吞吐量</li><li>隔离问题：由于集群中只有一个名称节点一个命名空间，因此无法对不同应用程序隔离</li><li>集群的可用性：一旦唯一的名称节点发生故障整个集群无法使用（第二名称节点是冷备份），单点故障（2.0解决，设置多个名称节点并且加入热备）</li></ul><h2 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h2><h3 id="冗余数据保存"><a href="#冗余数据保存" class="headerlink" title="冗余数据保存"></a>冗余数据保存</h3><p>廉价机器集群容易不断出现故障，那么需要冗余数据，每个数据以快为单位被冗余保存（默认保存3份）</p><p>伪分布时：冗余只能为1</p><p><strong>好处：</strong></p><ul><li>加快数据传输速度（因为多个客户端发起访问，可以实现并行操作）</li><li>容易检查数据错误（互为备份做参照）</li><li>保证数据可靠性</li></ul><h3 id="数据保存策略"><a href="#数据保存策略" class="headerlink" title="数据保存策略"></a>数据保存策略</h3><img src="images/image-20201024230045366.png" alt="image-20201024230045366" style="zoom:50%;"><blockquote><p>每个节点都是廉价机器</p><p><strong>存储</strong>，多份副本的放置：</p><ol><li><p>第一份放上传文件的数据节点（不需要通过网络）</p><p>如果提交数据的请求不在集群内部，则随机挑选磁盘不满CPU不忙节点</p></li><li><p>第二份放与第一份所在机架不同的节点上</p></li><li><p>第三份放与第一份所在机架相同机架的不同节点上</p></li><li><p>后续多份随机</p></li></ol><p><strong>读取</strong>，<em>就近</em>读取，网络开销小</p><p>确定就近：</p><img src="images/image-20201024230608275.png" alt="image-20201024230608275" style="zoom:50%;"><p>当客户端读取数据，从名称节点获得数据块不同副本的存放位置列表，列表中包含了副本所在数据节点，调用API确定节点所属机架ID，当发现数据块副本对应机架ID和客户端对应机架ID相同就优先选择该副本读取数据，否则随机选择</p></blockquote><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><h4 id="名称节点的出错"><a href="#名称节点的出错" class="headerlink" title="名称节点的出错"></a>名称节点的出错</h4><p>名称节点会做冷备份，当出错时，整个HDFS实例将失效，出了问题将会暂停服务一段时间，从第二名称节点做恢复，恢复后再开始服务(1.0，2.0马上热备)</p><h4 id="数据节点的出错"><a href="#数据节点的出错" class="headerlink" title="数据节点的出错"></a>数据节点的出错</h4><p>数据节点具体负责存储相关数据，那么<strong>如何知道出错</strong>：因为数据节点会定期（远程调用）对名称节点发送**<em>心跳信息**</em>示意自己的状态（收不到则发生故障）。</p><p><strong>处理</strong>：当发生故障名称节点对其标记宕机，把存储在故障机上数据重新分发到可用机上，因为之前冗余备份过，所以可以实现重新分发（可以调整冗余数据位置，当负载不均衡时也可以调整）</p><h4 id="数据本身的出错"><a href="#数据本身的出错" class="headerlink" title="数据本身的出错"></a>数据本身的出错</h4><p>数据块存储到不同服务器上会出现磁盘损坏的情况，导致数据错误</p><p><strong>如何知道</strong>：使用校验码，客户端读取数据后对数据进行校验码校验，校验码是在文件被创建时客户端写文件时为数据块分配的，读出数据后进行校验码计算，从而进行比较</p><p>出错后进行冗余数据的恢复</p><h2 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h2><h3 id="读过程"><a href="#读过程" class="headerlink" title="读过程"></a>读过程</h3><ul><li>打开文件</li></ul><img src="images/image-20201024233012593.png" alt="image-20201024233012593" style="zoom:50%;"><ul><li>获取数据块信息</li></ul><img src="images/image-20201024233153701.png" alt="image-20201024233153701" style="zoom:50%;"><blockquote><p>DFSInputStream询问名称节点，通过接口，名称节点返回信息</p></blockquote><ul><li>读取请求</li></ul><p>read函数读取，读后关闭与数据节点的连接</p><ul><li>获取数据块信息(可能发生)</li></ul><p>数据节点读后可能有剩余数据没有读完，因此可能还需要获取下一个数据的存储信息</p><img src="images/image-20201024233441535.png" alt="image-20201024233441535" style="zoom:50%;"><ul><li><p>再次读取数据</p></li><li><p>关闭文件</p></li></ul><p>循环读完后close关闭</p><h3 id="写过程"><a href="#写过程" class="headerlink" title="写过程"></a>写过程</h3><img src="images/image-20201024233734809.png" alt="image-20201024233734809" style="zoom:50%;"><ul><li><p>创建文件请求</p><p>DFSOutputStream与名称节点交流</p></li><li><p>创建文件元数据</p><p>询问名称节点文件写在什么数据节点</p><p>DFSOutputStream执行RPC远程调用，让名称节点在文件系统命名空间新建文件，名称节点检查文件是否存在以及权限检查，然后创建文件</p></li><li><p>写入数据、写入数据包</p><p>通过输出流，高效的方式是流水线复制：把数据分包，分包放入输出流的内部队列，放入后输出流会向名称节点申请数据节点。<strong>数据节点构成数据流管道</strong>，内部队列的分包会打包为数据包发送到整个数据流管道第一个节点，由第一个节点发给下一个节点，以此类推，形成流水线</p><p><img src="images/image-20201024234401842.png" alt="image-20201024234401842"></p></li><li><p>接受确认包</p><p>由最后一个数据节点开始往前传</p><p><img src="images/image-20201024234428900.png" alt="image-20201024234428900"></p></li><li><p>关闭文件、写操作完成</p></li></ul><h2 id="HDFS常用命令"><a href="#HDFS常用命令" class="headerlink" title="HDFS常用命令"></a>HDFS常用命令</h2><p>启动: ./sbin/start-dfs.sh</p><p>hadoop dfs / hadoop fd / ./bin/hdfs dfs </p><p>停止:./sbin/stop-dfs.sh</p><ul><li>fs支持命令</li></ul><img src="images/image-20201025121543860.png" alt="image-20201025121543860" style="zoom:50%;"><ul><li><p>首次使用HDFS，创建用户目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/hdfs dfs -mkdir -p /user/hadoop</span></span><br></pre></td></tr></table></figure><blockquote><p>该命令表示中HDFS中创建一个目录，“-p”表示如果是多级目录，则父目录和子目录一起创建，这里“/user/hadoop”就是一个多级目录，因此必须使用参数“-p”，否则会出错</p></blockquote></li><li><p>创建、删除都和linux命令差不多，需要注意的是地址，如果是”.”表示的是上面创建的目录，如果是“/”表示HDFS根目录</p></li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>从本地文件系统向HDFS中上传文件，或者把HDFS中的文件下载到本地文件系统</p><ul><li><p>将本地文件上传到HDFS指定目录-put</p><img src="images/image-20201025123017558.png" alt="image-20201025123017558" style="zoom:50%;"></li><li><p>将HDFS文件下载到本地-get</p><img src="images/image-20201025123241340.png" alt="image-20201025123241340" style="zoom:50%;"></li><li><p>对于把HDFS目录下一个文件拷贝到另一个目录，操作与linux查不多，加入前缀hadoop -dfs即可</p></li></ul><h3 id="利用Web界面管理HDFS"><a href="#利用Web界面管理HDFS" class="headerlink" title="利用Web界面管理HDFS"></a>利用Web界面管理HDFS</h3><blockquote><p><a href="http://localhost:9870/dfshealth.html#tab-overview">http://localhost:9870/dfshealth.html#tab-overview</a></p></blockquote><h2 id="HDFS常用JAVA-API"><a href="#HDFS常用JAVA-API" class="headerlink" title="HDFS常用JAVA API"></a>HDFS常用JAVA API</h2><p>Hadoop API文档</p><p><a href="http://hadoop.apache.org/docs/stable/api/">http://hadoop.apache.org/docs/stable/api/</a></p><h3 id="应用程序的部署"><a href="#应用程序的部署" class="headerlink" title="应用程序的部署"></a>应用程序的部署</h3><p>把Java应用程序生成JAR包，部署到Hadoop平台上运行</p><p>export -&gt; java -&gt; runnable jar file</p><ul><li>launch configuration:生成jar包被部署启动时运行的主类</li><li>export destination:jar包输出目录</li></ul><p><img src="images/image-20201025184313219.png" alt="image-20201025184313219"></p><p><strong>执行：</strong></p><p>使用hadoop jar运行程序</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;  </span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FSDataOutputStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">write</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                Configuration conf = <span class="keyword">new</span> Configuration();  </span><br><span class="line">                conf.set(<span class="string">&quot;fs.defaultFS&quot;</span>,<span class="string">&quot;hdfs://localhost:9000&quot;</span>);</span><br><span class="line">                conf.set(<span class="string">&quot;fs.hdfs.impl&quot;</span>,<span class="string">&quot;org.apache.hadoop.hdfs.DistributedFileSystem&quot;</span>);</span><br><span class="line">                FileSystem fs = FileSystem.get(conf);</span><br><span class="line">                <span class="keyword">byte</span>[] buff = <span class="string">&quot;Hello world&quot;</span>.getBytes(); <span class="comment">// 要写入的内容</span></span><br><span class="line">                String filename = <span class="string">&quot;test&quot;</span>; <span class="comment">//要写入的文件名</span></span><br><span class="line">                FSDataOutputStream os = fs.create(<span class="keyword">new</span> Path(filename));</span><br><span class="line">                os.write(buff,<span class="number">0</span>,buff.length);</span><br><span class="line">                System.out.println(<span class="string">&quot;Create:&quot;</span>+ filename);</span><br><span class="line">                os.close();</span><br><span class="line">                fs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>result:</p><img src="images/image-20201025185627646.png" alt="image-20201025185627646" style="zoom:50%;"><h4 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">isexistthefile</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                String filename = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">                Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">                conf.set(<span class="string">&quot;fs.defaultFS&quot;</span>,<span class="string">&quot;hdfs://localhost:9000&quot;</span>);</span><br><span class="line">                conf.set(<span class="string">&quot;fs.hdfs.impl&quot;</span>,<span class="string">&quot;org.apache.hadoop.hdfs.DistributedFileSystem&quot;</span>);</span><br><span class="line">                FileSystem fs = FileSystem.get(conf);</span><br><span class="line">                <span class="keyword">if</span>(fs.exists(<span class="keyword">new</span> Path(filename)))&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;文件存在&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                fs.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FSDataInputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">read</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">                conf.set(<span class="string">&quot;fs.defaultFS&quot;</span>,<span class="string">&quot;hdfs://localhost:9000&quot;</span>);</span><br><span class="line">                conf.set(<span class="string">&quot;fs.hdfs.impl&quot;</span>,<span class="string">&quot;org.apache.hadoop.hdfs.DistributedFileSystem&quot;</span>);</span><br><span class="line">                FileSystem fs = FileSystem.get(conf);</span><br><span class="line">                Path file = <span class="keyword">new</span> Path(<span class="string">&quot;test&quot;</span>); </span><br><span class="line">                FSDataInputStream getIt = fs.open(file);</span><br><span class="line">                BufferedReader d = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(getIt));</span><br><span class="line">                String content = d.readLine(); <span class="comment">//读取文件一行</span></span><br><span class="line">                System.out.println(content);</span><br><span class="line">                d.close(); <span class="comment">//关闭文件</span></span><br><span class="line">                fs.close(); <span class="comment">//关闭hdfs</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>result:</p><img src="images/image-20201025190008986.png" alt="image-20201025190008986" style="zoom:50%;"><h1 id="分布式数据库HBase"><a href="#分布式数据库HBase" class="headerlink" title="分布式数据库HBase"></a>分布式数据库HBase</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>分布式存储系统支持PB级别数据，可以存储几千台服务器具有高可扩展性</p><p><strong>特点：</strong>：高可靠性、高性能、面向列、可伸缩</p><p>HBase分布式数据库可以用来存储非结构化和半结构化松散数据</p><p>HBase和BigTable的底层技术对应关系：</p><p><img src="images/image-20201025203821941.png" alt="image-20201025203821941"></p><blockquote><p>HBase架构在底层分布式文件系统HDFS之上，是BigTable 的开源实现</p></blockquote><p>HBase：虽然有了HDFS和MapReduce，但是Hadoop主要解决大规模数据离线批量处理，没有办法满足大数据实时处理需求。而随着数据规模爆炸式增长，传统关系型数据库扩展能力非常有限，另外很多数据的结构会变化，而传统关系型数据库模式很难变化。</p><h3 id="HBase和传统关系型数据库的联系和区别"><a href="#HBase和传统关系型数据库的联系和区别" class="headerlink" title="HBase和传统关系型数据库的联系和区别"></a>HBase和传统关系型数据库的联系和区别</h3><ul><li><p>数据类型</p><p>传统关系数据库用非常经典的关系数据模型</p><p>hbase数据模型简单，将数据存储为未经解释的字符串即字节数组，由应用程序开发人员来解释</p></li><li><p>数据操作</p><p>关系数据库多种操作而hbase操作简单，不对数据规范化</p></li><li><p>存储模式</p><p>hbase基于列存储</p></li><li><p>数据索引</p><p>关系数据库可以直接针对各个不同列构建复杂索引</p><p>hbase原始设计只支持对行键的简单索引</p></li><li><p>数据维护</p><p>关系数据库做一些更新操作时，旧值被覆盖</p><p>hbase不存在替换，旧版本会保存只会定期清理</p></li><li><p>可伸缩型</p><p>关系数据库很难水平扩展，只能变多核等方式纵向扩展，而hbase是借助分布式集群存储海量数据，水平可扩展性好</p></li></ul><h3 id="HBase访问接口"><a href="#HBase访问接口" class="headerlink" title="HBase访问接口"></a>HBase访问接口</h3><ul><li>提供了一个原生JAVA API</li><li>Shell</li><li>Thrift Gateway</li><li>REST Gateway</li><li>提供sql类型接口 </li><li>pig</li><li>数据仓库产品hive（hive sql）</li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>HBase是一个稀疏的多维度的排序的映射表</p><img src="images/image-20201025205309295.png" alt="image-20201025205309295" style="zoom: 67%;"><ul><li><p>每个值都是未经解释的字符串也就是Bytes数组,单元格具体存储数据</p></li><li><p>一行可以有一个行键和任意多个列族，以列族为单位存储，不同列族存在不同文件,列可以增加或删除</p></li><li><p>列族支持动态扩展，执行数据更新操作会保留旧版本，因为架构在HDFS上，没有办法直接修改数据，只能加入时间戳</p><blockquote><p>时间戳：数据更新，旧版本会保留，新版本通过时间戳来进行区分，因此一个单元格可能有非常多版本数据保存按时间戳</p></blockquote></li><li><p>HBase不考虑冗余，追求分析效率</p></li></ul><h3 id="数据坐标"><a href="#数据坐标" class="headerlink" title="数据坐标"></a>数据坐标</h3><p>传统关系数据库只要通过一个行一个列两个维度就可以确定一个唯一数据</p><p>而HBase(键值数据库)对数据的定位采用四维坐标:<strong><code>行键 列族 列限定符 时间戳</code></strong></p><h3 id="概念视图"><a href="#概念视图" class="headerlink" title="概念视图"></a>概念视图</h3><p><img src="images/image-20201025211904093.png" alt="image-20201025211904093"></p><p>可以看出hbase是一个稀疏表</p><p><strong>但是底层存储是按列族存储</strong></p><h3 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h3><p><img src="images/image-20201025212018349.png" alt="image-20201025212018349"></p><blockquote><p>按列族存储</p></blockquote><p>传统的面向行存储是对于传统的<strong>事务型</strong>操作,但是做<strong>分析</strong>时候,比如性别特征,针对一个列分析,此时列式存储占据优势,并且按列存储可以带来很高的数据压缩率.</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="功能组件"><a href="#功能组件" class="headerlink" title="功能组件"></a>功能组件</h3><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><p>链接每个客户端</p><h4 id="master服务器"><a href="#master服务器" class="headerlink" title="master服务器"></a>master服务器</h4><p>管家</p><ul><li>对分区信息维护和管理</li><li>维护一个Region服务器列表,可以查看region服务器状态</li><li>负责对region分配</li><li>负载均衡</li></ul><h4 id="region服务器"><a href="#region服务器" class="headerlink" title="region服务器"></a>region服务器</h4><p>负责存储不同的region</p><p>客户端要访问数据也是在region对数据存取,不依赖master获取位置信息</p><h3 id="核心概念表与Region"><a href="#核心概念表与Region" class="headerlink" title="核心概念表与Region"></a>核心概念表与Region</h3><p>一个HBase表被划分为多个Region</p><p>一个region会分裂成多个新的region,分裂时不进行物理分割,修改指向信息即可,实现快速分裂.同一个region不可能分裂到不同的region服务器上</p><p><img src="images/image-20201025213240407.png" alt="image-20201025213240407"></p><blockquote><p>region的实际大小取决于单台服务器的有效处理能力,最佳配置为1GB-2G</p><p>每一个region服务器大概存储10-1000个region</p></blockquote><h3 id="Region定位"><a href="#Region定位" class="headerlink" title="Region定位"></a>Region定位</h3><blockquote><p>首先构建了一个元数据表,一列记录region id 另一列记录region服务器id</p><p>hbase最开始创建时有一个映射表,称为.META. 表,用于存储元数据</p></blockquote><p>HBase设计三层结构实现region寻址与定位</p><p><img src="images/image-20201025214125767.png" alt="image-20201025214125767"></p><blockquote><p>-ROOT-最多一个region不再分裂,记录元数据表元素信息存储在哪,.META.记录具体数据位置</p><p>实际存储时-ROOT-表地址记录在ZooKeeper中(写死),然后根据地址找到.META.,然后找到用户数据表</p><img src="images/image-20201025214326971.png" alt="image-20201025214326971" style="zoom:50%;"><p>.META.所有内容存储在内存中,因此需要考虑大小</p></blockquote><p>另外,为了加速寻址,客户端会缓存位置信息,同时需要解决缓存失效问题,采用惰性解决方式,只有发现找不到时才再次三级寻址</p><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><img src="images/image-20201025215128209.png" alt="image-20201025215128209"></p><p>HBase并不直接和底层磁盘联系</p><blockquote><ul><li><p>客户端:访问HBase接口,会维护访问region的信息</p></li><li><p>zookeeper:实现协同管理服务,大量用于分布式计算,提供配置维护,域名服务,分布式同步服务,维护整个hbase集群</p></li><li><p>master(主服务器):负责hbase表的操作以及region管理,负责不同region服务器的负载均衡,负责调整分裂\合并后region的分布,负责重新分配故障\失效的region服务器</p></li><li><p>region服务器:负责用户数据存储和管理</p><img src="images/image-20201025221348611.png" alt="image-20201025221348611" style="zoom:50%;"><p>每个region服务器有很多region,多个region共用一个Hlog文件,每个region按列族切分,每个列族会单独构成一个store,而每个store并不直接与底层连接,而是先写入memstore缓存中,缓存满后刷写到storefile(底层是通过hdfs存储(hfile格式))中</p></li></ul></blockquote><h3 id="Region服务器工作原理"><a href="#Region服务器工作原理" class="headerlink" title="Region服务器工作原理"></a>Region服务器工作原理</h3><h4 id="用户读写数据过程"><a href="#用户读写数据过程" class="headerlink" title="用户读写数据过程"></a>用户读写数据过程</h4><p>写:</p><p><img src="images/image-20201025222546421.png" alt="image-20201025222546421"></p><p>读:</p><p>先读缓存再读磁盘的storefile</p><p><img src="images/image-20201025222629090.png" alt="image-20201025222629090"></p><h4 id="缓存刷新"><a href="#缓存刷新" class="headerlink" title="缓存刷新"></a>缓存刷新</h4><p><img src="images/image-20201025225103257.png" alt="image-20201025225103257"></p><h3 id="Store工作原理"><a href="#Store工作原理" class="headerlink" title="Store工作原理"></a>Store工作原理</h3><h4 id="StoreFile合并"><a href="#StoreFile合并" class="headerlink" title="StoreFile合并"></a>StoreFile合并</h4><p>当磁盘中刷写生成的storefile达到一定阈值才会合并,但是合并到一定程度后会触发分裂,一个region分裂为两个region</p><p><img src="images/image-20201025225419043.png" alt="image-20201025225419043"></p><h3 id="HLog工作原理"><a href="#HLog工作原理" class="headerlink" title="HLog工作原理"></a>HLog工作原理</h3><p>HBase是构建一个集群管理数据,典型的分布式环境,底层使用的是非常廉价的低端机,故障是难免的,为了保证数据恢复需要采用日志方式,因此每次需要写入日志后再写入缓存</p><p><img src="images/image-20201025225721964.png" alt="image-20201025225721964"></p><h3 id="zookeper"><a href="#zookeper" class="headerlink" title="zookeper"></a>zookeper</h3><p>zookeeper监视整个集群.发现故障,监听region服务器,发现故障告诉master,master进行处理,通过日志进行恢复,对hlog拆解,把属于各个region的log分配出来,把发生故障的region分配给可用的region服务器通过log恢复.<strong>为了提高表的写操作性能</strong>所以才只分配一个hlog.所以拆解比较耗时,故障只是少部分情况.</p><h2 id="HBase应用方案"><a href="#HBase应用方案" class="headerlink" title="HBase应用方案"></a>HBase应用方案</h2><h3 id="性能优化方法"><a href="#性能优化方法" class="headerlink" title="性能优化方法"></a>性能优化方法</h3><ul><li><p>时间靠近数据存在一起:把时间戳包含在行键中,按升序排序,越后时间戳越大,因此需要反过来排序</p><p><img src="images/image-20201025232622511.png" alt="image-20201025232622511"></p></li><li><p>提升读写性能</p><p>根据需要决定是否放入缓存</p><p><img src="images/image-20201025232748493.png" alt="image-20201025232748493"></p></li><li><p>设置最大版本,保存最新版本的数据参数设为1,节省存储空间</p><p>HColumnDescriptor.setMaxVersionsMaxVersions</p></li><li><p>数据自动清理</p><p>TimeToLive,一旦超过生命周期成为过期数据自动被系统删除</p><p>setTimeToLive(2 * 24 * 60 * 60)</p></li></ul><h3 id="检测性能"><a href="#检测性能" class="headerlink" title="检测性能"></a>检测性能</h3><p>工具:</p><ul><li>Master-status:浏览器查询hbase运行状态</li><li>ganglia</li><li>opentsdb</li><li>ambari</li></ul><h3 id="构建sql引擎和HBase二级索引"><a href="#构建sql引擎和HBase二级索引" class="headerlink" title="构建sql引擎和HBase二级索引"></a>构建sql引擎和HBase二级索引</h3><h4 id="sql引擎"><a href="#sql引擎" class="headerlink" title="sql引擎"></a>sql引擎</h4><p>sql语句查询hbase相关数据</p><p>引擎:hive  phoneix</p><h4 id="HBase二级索引-辅助索引"><a href="#HBase二级索引-辅助索引" class="headerlink" title="HBase二级索引(辅助索引)"></a>HBase二级索引(辅助索引)</h4><blockquote><p>hbase默认只支持对行键进行索引.而实际应用要对不同列构建索引,因此可以采用coprocessor,如华为的hindex以及redis和solr</p></blockquote><p>coprocessor提供了两个实现endpoint和observer</p><ul><li>endpoint:相当于关系型数据库的存储过程</li><li>observer:相当于触发器</li></ul><blockquote><p>从而hbase可以有主表和索引表,(引擎构建在hbase之上,既没有对hbase进行任何改动,也不需要上层应用做任何妥协)但是缺点是耗时</p></blockquote><h2 id="HBase-数据库"><a href="#HBase-数据库" class="headerlink" title="HBase 数据库"></a>HBase 数据库</h2><p>启动:./bin/start-hbase.sh</p><p>shell:hbase shell  ./bin/hbase shell</p><p>停止:./bin/stop-hbase.sh</p><p>在添加数据时，HBase会自动为添加的数据添加一个时间戳，故在需要修改数据时，只需直接添加数据，HBase即会生成一个新的版本，从而完成“改”操作，旧的版本依旧保留，系统会定时回收垃圾数据，只留下最新的几个版本，保存的版本数可以在创建表的时候指定</p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create &#x27;student&#x27;,&#x27;Sname&#x27;,&#x27;Ssex&#x27;,&#x27;Sage&#x27;,&#x27;Sdept&#x27;,&#x27;course&#x27;</span><br></pre></td></tr></table></figure><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">put &#x27;student&#x27;,&#x27;95001&#x27;,&#x27;Sname&#x27;,&#x27;LiYing&#x27; # 95001行键</span><br><span class="line">put &#x27;student&#x27;,&#x27;95001&#x27;,&#x27;course:math&#x27;,&#x27;80&#x27; # course列族加入了math列</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">delete &#x27;student&#x27;,&#x27;95001&#x27;,&#x27;Ssex&#x27;</span><br><span class="line">deleteall &#x27;student&#x27;,&#x27;95001&#x27;  </span><br></pre></td></tr></table></figure><h3 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">get &#x27;student&#x27;,&#x27;95001&#x27;</span><br></pre></td></tr></table></figure><p><img src="images/image-20201026103328324.png" alt="image-20201026103328324"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;student&#x27;</span><br></pre></td></tr></table></figure><p><img src="images/image-20201026103408520.png" alt="image-20201026103408520"></p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><blockquote><p>disable 表</p><p>drop 表</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">disable &#x27;student&#x27;  </span><br><span class="line">drop &#x27;student&#x27;</span><br></pre></td></tr></table></figure><h3 id="查询表历史数据"><a href="#查询表历史数据" class="headerlink" title="查询表历史数据"></a>查询表历史数据</h3><h4 id="查询历史版本"><a href="#查询历史版本" class="headerlink" title="查询历史版本"></a>查询历史版本</h4><ol><li><p>创建表的时候，指定保存的版本数（假设指定为5）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create &#x27;teacher&#x27;,&#123;NAME=&gt;&#x27;username&#x27;,VERSIONS=&gt;5&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入数据然后更新数据，使其产生历史版本数据</p></li><li><p>查询时，指定查询的历史版本数。默认会查询出最新的数据</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">get &#x27;teacher&#x27;,&#x27;91001&#x27;,&#123;COLUMN=&gt;&#x27;username&#x27;,VERSIONS=&gt;5&#125;</span><br></pre></td></tr></table></figure><p><img src="images/image-20201026103950179.png" alt="image-20201026103950179"></p><p><img src="images/image-20201026104008006.png" alt="image-20201026104008006"></p></li></ol><p>退出HBase数据库是退出对数据库表的操作: exit</p><h2 id="HBase-JAVA-API"><a href="#HBase-JAVA-API" class="headerlink" title="HBase JAVA API"></a>HBase JAVA API</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleForHBase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Configuration configuration;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Admin admin;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        init();<span class="comment">//设置连接,配置</span></span><br><span class="line">        createTable(<span class="string">&quot;student&quot;</span>,<span class="keyword">new</span> String[]&#123;<span class="string">&quot;score&quot;</span>&#125;);</span><br><span class="line">        insertData(<span class="string">&quot;student&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;score&quot;</span>,<span class="string">&quot;English&quot;</span>,<span class="string">&quot;69&quot;</span>);</span><br><span class="line">        insertData(<span class="string">&quot;student&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;score&quot;</span>,<span class="string">&quot;Math&quot;</span>,<span class="string">&quot;86&quot;</span>);</span><br><span class="line">        insertData(<span class="string">&quot;student&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;score&quot;</span>,<span class="string">&quot;Computer&quot;</span>,<span class="string">&quot;77&quot;</span>);</span><br><span class="line">        getData(<span class="string">&quot;student&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;score&quot;</span>,<span class="string">&quot;English&quot;</span>);</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        configuration  = HBaseConfiguration.create(); <span class="comment">// 配置对象</span></span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.rootdir&quot;</span>,<span class="string">&quot;hdfs://localhost:9000/hbase&quot;</span>); <span class="comment">//设置参数</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            connection = ConnectionFactory.createConnection(configuration); <span class="comment">//连接对象</span></span><br><span class="line">            admin = connection.getAdmin();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123; <span class="comment">//关闭数据连接</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(admin != <span class="keyword">null</span>)&#123;</span><br><span class="line">                admin.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != connection)&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTable</span><span class="params">(String myTableName,String[] colFamily)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        TableName tableName = TableName.valueOf(myTableName); <span class="comment">//生成tablename对象</span></span><br><span class="line">        <span class="keyword">if</span>(admin.tableExists(tableName))&#123;<span class="comment">//判断是否存在表</span></span><br><span class="line">            System.out.println(<span class="string">&quot;talbe is exists!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            TableDescriptorBuilder tableDescriptor = TableDescriptorBuilder.newBuilder(tableName);</span><br><span class="line">            <span class="keyword">for</span>(String str:colFamily)&#123; <span class="comment">//创建列族</span></span><br><span class="line">                ColumnFamilyDescriptor family = </span><br><span class="line">ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(str)).build();</span><br><span class="line">                tableDescriptor.setColumnFamily(family);</span><br><span class="line">            &#125;</span><br><span class="line">            admin.createTable(tableDescriptor.build());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertData</span><span class="params">(String tableName,String rowKey,String colFamily,String col,String val)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Put put = <span class="keyword">new</span> Put(rowKey.getBytes()); <span class="comment">//单元格对象</span></span><br><span class="line">        put.addColumn(colFamily.getBytes(),col.getBytes(), val.getBytes()); <span class="comment">//确定列族等</span></span><br><span class="line">        table.put(put);</span><br><span class="line">        table.close(); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(String tableName,String rowKey,String colFamily, String col)</span><span class="keyword">throws</span>  IOException</span>&#123; </span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Get get = <span class="keyword">new</span> Get(rowKey.getBytes());</span><br><span class="line">        get.addColumn(colFamily.getBytes(),col.getBytes());</span><br><span class="line">        Result result = table.get(get);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(result.getValue(colFamily.getBytes(),col==<span class="keyword">null</span>?<span class="keyword">null</span>:col.getBytes())));</span><br><span class="line">        table.close(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>Not Only SQL</p><p>灵活的可扩展性：水平可扩展</p><p>灵活的数据模型：无模式，不那么严格</p><p>和云计算的紧密结合：水平可扩展，充分利用云计算基础设备。可以根据负载实时变化，动态伸缩</p><ul><li>传统的关系数据库性能上没有办法满足海量数据的管理需求；没有办法满足高并发需求，网页访问数据库，当多个用户访问性能很差，早期使用动态网页静态化技术，提前把动态网页保留成静态模式，外部访问静态网页而不需要访问数据库，但是应用需要实时生成数据，无法满足，这种实时生成的数据对数据库的负载非常高；无法满足高可扩展性和高可用性的需求，突发的负载高峰期无法应对。</li><li>MySQL集群方式的缺陷：复杂性，整个集群部署管理配置都非常复杂；延迟性，异步方式，主库压力大时会有较大延迟；扩容问题，整个集群压力过大时，需要增加新机器对整个数据集进行重新分区，非常复杂；动态迁移问题，数据集划分人工划分，没有办法有效预测集群未来负载分布情况，因此需要负载再均衡，迁移相关数据，需要总控节点，且需要人工实现。</li></ul><p>关系型数据库无法适应不同的业务场景，对于海量数据批量处理强调的是高吞吐量，因此有了hadoop、mongoDB、redis。如Web2.0通常不要求严格数据库事务，使用事务会有额外开销；不需要严格的读写实时性；不包含复杂的SQL查询</p><h3 id="与关系数据库比较"><a href="#与关系数据库比较" class="headerlink" title="与关系数据库比较"></a>与关系数据库比较</h3><ul><li>在数据库原理方面，关系数据库具有完备的关系代数理论作为基础；NoSQL数据库缺乏理论基础</li><li>数据规模方面：关系数据库很难实现横向扩展，纵向扩展有限，NoSQL水平可扩展性强</li><li>在数据库模式方面，关系数据库要定义严格的数据库模式，而且要严格遵守事先定义的数据库模式。NoSQL数据模型较灵活</li><li>在查询效率方面：关系数据库适当数据查询效率高，数据量级增大效率变低，NoSQL较关系型数据库性能低</li><li>事务一致性：关系数据库遵循ACID事务模型保证事务强一致性；NoSQL放松了该性能，而保证base要求</li><li>数据完整性：关系数据库具有保证完整性的完备机制；NoSQL不能实现完整性约束</li><li>在可扩展性，NoSQL水平可扩展性好</li><li>在可用性，关系数据库为了保证严格一致性可用性被削弱，NoSQL具有非常好可用性，短时间迅速返回结果</li><li>在标准化，关系数据库遵循SQL标准标准化完善，NoSQL数据库未形成通用的行业标准</li><li>技术支持方面，关系数据库很多为商业数据库可以有非常强大技术和服务支持；NoSQL数据库多属于开源产品，处于发展初步阶段</li><li>在可维护方面，关系数据库需要管理员维护，NoSQL数据库没有成熟的基础和实践操作规范，维护较为复杂</li></ul><p>关系数据库的优势就是完备的关系代数理论、严格的标准、事务一致性、可以借助索引机制实现非常高效的查询。劣势是可扩展性差、数据模型定义严格，无法较好满足新型Web2.0。应用于电信银行的关键业务系统。</p><p>NoSQL的优势可以支持超大规模数据存储，数据模型灵活。劣势是缺乏底层基础理论支撑，不支持事务一致性，影响在关键业务系统的应用。应用于互联网企业以及一些传统企业的非关键业务。</p><h3 id="四大类型、三大基石"><a href="#四大类型、三大基石" class="headerlink" title="四大类型、三大基石"></a>四大类型、三大基石</h3><h4 id="四大类型"><a href="#四大类型" class="headerlink" title="四大类型"></a>四大类型</h4><p>键值数据库、列族数据库、文档数据库（可看作键值，只不过文档是值）、图数据库（图结构）</p><ul><li><p>键值数据库如Redis Memcached  SimpleDB</p><ul><li><p>数据模型：键是一个字符串对象（因此也无法存储结构化信息、条件查询效率低）</p></li><li><p>应用：涉及频繁读写，拥有简单数据模型的应用，内容缓存，如会话、配置文件、参数、购物车等，存储配置和用户数据信息等移动应用</p></li><li><p>一般不支持回滚</p></li><li><p>成为理想的缓冲层解决方案</p></li></ul></li><li><p>列族数据库如BigTable、HBase、Cassandra</p><ul><li><p>数据模型：列族</p></li><li><p>应用：分布式数据存储与管理。数据在地理上分布于多个数据中心的应用程序；可以容忍副本中存在短期不一致情况的应用程序；拥有动态字段的应用程序</p></li><li><p>大都不支持事务一致性（因此需要ACID事务支持的就不能用）</p></li></ul></li><li><p>文档数据库，如MongoDB CouchDB</p><ul><li>value是文档的键值数据库，能够将自己的数据内容和类型进行自我描述</li><li>数据结构：JSON数据格式</li><li>并发性高，文档数据库可以完整包含在一个文档里，有较好的并发性。对数据更新时，只需锁定一个文档既可以把相关数据修改</li><li>应用：存储、索引并管理面向文档数据；或者类似的半结构化数据</li><li>文档数据库不支持文档间事务</li></ul></li><li><p>图数据库 如Neo4j</p><ul><li>数据模型：图结构</li><li>应用：处理具有高度相互关联关系的数据，较适合于社交网络、模式识别、依赖分析、推荐系统以及路径寻找等问题</li></ul></li></ul><h4 id="三大基石"><a href="#三大基石" class="headerlink" title="三大基石"></a>三大基石</h4><h5 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h5><ul><li><p>Consistency：一致性，任何一个操作总能读到之前完成的写操作的结果</p></li><li><p>Availablity：可用性，快速获取数据，可以在确定的时间内返回操作结果，保证每个请求不管成功或者失败都有响应</p></li><li><p>Partition tolerance：分区容忍性，当出现网络分区的情况时，分离的系统也能够正常运行</p></li></ul><p>一个分布式系统不能同时满足CAP只能牺牲一个</p><img src="images/image-20201105112739921.png" alt="image-20201105112739921" style="zoom:50%;"><p><img src="images/image-20201105112815458.png" alt="image-20201105112815458"></p><h5 id="BASE-Basically-Avaible-Soft-state、Eventual-consistency"><a href="#BASE-Basically-Avaible-Soft-state、Eventual-consistency" class="headerlink" title="BASE-Basically Avaible Soft state、Eventual consistency"></a>BASE-Basically Avaible Soft state、Eventual consistency</h5><blockquote><p>ACID是关系数据库事务的四性质，NoSQL中BASE是对应关系</p></blockquote><ul><li><p>基本可用：允许分区失败出现，一个分布式系统的一部分发生问题变得不可用时其他部分仍然可以正常使用</p></li><li><p>软状态：状态可以有一段时间不同步，具有一定滞后性（硬状态：数据库状态必须一直保持数据库一致性，任意时刻数据必须正确）</p></li><li><p>最终一致性：一致性的类型包括强一致性和弱一致性，二者主要区别在于高并发的数据访问操作下，后续操作是否能够获得最新数据</p><p>根据更新数据后各进程访问到数据的时间和方式不同，可以分为：</p><ul><li>因果一致性：A通知B可以获得</li><li>读己之所写一致性</li><li>单调读一致性</li><li>会话一致性：会话存在就可以保证读己之所写一致性</li><li>单调写一致性：保证同一个进程写操作按顺序执行</li></ul></li></ul><h6 id="实现一致性"><a href="#实现一致性" class="headerlink" title="实现一致性"></a>实现一致性</h6><p>假设一个分布式系统，实现可靠性，N：对数据进行冗余存储份数，W：更新数据时保证写完成的节点数，R：读取数据时候需要读取的节点数</p><p>当W+R&gt;N，强一致性<img src="images/image-20201105120108268.png" alt="image-20201105120108268" style="zoom:50%;"></p><p>当W+R&lt;=N，弱一致性<img src="images/image-20201105120243549.png" alt="image-20201105120243549" style="zoom:50%;"></p><p>一般N&gt;=3</p><p>如果N=W R=1，任何一个写节点失效都会导致写失败，因此可用性降低，但是由于数据分布的N个节点是同步写入的因此可以保证强一致性</p><p>HDFS采用强一致性保证，N=W R=1</p><h3 id="NoSQL和NewSQL数据库区别"><a href="#NoSQL和NewSQL数据库区别" class="headerlink" title="NoSQL和NewSQL数据库区别"></a>NoSQL和NewSQL数据库区别</h3><img src="images/image-20201105120632265.png" alt="image-20201105120632265" style="zoom:50%;"><p>而现在根据不同应用场景来使用</p><p>分析型应用：NewSQL；事务型应用：OldSQL；互联网应用：NoSQL</p><p>NewSQL是关系型数据库，同时具备 OldSQL和NoSQL优点</p><img src="images/image-20201105120827245.png" alt="image-20201105120827245" style="zoom:50%;"><h3 id="文档数据库MongoDB为实例介绍NoSQL数据库编程实战"><a href="#文档数据库MongoDB为实例介绍NoSQL数据库编程实战" class="headerlink" title="文档数据库MongoDB为实例介绍NoSQL数据库编程实战"></a>文档数据库MongoDB为实例介绍NoSQL数据库编程实战</h3><img src="images/image-20201105121059323.png" alt="image-20201105121059323" style="zoom:50%;"><h4 id="与关系数据库的比较"><a href="#与关系数据库的比较" class="headerlink" title="与关系数据库的比较"></a>与关系数据库的比较</h4><p><img src="images/image-20201105121116356.png" alt="image-20201105121116356"></p><p>比如博客评论，记录在一个文档即可</p><p>客户端是mongod服务器端是mongo</p><p>集合就是mongoDB文档组，类似于RDBMS的表格，集合存在于数据库中，没有固定结构，可以对集合查入不同格式和类型的数据</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><img src="images/image-20201105121345717.png" alt="image-20201105121345717" style="zoom:50%;"><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><img src="images/image-20201105121357484.png" alt="image-20201105121357484" style="zoom:50%;"><p>安装：</p><p><img src="images/image-20201105121637215.png" alt="image-20201105121637215"></p><p>使用：</p><p><img src="images/image-20201105121736509.png" alt="image-20201105121736509"></p><p>编程方式访问：</p><p><img src="images/image-20201105121843521.png" alt="image-20201105121843521"></p><p><img src="images/image-20201105121857478.png" alt="image-20201105121857478"></p><p><img src="images/image-20201105121920473.png" alt="image-20201105121920473"></p><p><img src="images/image-20201105121950080.png" alt="image-20201105121950080"></p><p><img src="images/image-20201105122004775.png" alt="image-20201105122004775"></p><h1 id="云数据库"><a href="#云数据库" class="headerlink" title="云数据库"></a>云数据库</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>云计算：通过网络以服务的方式为用户提供廉价的IT资源。按需服务，随时服务，通用性，高可靠性，极其廉价，超大规模，虚拟概念，虚拟化技术</p><p>云数据库：IaaS，PaaS，SaaS部署和虚拟化在云计算环境下的数据库，因此动态可扩展、高可用性、较低的使用代价、易用性、免维护、高性能、安全</p><p>个性化存储需求：大企业海量数据存储需求、中小企业低成本数据存储需求、企业动态变化的存储需求</p><p>云数据库和其他数据库关系，以数据模型角度通过网络以服务的方式提供数据库功能，并没有专属的数据模型</p><h2 id="UMP系统"><a href="#UMP系统" class="headerlink" title="UMP系统"></a>UMP系统</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><blockquote><p>mysql解决方案，低成本高性能开源数据库</p></blockquote><p>UMP在设计时实现以下原则：</p><ul><li>整个系统保持单一的对外访问入口，统一的入口，统一的资源池供调用</li><li>消除单点故障，保证服务的高可用性，存在管家Controller多个</li><li>具有良好的可伸缩，能够动态增加、减少计算资源</li><li>可以实现资源之间的相互隔离，因为云数据库属于多租户，而共用底层资源，可能会出现某个用户消耗资源过多的情况，因此UMP设置了安全限制</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>mysql集群负责具体数据库存储，controller服务器管理（多个，由zookeeper选出总管），对外提供服务窗口由proxy服务器，LVS实现集群负载均衡</p><img src="images/image-20201106144450532.png" alt="image-20201106144450532" style="zoom:50%;"><blockquote><p>mnesia：分布式数据库管理系统，支持事务，支持透明的数据分片，数据库模式可以运行时动态配置</p><img src="images/image-20201106144633822.png" alt="image-20201106144633822" style="zoom:50%;"><p>RabbitMQ：工业级消息队列产品，异步传输，保证可靠的消息传输</p><img src="images/image-20201106144756010.png" alt="image-20201106144756010" style="zoom:50%;"><p>ZooKeeper：高效可靠的协调服务，在UMP系统中作为全局的配置服务器，可以设定相关监听，检测到后告诉其他，提供分布式锁（选出集群总管，多个管家中一个，其他后备），监控所有mysql实例状态</p><p>LVS Linux Virtual Server：实现集群内部负载均衡，采用IP负载均衡技术和基于内容请求分发技术，调度器是LVS集群系统唯一入口点，整个服务器集群结构对客户透明</p><p>Controller服务器：集群管理，运行了一组mnesia分布式数据库服务，为了避免单点故障，设置多个Controller服务器，而由ZooKeeper服务器确定总管，提供对外服务</p><p>Web控制台：提供界面</p><p>Proxy服务器：面向用户提供访问mysql数据库服务，通过用户名获得用户认证信息，进行资源配额限制，后台mysql实例地址</p><p>agent服务器：部署在允许mysql进程的机器上，用来管理每台物理机上的mysql实例。</p><p>日志分析服务器：对整个日志进行分析</p><p>信息统计服务器：系统运营数据如用户连接数、每秒查询数、mysql实例进程状态</p><p>愚公系统：数据迁移，允许不停机情况下动态扩容、缩容、迁移</p></blockquote><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><h3 id="分布式并行编程"><a href="#分布式并行编程" class="headerlink" title="分布式并行编程"></a>分布式并行编程</h3><p>数据处理能力提升的两条路线：</p><ol><li>单核CPU到双核到四核到八核</li><li>分布式并行编程：借助一个集群通过多台机器同时并行处理大规模数据集</li></ol><img src="images/image-20201106151304653.png" alt="image-20201106151304653"><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>Map + Reduce</p><h4 id="策略：分而治之"><a href="#策略：分而治之" class="headerlink" title="策略：分而治之"></a>策略：分而治之</h4><p>把非常庞大的数据集切分成非常多的独立小分片，为每一个分片单独启动一个map任务， 最终通过多个map任务，并行地在多个机器上去处理</p><p><strong>遵循</strong>计算向数据靠拢（构建集群选取机器做map机器进行数据处理分析，数据块在不同机器上，数据寻找离所在机器最近的map机器，通常是同台，数据不需迁移，计算就在数据节点上执行）而不是数据向计算靠拢（选择计算结点，把运行数据分析的程序放在计算节点上运行，然后把它涉及的数据从各个不同节点上拉过来，传输到计算发生地方）减少了数据传输开销</p><img src="images/image-20201106153907633.png" alt="image-20201106153907633" style="zoom:50%;"><h4 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h4><p>Master/slave</p><img src="images/image-20201106154104934.png" alt="image-20201106154104934" style="zoom:50%;"><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><img src="images/image-20201106154208859.png" alt="image-20201106154208859"><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p><img src="images/image-20201106154301887.png" alt="image-20201106154301887"></p><h2 id="体系结构-1"><a href="#体系结构-1" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><ul><li><p>通过client提交用户编写应用程序，将其交给jobtracker端</p></li><li><p>同时可以查看当前提交作业运行状态</p></li></ul><h3 id="jobtracker"><a href="#jobtracker" class="headerlink" title="jobtracker"></a>jobtracker</h3><ul><li>负责资源的监控和作业调度</li><li>监控底层的其他tasktracker以及当前运行的job健康状态</li><li>一旦探测到失败情况把任务转移到其他节点继续跟踪任务执行进度和资源使用量（涉及任务调度器）</li></ul><h3 id="tasktrackr-任务调度器"><a href="#tasktrackr-任务调度器" class="headerlink" title="tasktrackr-任务调度器"></a>tasktrackr-任务调度器</h3><ul><li>执行具体的相关任务一般接收jobtracker的命令</li><li>把一些自己的资源使用情况，以及任务的运行进度通过心跳的方式，即heartbeat发送给jobtracker</li></ul><h4 id="衡量资源状态-slot槽"><a href="#衡量资源状态-slot槽" class="headerlink" title="衡量资源状态-slot槽"></a>衡量资源状态-slot槽</h4><p>所有资源进行打包，然后等分为slot（map类型、reduce类型），两种类型的slot并不通用，map类型的由map任务执行，以slot为单位调度资源，也就是说只有有空闲的slot才能把相关task分配执行</p><h3 id="task-schedule"><a href="#task-schedule" class="headerlink" title="task schedule"></a>task schedule</h3><ul><li>map任务</li><li>reduce任务</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="images/image-20201108105351128.png" alt="image-20201108105351128"></p><blockquote><p>应用程序执行大规模数据分析，大规模数据保存在分布式文件系统，如HDFS，因此需要分片，每个分片单独分配map任务，输入输出均为key value，map任务输出结果分配给不同的reduce，分区数量一般取决于reduce数量，分发过程为shuffle，最后给reduce，reduce处理后写入hdfs</p></blockquote><ul><li>不同map任务不进行通信，不同的reduce也不进行信息交换，用户也不能从一台机器向另一台机器发送消息</li></ul><h3 id="执行的各个阶段"><a href="#执行的各个阶段" class="headerlink" title="执行的各个阶段"></a>执行的各个阶段</h3><p><img src="images/image-20201108110244574.png" alt="image-20201108110244574"></p><blockquote><ul><li>InputFormat：首先执行从HDFS加载文件，对输入进行格式验证，同时对大数据集切分为split，<strong>逻辑上切分</strong></li><li>由recordreader记录阅读器具体根据分片长度信息，从hdfs各块中读出&lt;key, value&gt;，交给map</li><li>map函数输入后，根据用户的处理逻辑，处理后得到一堆key-value</li><li>对输出进行分区排序合并归并（shuffle，洗牌），然后再把相关键值对交给对应reduce任务</li><li>reduce处理用户撰写的处理逻辑，完成数据分析，以value输出</li><li>outputFomat对输出进行检查，然后交给hdfs</li></ul></blockquote><h4 id="split-分片"><a href="#split-分片" class="headerlink" title="split-分片"></a>split-分片</h4><p>inputformat将大的文件分成很多split</p><p>hdfs分块是物理块，分片是逻辑分片，由用户定义，每次产生分片，会为其分配map任务，因此map任务多会浪费管理资源，如果过少无法很好的利用并行，因此一般根据块大小定义，否则横跨block，如果不在一台机器，那么会有额外的数据开销</p><p><img src="images/image-20201108111555841.png" alt="image-20201108111555841"></p><h4 id="map、reduce分配"><a href="#map、reduce分配" class="headerlink" title="map、reduce分配"></a>map、reduce分配</h4><p>map数量一般按照分片数量，reduce任务的数量一般取决于集群中可用的reduce任务槽slot的数目（通常设置比reduce任务槽数目稍微小一些的reduce任务个数，可以预留一些系统资源处理可能发生的错误）</p><h2 id="shuffle过程原理"><a href="#shuffle过程原理" class="headerlink" title="shuffle过程原理"></a>shuffle过程原理</h2><p><img src="images/image-20201108111927974.png" alt="image-20201108111927974"></p><blockquote><p>数据从分布式文件系统输入，输入后分片处理，每个分片分配一个map执行处理逻辑，输出键值对。</p><p>键值对先进入缓存，缓存满后再溢写到磁盘（过程中进行分区排序合并），溢写发生多次，生成多个磁盘文件，多个磁盘文件进行统一归并，然后通知reduce取走。reduce执行归并得到键值对，交给reduce执行处理逻辑，然后给分布式文件系统</p></blockquote><h3 id="map端shuffle"><a href="#map端shuffle" class="headerlink" title="map端shuffle"></a>map端shuffle</h3><p><img src="images/image-20201108112436428.png" alt="image-20201108112436428"></p><h4 id="输入数据和执行map任务"><a href="#输入数据和执行map任务" class="headerlink" title="输入数据和执行map任务"></a>输入数据和执行map任务</h4><p>切分给map任务，每个map任务分配缓存</p><h4 id="写入缓存"><a href="#写入缓存" class="headerlink" title="写入缓存"></a>写入缓存</h4><h4 id="溢写"><a href="#溢写" class="headerlink" title="溢写"></a>溢写</h4><p>一般设置溢写比例（0.8）防止满了造成丢失</p><h5 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h5><p>不同的reduce不同的区，一般采用哈希函数</p><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>默认操作，根据key</p><h5 id="合并（非必须）"><a href="#合并（非必须）" class="headerlink" title="合并（非必须）"></a>合并（非必须）</h5><p>减少溢写到磁盘的数据量，如A、A合并为（A，2）（由于合并有代价，可以设置阈值再进行合并）</p><p>注意保证不改变计算结果</p><h4 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h4><p>多次溢写，磁盘有多个溢写文件，那么系统对其进行归并，最后交给本地磁盘，大文件内键值对是分区且排序的</p><p><strong>jobtracker检测到写完数据到磁盘生成大文件，会通知reduce取出数据</strong></p><h3 id="reduce端shuffle"><a href="#reduce端shuffle" class="headerlink" title="reduce端shuffle"></a>reduce端shuffle</h3><p><img src="images/image-20201108113215979.png" alt="image-20201108113215979"></p><blockquote><p>reduce从map机器拉走数据，需要从多个map任务取走，那么既然是多个map机器取出，肯定还可以进行合并，因此进行归并再合并</p><p>归并：生成&lt;key, value-list&gt;，如果不进行合并就是key value-list</p><p>如果有合并则合并后写入磁盘，磁盘中有可能有若干个文件，那么还需要归并成大文件，多轮归并可能还是若干个，可以直接给reduce处理</p></blockquote><h2 id="应用程序执行过程"><a href="#应用程序执行过程" class="headerlink" title="应用程序执行过程"></a>应用程序执行过程</h2><p><img src="images/image-20201108113750732.png" alt="image-20201108113750732"></p><ol><li><p>程序部署</p><ul><li>master：1个，负责管家角色，jobtracker</li><li>worker：多个，有map也有reduce</li></ul></li><li><p>分配map\reduce任务，分配worker任务</p><p>对数据分片，分配map执行分片处理</p></li><li><p>从分布式文件系统读数据，得到键值对交给map，先写缓存</p></li><li><p>本地写数据到磁盘，得到大文件</p></li><li><p>从远端拉走数据到本地，远程读数据，执行reduce函数，得到键值对</p></li><li><p>写数据到输出文件，也就是分布式文件系统</p></li></ol><p>注意：中间过程并不写在分布式文件系统，只是个中间结果在本地磁盘即可</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul><li>能够分而治之的任务才能由mapreduce来做，如果有相互依赖性则无法使用</li></ul><img src="images/image-20201108115035223.png" alt="image-20201108115035223" style="zoom:50%;"><img src="images/image-20201108115044211.png" alt="image-20201108115044211" style="zoom:50%;"><img src="images/image-20201108115335996.png" alt="image-20201108115335996" style="zoom:50%;"><h3 id="实现自然连接"><a href="#实现自然连接" class="headerlink" title="实现自然连接"></a>实现自然连接</h3><img src="images/image-20201108115847808.png" alt="image-20201108115847808" style="zoom: 50%;"><p>实现如下：</p><p><img src="images/image-20201108115917327.png" alt="image-20201108115917327"></p><ul><li><p>使用map生成键值对</p><p>b作为key，&lt;R, a&gt;可以根据元组找到来自哪个关系，因为只能进行R S连接</p><p><img src="images/image-20201108120043939.png" alt="image-20201108120043939"></p></li><li><p>交给reduce任务，相同key，来自不同关系进行连接</p><p><img src="images/image-20201108120113749.png" alt="image-20201108120113749"></p></li></ul><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="images/image-20201109062539800.png" alt="image-20201109062539800"></p><blockquote><p>注意:需要导入相应的jar包</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        String[] otherArgs = (<span class="keyword">new</span> GenericOptionsParser(conf, args)).getRemainingArgs();</span><br><span class="line">        <span class="keyword">if</span>(otherArgs.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Usage: wordcount &lt;in&gt; [&lt;in&gt;...] &lt;out&gt;&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Job job = Job.getInstance(conf, <span class="string">&quot;word count&quot;</span>); <span class="comment">// 设置环境参数</span></span><br><span class="line">        job.setJarByClass(WordCount.class);<span class="comment">// 设置整个程序类名</span></span><br><span class="line">        job.setMapperClass(WordCount.TokenizerMapper.class);<span class="comment">// 添加mapper类</span></span><br><span class="line">        job.setCombinerClass(WordCount.IntSumReducer.class);</span><br><span class="line">        job.setReducerClass(WordCount.IntSumReducer.class);<span class="comment">// 添加reducer类</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);<span class="comment">// 设置输出类型</span></span><br><span class="line">        job.setOutputValueClass(IntWritable.class); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; otherArgs.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[i]));<span class="comment">// 设置输入文件</span></span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(otherArgs[otherArgs.length - <span class="number">1</span>]));<span class="comment">//设置输出文件</span></span><br><span class="line">        System.exit(job.waitForCompletion(<span class="keyword">true</span>)?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;<span class="comment">// 继承自Mapper</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IntWritable one = <span class="keyword">new</span> IntWritable(<span class="number">1</span>); <span class="comment">//数据通过网络传输,因此需要保证可序列化</span></span><br><span class="line">        <span class="keyword">private</span> Text word = <span class="keyword">new</span> Text();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TokenizerMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输入输出类型定义</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Mapper&lt;Object, Text, Text, IntWritable&gt;.Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">// 执行map处理逻辑</span></span><br><span class="line">            StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString()); </span><br><span class="line">            <span class="keyword">while</span>(itr.hasMoreTokens()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.word.set(itr.nextToken());</span><br><span class="line">                context.write(<span class="keyword">this</span>.word, one);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">// 继承自reducer </span></span><br><span class="line">    <span class="comment">// 执行前经历shuffle,生成&lt;KEY, VALUE-LIST&gt;</span></span><br><span class="line">        <span class="keyword">private</span> IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IntSumReducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 输入iterable容器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Reducer&lt;Text, IntWritable, Text, IntWritable&gt;.Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            IntWritable val;</span><br><span class="line">            <span class="keyword">for</span>(Iterator i$ = values.iterator(); i$.hasNext(); sum += val.get()) &#123;</span><br><span class="line">                val = (IntWritable)i$.next();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.result.set(sum);<span class="comment">// 需要设置为可序列化类型</span></span><br><span class="line">            context.write(key, <span class="keyword">this</span>.result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包为jar包后执行输出结果如下:</p><p><img src="images/image-20201109120905340.png" alt="image-20201109120905340"></p><h1 id="Hadoop发展"><a href="#Hadoop发展" class="headerlink" title="Hadoop发展"></a>Hadoop发展</h1><ul><li>抽象层次低，需人工编码</li><li>表达能力有限</li><li>难以看到程序整体逻辑</li><li>开发者自己管理作业之间依赖关系</li><li>执行迭代操作效率低</li><li>资源浪费</li><li>实时性差</li></ul><img src="images/image-20201203160548636.png" alt="image-20201203160548636" style="zoom:50%;"><blockquote><p>热备机制高可用性；多个命名空间实现资源隔离；yarn来承担资源管理</p></blockquote><h2 id="HDFS-HA、HDFS-Federation"><a href="#HDFS-HA、HDFS-Federation" class="headerlink" title="HDFS HA、HDFS Federation"></a>HDFS HA、HDFS Federation</h2><h3 id="HDFS-HA"><a href="#HDFS-HA" class="headerlink" title="HDFS HA"></a>HDFS HA</h3><p>解决单点故障问题，热备份</p><ul><li><p>架构</p><p>Zookeeper集群帮助保证只有一个节点处于活跃状态</p><p>共享存储系统保证待命节点与活跃节点保证数据信息同步，同步的是editlog，并不是映射表（映射关系是通过底层不断汇报获得）</p><img src="images/image-20201203161256058.png" alt="image-20201203161256058" style="zoom: 80%;"></li></ul><h3 id="HDFS-Fedration"><a href="#HDFS-Fedration" class="headerlink" title="HDFS Fedration"></a>HDFS Fedration</h3><p>解决水平扩展问题、单个名称节点吞吐量（系统性能）、不同程序之间隔离性。</p><ul><li><p>架构</p><p>多个名称节点，相互独立构成联盟关系，提供向后兼容性、且所有名称节点共享底层数据存储池（块池只是逻辑概念）</p><img src="images/image-20201203161950514.png" alt="image-20201203161950514" style="zoom:80%;"><blockquote><p>全局命名空间，可以通过客户端挂载方式，访问不同挂载点访问不同空间</p><img src="images/image-20201203162311798.png" alt="image-20201203162311798" style="zoom: 50%;"></blockquote><ol><li>多个名称节点，可扩展</li><li>性能更高效，多个名称节点提供对外服务</li><li>良好的隔离性</li></ol></li><li><p>依然未解决单点故障问题，各个名称节点不是备份关系，需要热备份</p></li></ul><h2 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h2><img src="images/image-20201203162908015.png" alt="image-20201203162908015" style="zoom: 67%;"><p>MapReduce成为了纯粹的计算框架，不再负责资源调度管理服务</p><h3 id="体系结构-2"><a href="#体系结构-2" class="headerlink" title="体系结构"></a>体系结构</h3><p><img src="images/image-20201203220218297.png" alt="image-20201203220218297"></p><p><img src="images/image-20201203163117695.png" alt="image-20201203163117695"></p><h4 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h4><p>负责处理客户端请求；启动/监控ApplicationMaster；监控NodeManager、资源分配与调度</p><blockquote><p><strong>全局资源管理器</strong>，负责整个系统的资源管理和分配，主要包括两个组件：调度器和应用程序管理器</p></blockquote><h5 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h5><p>接收来自ApplicationMaster应用程序资源请求，把集群中的资源以容器的形式分配给提出申请的应用程序，容器的选择通常考虑应用程序所要处理的数据位置，进行就近选择从而实现<strong>计算向数据靠拢</strong></p><ul><li><strong>容器Container</strong>：作为动态资源分配单位，每个容器中都封装了一定数量的CPU、内存、磁盘等资源，从而限定每个应用程序可以使用的资源量</li></ul><p>调度器被设计成一个可插拔的组件，不仅自身提供了许多种直接可用的调度器，也可以允许用户根据自己需求重新设计调度器</p><h5 id="应用程序管理器"><a href="#应用程序管理器" class="headerlink" title="应用程序管理器"></a>应用程序管理器</h5><p>负责系统中<strong>所有应用程序的管理工作</strong>（管ApplicationMaster），主要包括应用程序提交、与调度器协商资源以启动ApplicationMaster、监控ApplicationMaster运行状态并在失败时重新启动</p><p><strong>过渡：</strong>ResourceManager接收用户提交的作业，按照作业的上下文信息以及NodeManager收集来的容器状态信息，启动调度过程，<strong>为用户作业启动一个ApplicationMaster</strong></p><h4 id="ApplicationMaster"><a href="#ApplicationMaster" class="headerlink" title="ApplicationMaster"></a>ApplicationMaster</h4><p>为应用程序申请资源并分配给内部任务；任务调度、监控与容错</p><p>功能：</p><ul><li>当用户<strong>作业提交</strong>（用户程序是以作业形式提交）时，ApplicationMaster与ResourceManager协商获取资源，ResourceManager以容器的形式给ApplicationMaster分配资源</li><li>把获得的资源进一步分配给内部的各个任务（Map Reduce），实现资源的<strong>二次分配</strong></li><li>与NodeManager<strong>保持交互通信</strong>进行应用程序的启动、运行、监控和停止，<strong>监控申请到的资源的使用情况</strong>，对所有任务的执行进度和状态进行监控，<strong>并在任务发生失败时执行失败恢复</strong>（即重新申请资源重启任务）</li><li>定时向ResourceManager发送心跳信息，报告资源的使用情况和应用的进度信息</li><li>作业完成时ApplicationMaster向ResourceManager注销容器，执行周期完成</li></ul><h4 id="NodeManager"><a href="#NodeManager" class="headerlink" title="NodeManager"></a>NodeManager</h4><p>单个节点上的资源管理；处理来自ResourceManager命令；处理来自ApplicationMaster命令</p><blockquote><p>驻留在一个YARN集群中每个节点上的代理，主要负责：</p><ul><li>容器生命周期管理</li><li>监控每个容器的资源（CPU、内存）使用情况</li><li>跟踪节点健康状况</li><li>以心跳方式和ResourceManager保持通信</li><li>向ResourceManager汇报作业的资源使用情况和每个容器的运行状态</li><li>接收来自ApplicationMaster的启动/停止容器的各种请求</li></ul></blockquote><p><strong>注意</strong>：NodeManager主要负责管理抽象的容器，只处理与容器相关的事情，而不具体负责每个任务（Map任务或Reduce任务）自身状态的管理，这些管理工作由ApplicationMaster完成，ApplicationMaster会通过不断与NodeManager通信来掌握各个任务的执行状态</p><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><img src="images/image-20201203220408893.png" alt="image-20201203220408893" style="zoom: 80%;"><blockquote><ol><li>用户编写客户端应用程序向YARN提交应用程序（3个）</li><li>YARN中的ResourceManager负责接收和处理来自客户端的请求，为应用程序<strong>分配一个容器</strong>，<strong>在该容器中启动</strong>一个ApplicationMaster</li><li>ApplicationMaster被创建后会首先向ResourceManager注册（才能监控管理）</li><li>ApplicationMaster采用轮询的方式向ResourceManager申请资源</li><li>ResourceManager以容器的形式向提出申请的ApplicationMaster分配资源</li><li>在容器中启动任务（运行环境、脚本）容器中会二次分配资源</li><li>各个任务向ApplicationMaster汇报自己的状态和进度</li><li>应用程序运行完成后，ApplicationMaster向ResourceManager的应用程序管理器注销并关闭自己</li></ol></blockquote><h3 id="发展目标"><a href="#发展目标" class="headerlink" title="发展目标"></a>发展目标</h3><ul><li>运行MapReduce批处理</li><li>运行流计算Storm</li><li>运行基于内存计算的Spark</li></ul><blockquote><p><strong>YARN的目标是实现一个集群多个框架，即在一个集群上部署一个统一的资源调度管理框架YARN，在YARN上可以部署其他各种计算框架</strong></p><p>因为企业会同时存在各种不同的业务应用场景，需要采用不同的计算框架，如</p><img src="images/image-20201203221934285.png" alt="image-20201203221934285" style="zoom:50%;"><p>不同的计算框架会争抢资源，因此为了避免不同类型应用之间互相干扰，需要把内部的服务器拆分成多个集群，分别安装运行不同的计算框架即“一个框架一个集群”，然而集群资源利用率低（一些会处于空闲状态）；数据无法共享（集群之间隔离）；维护代价高</p><blockquote><p>YARN为这些计算框架提供统一的资源调度管理服务，并且能够根据各种计算框架的负载需求，调整各自占用的资源，实现集群资源共享和资源弹性收缩</p><p>可以实现一个集群上不同应用负载混搭，有效提高了集群的利用率</p><p>不同计算框架可以共享底层存储，避免了数据集跨集群移动，如下</p><img src="images/image-20201203222546157.png" alt="image-20201203222546157" style="zoom:50%;"></blockquote></blockquote><h2 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h2><h3 id="Pig"><a href="#Pig" class="headerlink" title="Pig"></a>Pig</h3><ul><li>Apache项目中一个开源项目</li><li>提供了类似SQL的Pig Latin语言（包含Filter、GroupBy，Join，OrderBy等操作，同时也支持用户自定义函数）</li><li>用户只需要撰写非常简单的Pig Latin语句即可完成各种复杂的数据分析任务</li><li>Pig会自动把用户编写的脚本转换成MapReduce作业在Hadoop集群上运行，而且具备对生成的MapReduce程序进行自动优化功能</li><li>因此用户在编写Pig程序的时候，不需要关心程序的运行效率，大大减少了用户编程时间</li></ul><p>提供过滤、分组、连接、排序操作</p><p><strong>过程</strong>：</p><ol><li>加载数据</li><li>表达转换数据</li><li>存储最终结果</li></ol><blockquote><ul><li>通过LOAD语句去文件系统读取数据</li><li>通过一系列“转换”语句对数据进行处理</li><li>通过STORE语句把处理结果输出到文件当中去或者用DUMP语句把处理结果输出到屏幕上</li></ul><p>一般先数据收集，到Pig数据加工，然后到Hive做数据仓库进行海量数据分析</p></blockquote><img src="images/image-20201203223354254.png" alt="image-20201203223354254" style="zoom:80%;"><p>转换为一堆Map任务与Reduce任务，其中一些横跨两个任务</p><img src="images/image-20201203223625184.png" alt="image-20201203223625184" style="zoom:50%;"><h3 id="Tez"><a href="#Tez" class="headerlink" title="Tez"></a>Tez</h3><ul><li><p>Apache开源的支持DAG作业的计算框架，直接缘与MapReduce框架</p></li><li><p>核心思想是将Map和Reduce两个操作进一步拆分，分解后可以任意灵活组合，进行细粒度划分，产生新操作，经过一些控制程序组装后形成一个大的DAG作业，通过DAG作业方式运行MapReduce对多余操作和衔接部分处理，提供程序运行的整体处理逻辑</p><img src="images/image-20201203224029805.png" alt="image-20201203224029805" style="zoom:50%;"><img src="images/image-20201203224038514.png" alt="image-20201203224038514" style="zoom:50%;"></li></ul><p><img src="images/image-20201203224410083.png" alt="image-20201203224410083"></p><blockquote><p>四次的MapReduce任务变为右</p><p>优势：</p><ul><li><p>去除连续两个作业之间写入HDFS操作</p></li><li><p>去除每个工作流中多余的Map阶段</p><img src="images/image-20201203224619674.png" alt="image-20201203224619674" style="zoom:50%;"></li></ul></blockquote><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><img src="images/image-20201203224848721.png" alt="image-20201203224848721" style="zoom:50%;"><blockquote><p>Spark是用于大规模数据处理的快速、通用引擎</p><ul><li>采用内存计算，带来更高的迭代运算效率</li><li>基于DAG的任务调度执行机制，优于MapReduce的迭代执行机制</li></ul></blockquote><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>一种高吞吐量的分布式发布订阅消息系统，用户通过Kafka系统可以发布大量消息，同时也能实时订阅消费消息</p><ul><li><p>可以同时满足在线实时处理和批量离线处理</p></li><li><p>作为数据交换的中枢</p><blockquote><p><img src="images/image-20201203225124017.png" alt="image-20201203225124017"></p><ul><li>解决大规模数据存储，采用NoSQL</li><li>流计算Storm</li><li>内存计算Spark</li></ul><p>不同类型的分布式系统可以统一介入到Kafka，实现和Hadoop各个组件之间的不同类型数据的实时高效交换</p></blockquote></li></ul><h1 id="数据仓库Hive"><a href="#数据仓库Hive" class="headerlink" title="数据仓库Hive"></a>数据仓库Hive</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><p>数据仓库：</p><blockquote><p>面向主题的、集成的、相对稳定的、反映历史变化的数据集合，用于支持管理决策</p><p>为了支持企业内部商业分析和决策</p></blockquote><img src="images/image-20201204185222584.png" alt="image-20201204185222584" style="zoom:80%;"><ul><li><p>Hive</p><img src="images/image-20201204185839070.png" alt="image-20201204185839070" style="zoom:50%;"></li><li><p>Hive架构在底层的Hadoop核心组件基础上</p><p>依赖HDFS存储数据、依赖分布式并行计算模型MapReduce处理数据、借鉴SQL语言设计了新的查询语言HiveQL来运行MapReduce任务实现数据仓库分析，类似SQL接口容易移植</p></li><li><p>Hive的特性：</p><ol><li>采用批处理方式处理海量数据<ul><li>Hive把HiveQL语句转换成MapReduce任务进行运行</li><li>数据仓库存储的是静态数据，对静态数据的分析适合采用批处理方式，不需要快速响应给出结构，而且数据本身也不会频繁变换</li></ul></li><li>Hive提供了一系列对数据进行提取、转换、加载(ETL)工具。可以存储、查询和分析存储在Hadoop中的大规模数据，能很好的满足数据仓库各种应用场景</li></ol></li><li><p>Hive在Hadoop生态系统</p><p>与Pig类似，但是Pig轻量级，适合实时交互性分析，主要用于ETL环节</p><p>Hive主要用于数据仓库海量数据的批处理分析</p><img src="images/image-20201204190514466.png" alt="image-20201204190514466" style="zoom:50%;"></li><li><p>Hive与传统数据库差别</p><img src="images/image-20201204190753638.png" alt="image-20201204190753638" style="zoom:50%;"><blockquote><p>Hive数据仓库保存静态数据，不允许更新；Hive需要海量数据批处理无法实时；Hive水平可扩展性很好</p></blockquote></li><li><p>Hive在企业大数据分析平台中的应用</p><img src="images/image-20201204190934371.png" alt="image-20201204190934371" style="zoom:33%;"></li><li><p>Hive系统架构</p><img src="images/image-20201204191224514.png" alt="image-20201204191224514" style="zoom:50%;"><blockquote><p>较重要的模块：</p><ul><li><p>对外接口模块</p><p>CLI:一种命令行工具</p><p>HWI:Hive Web Interface是Hive的Web接口</p><p>JDBC和ODBC:开放数据库连接接口</p><p>Thrift Server:基于Thrift架构开发的接口，允许外界通过该接口实现对Hive仓库的RPC调用</p></li><li><p>驱动模块</p><p>包含编译器、优化器、执行器</p><p>就是把HiveQL语句转换成一系列MapReduce作业</p></li><li><p>元数据存储模块Metastore</p><p>一个独立的关系型数据库</p><p>通过MySQL</p></li></ul></blockquote></li><li><p>Hive HA</p><p>高可用性Hive解决方案</p><p>在很多时候Hive表现出不稳定，因此提出Hive HA，即通过整个Hive集群，设置多个Hive实例，放入统一资源池，外界访问设置统一访问接口HAProxy</p><img src="images/image-20201204191700371.png" alt="image-20201204191700371" style="zoom:67%;"><blockquote><ul><li>访问HA Proxy</li><li>一次询问Hive实例，执行逻辑可用性测试，不通过加入黑名单</li><li>每隔一定周期，HA Proxy重新对列入黑名单的实例进行统一处理</li></ul></blockquote></li></ul><h2 id="SQL转MapReduce作业原理"><a href="#SQL转MapReduce作业原理" class="headerlink" title="SQL转MapReduce作业原理"></a>SQL转MapReduce作业原理</h2><p>举例如连接操作：</p><ol><li>编写一个Map处理逻辑</li><li>Map处理逻辑输入关系数据库的表</li><li>每条记录通过Map转换</li></ol><p><strong>原理：</strong></p><p>当用户向Hive输入一段命令或查询时，Hive需要与Hadoop交互工作来完成该操作</p><ul><li>驱动模块接收该命令或查询编译器</li><li>对该命令或查询进行解析编译</li><li>由优化器对该命令或查询进行优化计算</li><li>该命令或查询通过执行器进行执行</li></ul><img src="images/image-20201204193536637.png" alt="image-20201204193536637" style="zoom: 80%;"><blockquote><p>HiveQL输入后</p><ol><li>由Hive驱动模块中的编译器对用户输入的SQL语言进行词法和语法解析， 将SQL语句转化为抽象语法树形式</li><li>抽象语法树仍然复杂，因此转化为查询块</li><li>把查询块转换成逻辑查询计划，里面包含了许多逻辑操作符</li><li>重写逻辑查询计划，进行优化合并多余操作，减少MapReduce任务数量</li><li>把逻辑操作符转换成需要执行的具体MapReduce任务</li><li>对生成的MapReduce任务进行优化生成最终的MapReduce任务执行计划</li><li>由Hive驱动模块中的执行器对最终的MapReduce任务进行执行输出</li></ol><p>Hive本身不生成MapReduce程序</p><p>而是通过一个表示“JOB执行计划”的XML文件驱动执行内置的、原生的Mapper和Reducer模块</p><p>Hive通过和JobTracker通信来初始化MapReduce任务，不必直接部署在JobTracker所在的管理节点上执行</p><p>通常在大型集群上，有专门的网关机来部署Hive工具，与远程JobTracker通信来完成具体任务</p></blockquote><h2 id="Impala"><a href="#Impala" class="headerlink" title="Impala"></a>Impala</h2><ul><li><p>Impala的允许需要依赖于Hive的元数据，参照Dremel系统进行设计，响应高</p></li><li><p>不需要转化为MapReduce任务，采用了与商用并行关系数据库类似的分布式查询引擎，直接与HDFS和HBase进行交互查询，数据存储在HDFS和HBase中</p><img src="images/image-20201204194448198.png" alt="image-20201204194448198" style="zoom:67%;"></li><li><p>和Hive采用相同的SQL语法ODBC驱动程序和用户接口</p></li></ul><img src="images/image-20201204195246149.png" alt="image-20201204195246149" style="zoom:50%;"><h3 id="系统架构-1"><a href="#系统架构-1" class="headerlink" title="系统架构"></a>系统架构</h3><p><img src="images/image-20201204194538924.png" alt="image-20201204194538924"></p><blockquote><p>Impala组件并不是单独部署，和Hadoop其他组件一起部署，部署于同一个集群，因此可以用底层的HDFS和HBase</p></blockquote><p><strong>Impala的组件</strong>：</p><ul><li>Impalad：负责具体的相关查询任务</li><li>State Store：负责元数据管理和状态信息维护</li><li>CLI：用户访问接口</li></ul><h4 id="Impalad"><a href="#Impalad" class="headerlink" title="Impalad"></a>Impalad</h4><p>驻留在各个不同数据节点上的不同的相关进程</p><blockquote><p>包含Query Planner、Query Coordinator、Query Exec Engine三个模块</p></blockquote><ul><li>负责协调客户端提交的查询的执行</li><li>与HDFS的数据节点（HDFS DN）允许在同一节点</li><li>给其他Impalad分配任务以及收集其他Impalad的执行结果进行汇总（分布）</li><li>也会执行其他Impalad给其分配的任务，对本地HDFS和HBase里的部分数据进行操作</li><li></li></ul><h4 id="State-Store"><a href="#State-Store" class="headerlink" title="State Store"></a>State Store</h4><p>每个查询的提交都会创建一个StateStore进程，其来跟踪监控各个查询任务</p><ul><li>负责收集分布在集群中各个Impalad进程的资源信息用于查询调度</li></ul><h4 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h4><p>给用户提供查询使用的命令行工具</p><p>提供了Hue、JDBC、ODBC的使用接口</p><h3 id="查询执行过程"><a href="#查询执行过程" class="headerlink" title="查询执行过程"></a>查询执行过程</h3><img src="images/image-20201204195324284.png" alt="image-20201204195324284" style="zoom:50%;"><blockquote><ul><li>当用户提交查询前，Impala先创建一个负责协调客户端提交的查询的Impalad进程，该进程会向Impala State Store提交注册订阅信息，State Store会创建一个statestored进程，其通过创建多个线程来处理Impalad的注册订阅信息</li><li>用户通过CLI客户端提交一个查询到impalad进程，Impalad的Query Planner对SQL语句解析，生成解析树，Planner把这个查询的解析树变成若干PlanFragment，发送到Query Coordinator</li><li>Coordinator通过从MySQL源数据库中获取元数据，从HDFS名称节点中获取数据地址，以得到存储这个查询相关数据的所有数据节点</li><li>Coordinator初始化相应impalad上的任务执行，即把查询任务分配给所有存储该查询相关数据的数据节点</li><li>Query Executor通过流式交换中间输出，并由Query Coordinator汇聚来自各个impalad的结果</li><li>Coordinator把汇总后的结果返回给CLI客户端</li></ul></blockquote><h3 id="与Hive对比"><a href="#与Hive对比" class="headerlink" title="与Hive对比"></a>与Hive对比</h3><p><strong>不同点：</strong></p><ul><li><p>Hive适合长时间的批处理查询分析，而Impala适合实时交互式查询，因为Hive构建在MapReduce上，需要转换，impala直接架构在底层存储之上</p><img src="images/image-20201204202728443.png" alt="image-20201204202728443" style="zoom:50%;"></li><li><p>Hive依赖MapReduce计算框架，Impala把执行计划表现为一棵完整的执行计划树，直接分发执行计划到各个Impalad执行查询</p></li><li><p>Hive执行中，当内存放不下所有数据，会使用外存</p><p>而Impala在遇到内存不足，不会利用外存，因此处理查询其实受到限制</p></li></ul><p><strong>相同点：</strong></p><ul><li>使用系统的存储数据池都支持把数据存储于HDFS和HBase中</li><li>Hive与Impala使用相同的元数据</li><li>Hive与Impala中对SQL的解释处理相似，都是通过词法分析生成执行计划</li></ul><blockquote><p>Impala不是替换Hive工具，而是弥补不足，如实时性</p><p>实际上可以和Hive组合使用，如用Hive进行数据转换处理，然后再用Impala在Hive处理后的结果数据集上进行快速的数据分析</p></blockquote><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Hive支持基本数据类型和复杂类型, 基本数据类型主要有数值类型(INT、FLOAT、DOUBLE ) 、布尔型和字符串, 复杂类型有三种:ARRAY、MAP 和 STRUCT。</p><h4 id="基本数据类型-1"><a href="#基本数据类型-1" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul><li>TINYINT: 1个字节</li><li>SMALLINT: 2个字节</li><li>INT: 4个字节</li><li>BIGINT: 8个字节</li><li>BOOLEAN: TRUE/FALSE</li><li>FLOAT: 4个字节，单精度浮点型</li><li>DOUBLE: 8个字节，双精度浮点型STRING 字符串</li></ul><h4 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><ul><li>ARRAY: 有序字段</li><li>MAP: 无序字段</li><li>STRUCT: 一组命名的字段</li></ul><h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> hive;       #创建数据库</span><br><span class="line"><span class="keyword">show</span> databases;                           #查看Hive中包含数据库</span><br><span class="line"><span class="keyword">show</span> databases <span class="keyword">like</span> <span class="string">&#x27;h.*&#x27;</span>;                #查看Hive中以h开头数据库</span><br><span class="line"><span class="keyword">describe</span> databases;                       #查看hive数据库位置等信息</span><br><span class="line"><span class="keyword">alter</span> database hive <span class="keyword">set</span> dbproperties;     #为hive设置键值对属性</span><br><span class="line">use hive;                                 #切换到hive数据库下</span><br><span class="line"><span class="keyword">drop</span> database if <span class="keyword">exists</span> hive;             #删除不含表的数据库</span><br><span class="line"><span class="keyword">drop</span> database if <span class="keyword">exists</span> hive cascade;     #删除数据库和它中的表</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#创建内部表（管理表）</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> hive.usr(</span><br><span class="line">      name string comment <span class="string">&#x27;username&#x27;</span>,</span><br><span class="line">      pwd string comment <span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">      address struct<span class="operator">&lt;</span>street:string,city:string,state:string,zip:<span class="type">int</span><span class="operator">&gt;</span> comment  <span class="string">&#x27;home address&#x27;</span>,</span><br><span class="line">      identify map<span class="operator">&lt;</span><span class="type">int</span>,tinyint<span class="operator">&gt;</span> comment <span class="string">&#x27;number,sex&#x27;</span>) </span><br><span class="line">      comment <span class="string">&#x27;description of the table&#x27;</span>  </span><br><span class="line">     tblproperties(<span class="string">&#x27;creator&#x27;</span><span class="operator">=</span><span class="string">&#x27;me&#x27;</span>,<span class="string">&#x27;time&#x27;</span><span class="operator">=</span><span class="string">&#x27;2016.1.1&#x27;</span>); </span><br><span class="line">#创建外部表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> usr2(</span><br><span class="line">      name string,</span><br><span class="line">      pwd string,</span><br><span class="line">  address struct<span class="operator">&lt;</span>street:string,city:string,state:string,zip:<span class="type">int</span><span class="operator">&gt;</span>,</span><br><span class="line">      identify map<span class="operator">&lt;</span><span class="type">int</span>,tinyint<span class="operator">&gt;</span>) </span><br><span class="line">      <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">     location <span class="string">&#x27;/usr/local/hive/warehouse/hive.db/usr&#x27;</span>; </span><br><span class="line">#创建分区表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> usr3(</span><br><span class="line">      name string,</span><br><span class="line">      pwd string,</span><br><span class="line">      address struct<span class="operator">&lt;</span>street:string,city:string,state:string,zip:<span class="type">int</span><span class="operator">&gt;</span>,</span><br><span class="line">      identify map<span class="operator">&lt;</span><span class="type">int</span>,tinyint<span class="operator">&gt;</span>) </span><br><span class="line">      partitioned <span class="keyword">by</span>(city string,state string);    </span><br><span class="line">#复制usr表的表模式  </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> hive.usr1 <span class="keyword">like</span> hive.usr;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">in</span> hive;  </span><br><span class="line"><span class="keyword">show</span> tables <span class="string">&#x27;u.*&#x27;</span>;        #查看hive中以u开头的表</span><br><span class="line"><span class="keyword">describe</span> hive.usr;        #查看usr表相关信息</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> usr rename <span class="keyword">to</span> custom;      #重命名表</span><br><span class="line"> </span><br><span class="line">#为表增加一个分区</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> usr3 <span class="keyword">add</span> if <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">partition</span>(city<span class="operator">=</span><span class="string">&#x27;beijing&#x27;</span>,state<span class="operator">=</span><span class="string">&#x27;China&#x27;</span>) location <span class="string">&#x27;/usr/local/hive/warehouse/usr3/China/beijing&#x27;</span>; </span><br><span class="line">#修改分区路径</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> usr3 <span class="keyword">partition</span>(city<span class="operator">=</span>&quot;beijing&quot;,state<span class="operator">=</span>&quot;China&quot;)</span><br><span class="line">     <span class="keyword">set</span> location <span class="string">&#x27;/usr/local/hive/warehouse/usr3/CH/beijing&#x27;</span>;</span><br><span class="line">#删除分区</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> usr3 <span class="keyword">drop</span> if <span class="keyword">exists</span>  <span class="keyword">partition</span>(city<span class="operator">=</span><span class="string">&#x27;beijing&#x27;</span>,state<span class="operator">=</span><span class="string">&#x27;China&#x27;</span>);</span><br><span class="line">#修改列信息</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> custom change <span class="keyword">column</span> name username string after pwd;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> custom <span class="keyword">add</span> columns(hobby string);                  #增加列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> custom replace columns(uname string);              #删除替换列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> custom <span class="keyword">set</span> tblproperties(<span class="string">&#x27;creator&#x27;</span><span class="operator">=</span><span class="string">&#x27;liming&#x27;</span>);      #修改表属性</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> usr3 <span class="keyword">partition</span>(city<span class="operator">=</span>”beijing”,state<span class="operator">=</span>”China”) <span class="keyword">set</span> fileformat sequencefile;    #修改存储属性           </span><br><span class="line">use hive;                                                   #切换到hive数据库下</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> usr1;                                  #删除表</span><br><span class="line"><span class="keyword">drop</span> database if <span class="keyword">exists</span> hive cascade;                       #删除数据库和它中的表</span><br></pre></td></tr></table></figure><p><a href="http://dblab.xmu.edu.cn/blog/2440-2/">http://dblab.xmu.edu.cn/blog/2440-2/</a> 更多实操见此</p><h1 id="Spark-1"><a href="#Spark-1" class="headerlink" title="Spark"></a>Spark</h1><p>使用DAG执行引擎以支持循环数据流与内存计算；可交互式编程；提供完整强大的技术栈，包括SQL查询、流式计算、机器学习和图算法组件；运行模式多样，可运行于独立的集群模式中。</p><img src="images/image-20201207124634936.png" alt="image-20201207124634936" style="zoom:50%;"><blockquote><p>相比于Hadoop MapReduce，Spark提供了内存计算，将中间结果存放到内存中，对于迭代运算效率更高</p><p><img src="images/image-20201207125035911.png" alt="image-20201207125035911" style="zoom:50%;"><img src="images/image-20201207125202326.png" alt="image-20201207125202326"></p></blockquote><img src="images/image-20201207125206002.png" alt="image-20201207125206002" style="zoom:50%;"><h2 id="生态系统"><a href="#生态系统" class="headerlink" title="生态系统"></a>生态系统</h2><p>实际应用中大数据处理需要复杂的批量数据处理，通常时间跨度大、基于历史数据交互式查询、基于实时数据流的数据处理</p><blockquote><p>以上情形需要不同的软件，如MapReduce解决复杂的批量数据处理、Impala基于历史数据的交互式查询、Storm解决实时数据流处理。然而不同输入输出数据无法做到无缝连接，需要格式转换、维护成本高、难以统一资源协调和分配</p></blockquote><blockquote><p>Spark设计使一个软件栈满足不同应用场景</p><ul><li>既能够提供内存计算框架</li><li>也可以支持SQL即时查询、实时流式计算、机器学习和图计算等</li></ul><img src="images/image-20201207132254729.png" alt="image-20201207132254729" style="zoom:50%;"></blockquote><img src="images/image-20201207132432340.png" alt="image-20201207132432340" style="zoom:50%;"><p><strong>应用场景：</strong></p><p><img src="images/image-20201207132506555.png" alt="image-20201207132506555"></p><h2 id="运行架构"><a href="#运行架构" class="headerlink" title="运行架构"></a>运行架构</h2><h3 id="概述和架构设计"><a href="#概述和架构设计" class="headerlink" title="概述和架构设计"></a>概述和架构设计</h3><p>RDD：<strong>弹性分布式数据集</strong>，是分布式内存，提供高度受限的共享内存模型（只读），一种数据抽象</p><p>DAG：有向无环图，反映RDD之间依赖关系，RDD之间一次又一次操作生成了有向无环图</p><p>Executor：运行在工作节点的一个<strong>进程</strong>，负责运行Task</p><p>Task：运行在Executor上工作单元</p><p>Application：用户编写的Spark应用程序</p><p>Job：包含多个RDD及作用于相应RDD上各种操作</p><p>stage：Job基本调度单位，一个Job分为多组Task，每组Task被称为Stage，或者也被称为TaskSet，代表一组关联的、相互之间没有Shuffle依赖关系的任务组成的任务集</p><h4 id="运行架构-1"><a href="#运行架构-1" class="headerlink" title="运行架构"></a>运行架构</h4><img src="images/image-20201207133223594.png" alt="image-20201207133223594" style="zoom:67%;"><blockquote><ul><li>集群资源管理器负责对整个应用程序的资源分配和调度，CPU内存带宽，可以自带、或者yarn或者mesos</li><li>Worker Node负责运行具体任务</li><li>Driver类似管家，负责应用控制，对任务阶段拆解</li></ul></blockquote><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li><p><strong>Executor采用多线程来执行具体任务</strong>，减少任务的启动开销</p></li><li><p>Executor存在一个BlockManager存储模块，<strong>将内存和磁盘共同作为存储设备</strong>，有效减少IO开销</p></li></ul><h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><img src="images/image-20201207133438254.png" alt="image-20201207133438254" style="zoom: 67%;"><blockquote><p>一个Application由一个Driver和若干个Job构成，一个Job由多个stage构成，一个stage由多个没有shuffle关系的Task组成</p><img src="images/image-20201207133726689.png" alt="image-20201207133726689" style="zoom:67%;"><p>当执行一个Application，Driver会向集群管理器申请资源，启动Executor并向其发送应用程序代码和文件，然后在Executor上执行Task，运行结束后，执行结果返回给Driver，或者写到HDFS或其他数据库中</p></blockquote><h3 id="Spark运行基本流程"><a href="#Spark运行基本流程" class="headerlink" title="Spark运行基本流程"></a>Spark运行基本流程</h3><img src="images/image-20201207134833580.png" alt="image-20201207134833580" style="zoom: 67%;"><blockquote><ul><li><p>为应用构建起基本的运行环境，即由Driver创建一个<strong>SparkContext（指挥官）</strong>进行<strong>资源的申请、任务的分配和监控，与资源管理器不断沟通</strong>。</p><img src="images/image-20201214111754722.png" alt="image-20201214111754722" style="zoom:50%;"></li><li><p>资源管理器为Executor分配资源，并启动Executor进程，启动后不断汇报资源使用情况</p><img src="images/image-20201214111814311.png" alt="image-20201214111814311" style="zoom:50%;"></li><li><p>SparkContext（Driver生成，管家，连接集群的通道）<strong>根据RDD的依赖构建DAG图（代码就是对RDD一次次操作）</strong>，DAG图提交给DAGScheduler解析成Stage，然后把一个个TaskSet提交给底层调度器TaskScheduler处理</p><img src="images/image-20201214111911415.png" alt="image-20201214111911415" style="zoom:50%;"></li><li><p>Executor向SparkContext申请Task，TaskScheduler将Task发放给Executor运行并提供应用程序代码</p></li><li><p>Task在Executor上运行把执行结果反馈给TaskScheduler，然后反馈给DAGScheduler，运行完毕后写入数据并释放所有资源</p><img src="images/image-20201214111954742.png" alt="image-20201214111954742" style="zoom:50%;"><p>每个阶段若干个任务，然后把各个阶段提交给Task Scheduler负责分发任务，由Worker Node主动申请运行，根据申请情况，把任务扔到对应node上，让进程派线程执行（保证计算向数据靠拢）</p><img src="images/image-20201214112143169.png" alt="image-20201214112143169" style="zoom:50%;"><p>任务运行后，得到结果反馈</p><img src="images/image-20201214112301347.png" alt="image-20201214112301347" style="zoom:50%;"></li></ul></blockquote><img src="images/image-20201207163031364.png" alt="image-20201207163031364" style="zoom: 50%;"><blockquote><p>数据本地性：执行计算时候，让计算和数据靠拢，让Task靠近数据所在运行</p><p>推测执行：当资源调光，需要判断是否迁移，根据迁移代价和等待代价</p></blockquote><h3 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h3><h4 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h4><p>迭代计算需要不同计算阶段重用中间结果，而且MapReduce的磁盘读写开销大</p><blockquote><p>而RDD提供了一种抽象的数据结构；不必担心底层数据的分布特性，只需要具体的应用逻辑表达为一系列转换处理；不同RDD之间的转换操作形<strong>成依赖，可以实现管道化</strong>，避免中间数据存储</p></blockquote><ul><li><p>RDD就是一个分布式对象集合，本质上是一个<strong>只读</strong>的分区记录集合，每个RDD可分成多个分区，每个分区就是一个数据集片段，并且一个RDD的不同分区可以被保存到集群中不同的节点上，<strong>从而可以在集群中的不同节点进行并行计算</strong></p><blockquote><p>就是因为是只读，因此RDD提供的是一种<strong>高度受限的共享内存模型</strong>，即RDD是只读的记录分区的集合，不能直接修改，<em>只能基于稳定的物理存储中的数据集创建RDD，或者通过在其他RDD上执行确定的转换操作如map、join、group by而创建得到新的RDD</em></p></blockquote></li><li><p>RDD提供了一组丰富的操作支持常见的数据运算，分为动作（action）和转换(transformation)，提供的转换接口非常简单，是粗粒度的数据转换操作，不是针对某个数据项的细粒度修改，因此不适合爬虫</p><blockquote><p>转换类型的操作：<strong>只记录</strong>转换的轨迹，而不进行真正的计算。只进行粗粒度的转换，即一次只能针对RDD全集进行转换</p><p>动作类型的操作：才进行从头到尾的计算</p></blockquote></li><li><p>表面上RDD功能受限，实际上可以高效表达许多框架的编程模型</p></li></ul><p><strong>典型执行过程：</strong></p><ul><li><p>RDD<strong>读入</strong>外部数据源进行创建</p></li><li><p>RDD经过系列转换操作每次都会产生不同的RDD供给下一个转换操作使用</p></li><li><p>最后一个RDD经过动作操作进行转换并输出到<strong>外部数据源</strong></p><img src="images/image-20201207164121220.png" alt="image-20201207164121220" style="zoom: 25%;"><p><strong>惰性机制</strong>，只有最后动作执行才生成结果，<strong>这一系列处理称为一个Lineage血缘关系，即DAG拓扑排序结果</strong></p></li></ul><blockquote><p>惰性调用、管道化、避免同步等待、不需要保存中间结果、每次操作变得简单</p></blockquote><img src="images/image-20201214113544071.png" alt="image-20201214113544071" style="zoom:50%;"><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>高效计算：</p><ul><li><p>高效的容错机制</p><blockquote><p>由于现有的容错机制：数据复制或者记录日志（事务机制），<strong>数据密集型应用代价非常高</strong></p><p>RDD的血缘关系、重新计算丢失分区、<strong>无需回滚系统</strong>、重算过程在不同节点之间<strong>并行</strong>、只记录粗粒度操作。天然容错机制</p></blockquote></li><li><p><strong>中间结果持久化到内存</strong>，数据在内存中的多个RDD操作之间进行传递， 避免了不必要的读写磁盘开销</p><img src="images/image-20201214114556088.png" alt="image-20201214114556088" style="zoom:50%;"></li><li><p>存放的数据可以是Java对象，避免了不必要的对象序列化和反序列化</p></li></ul><h4 id="依赖关系和运行过程"><a href="#依赖关系和运行过程" class="headerlink" title="依赖关系和运行过程"></a>依赖关系和运行过程</h4><p><strong>依赖关系</strong>：窄依赖与宽依赖</p><blockquote><p>RDD之间的依赖关系是划分stage的依据</p></blockquote><img src="images/image-20201207165019890.png" alt="image-20201207165019890" style="zoom:50%;"><blockquote><p>窄依赖：表现为一个父RDD的分区对应于一个子RDD的分区，或多个父RDD的分区对应于一个子RDD的分区</p><p>宽依赖：表现为存在一个父RDD的一个分区对应于一个子RDD的多个分区，只要发生shuffle（大量的网络之间的数据分发）则是宽依赖</p></blockquote><p>Spark通过分析各个RDD的依赖关系生成DAG；再通过分析各个RDD的分区之间依赖关系划分stage，<strong>具体方法</strong>如下</p><ul><li>在DAG中进行<strong>反向解析</strong>，遇到宽依赖断开</li><li>遇到窄依赖把当前的RDD加入到stage中</li><li>将窄依赖尽量划分在同一个stage中，可以实现流水线计算，从而使得数据可以直接在内存中进行变换，避免了磁盘IO开销</li></ul><blockquote><p>由于：<strong>窄依赖可以进行流水线优化，宽依赖不能进行流水线优化</strong></p><p>优化原理：fork/join机制，fork/join是并行执行任务的框架。为了并行执行，fork到不同机器一起执行，再将结果进行join，每次转换都进行一次fork/join。因此对于这种的转换进行优化，如例：</p><p>取消不必要的路障，能够流水线尽量流水线，窄依赖就不需要等待</p><img src="images/image-20201214120411122.png" alt="image-20201214120411122" style="zoom: 33%;"><img src="images/image-20201214120422975.png" alt="image-20201214120422975" style="zoom:33%;"><p>上为窄依赖，下为宽依赖，进行了一次shuffle</p><img src="images/image-20201214120648262.png" alt="image-20201214120648262" style="zoom:33%;"></blockquote><p><strong>划分的stage分为</strong></p><ul><li>ShuffleMapStage：不是最终的stage，所以输出一定经过shuffle过程，并作为后续stage的输入。以shuffle为输出边界，其输入边界可以是从外部获取数据，也可以是另一个shuffleMapStage的输出其输出可以是另一个stage的开始。在一个job可以没有该stage</li><li>ResultStage：最终的stage，无输出，直接产生结果或存储。输入边界可以是从外部获取数据，也可以是另一个shufflemapstage输出。一个job必定有该stage，至少含一个。</li></ul><img src="images/image-20201207183149765.png" alt="image-20201207183149765" style="zoom:50%;"><h2 id="SparkSQL"><a href="#SparkSQL" class="headerlink" title="SparkSQL"></a>SparkSQL</h2><p>hive on spark：shark</p><blockquote><p>shark沿用hive中各个组件，完成SQL解析，只有在最后物理计算时候生成Spark程序</p><p><strong>不足：</strong></p><ul><li>执行计划完全依赖于hive，不方便添加新的优化策略</li><li>spark线程级别并行，而MapReduce是进程并行，因此兼容上存在线程安全问题，需要用另外一套独立维护的打了补丁的Hive源码分支</li></ul><p>由此有了SparkSQL</p><img src="images/image-20201207184212479.png" alt="image-20201207184212479" style="zoom: 50%;"><img src="images/image-20201207184332530.png" alt="image-20201207184332530" style="zoom:50%;"></blockquote><p>Spark SQL增加SchemaRDD让用户在Spark SQL中执行SQL语句</p><h2 id="部署和应用"><a href="#部署和应用" class="headerlink" title="部署和应用"></a>部署和应用</h2><p><strong>三种部署：</strong></p><ul><li>standalone：slot为资源分配单位，自带集群资源管理器</li><li>spark on mesos</li><li>spark on yarn</li></ul><p><strong>应用</strong></p><ul><li>采用hadoop+storm部署方式</li></ul><img src="images/image-20201207191723260.png" alt="image-20201207191723260" style="zoom:50%;"><blockquote><p>实时通过storm做流式处理，hadoop批量处理</p><p>但繁琐，采用spark</p></blockquote><ul><li>spark</li></ul><blockquote><p>用Streaming做实时数据处理分析，批量计算用spark，交互式用sparkSQL，实现一站式服务</p><img src="images/image-20201207191835131.png" alt="image-20201207191835131" style="zoom:50%;"></blockquote><ul><li><p>还可用hadoop+spark，因为一些hadoop的功能spark无法取代。</p><p>可以实现资源按需伸缩；不同负载应用混搭，集群利用率高；共享底层存储，避免数据跨集群迁移</p><img src="images/image-20201207192021460.png" alt="image-20201207192021460" style="zoom:50%;"></li></ul><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/spark</span><br><span class="line">bin/spark-shell</span><br></pre></td></tr></table></figure><img src="images/image-20201210103422953.png" alt="image-20201210103422953" style="zoom:67%;"><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/spark-shell --master &lt;master-url&gt;</span><br></pre></td></tr></table></figure><blockquote><p>master-url：</p><ul><li><p>local：一个worker线程运行spark</p></li><li><p>local|*|：使用逻辑CPU个数数量的线程运行spark。如2个物理CPU，每个CPU有2给Core则为4，<strong>也是默认进入模式</strong></p></li><li><p>spark:HOST:PORT：独立集群模式，如spark://localhost:7077</p></li><li><p>yarn的两种模式：</p><p>yarn-client：指挥部在客户端，不可关。调试程序时可用</p><p>yarn-cluster：在集群中放指挥部。进入生产环境时可用</p></li><li><p>mesos:HOST:PORT：mesos集群模式</p></li></ul><img src="images/image-20201214122846707.png" alt="image-20201214122846707" style="zoom:50%;"><img src="images/image-20201214122857312.png" alt="image-20201214122857312" style="zoom:50%;"></blockquote><h3 id="加载text文件"><a href="#加载text文件" class="headerlink" title="加载text文件"></a>加载text文件</h3><p>spark创建sc，可以加载本地文件和HDFS文件创建RDD</p><blockquote><p>加载HDFS文件和本地文件都是使用textFile，区别是添加<strong>前缀</strong>(hdfs://和file:///)进行标识</p></blockquote><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> textFile = sc.textFile(<span class="string">&quot;file:///usr/local/spark/README.md&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="简单RDD操作"><a href="#简单RDD操作" class="headerlink" title="简单RDD操作"></a>简单RDD操作</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取RDD文件textFile的第一行内容</span></span><br><span class="line">textFile.first()</span><br><span class="line"><span class="comment">//获取RDD文件textFile所有项的计数</span></span><br><span class="line">textFile.count()</span><br><span class="line"><span class="comment">//抽取含有“Spark”的行，返回一个新的RDD</span></span><br><span class="line"><span class="keyword">val</span> lineWithSpark = textFile.filter(line =&gt; line.contains(<span class="string">&quot;Spark&quot;</span>))</span><br><span class="line"><span class="comment">//统计新的RDD的行数</span></span><br><span class="line">lineWithSpark.count()</span><br></pre></td></tr></table></figure><p>可以通过组合RDD操作进行组合，可以实现简易MapReduce操作</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找出文本中每行的最多单词数</span></span><br><span class="line">textFile.map(line =&gt; line.split(<span class="string">&quot; &quot;</span>).size).reduce((a, b) =&gt; <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b)</span><br></pre></td></tr></table></figure><blockquote><p>在Spark程序中必须创建一个SparkContext对象，该对象是Spark程序的入口，负责创建RDD、启动任务等</p><p>在启动Spark Shell后，该对象会自动创建，可以通过变量sc进行访问</p><p><img src="images/image-20201210103829452.png" alt="image-20201210103829452"></p></blockquote><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><img src="images/image-20201210055519214.png" alt="image-20201210055519214" style="zoom:67%;"><h4 id="transformation"><a href="#transformation" class="headerlink" title="transformation"></a>transformation</h4><img src="images/image-20201210055541577.png" alt="image-20201210055541577" style="zoom:67%;"><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">:quit</span><br></pre></td></tr></table></figure><h2 id="独立应用程序编程"><a href="#独立应用程序编程" class="headerlink" title="独立应用程序编程"></a>独立应用程序编程</h2><h3 id="使用sbt对Scala独立应用程序进行编译打包"><a href="#使用sbt对Scala独立应用程序进行编译打包" class="headerlink" title="使用sbt对Scala独立应用程序进行编译打包"></a>使用sbt对Scala独立应用程序进行编译打包</h3><ol><li><p>Scala应用程序</p><p> 应用程序根目录 </p><p><img src="images/image-20201210060328542.png" alt="image-20201210060328542"></p><blockquote><p>scala文件下建代码文件</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SimpleApp.scala */</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkContext</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkContext</span>._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SimpleApp</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">            <span class="keyword">val</span> logFile = <span class="string">&quot;file:///usr/local/spark/README.md&quot;</span> <span class="comment">// Should be some file on your system</span></span><br><span class="line">            <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;Simple Application&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)<span class="comment">//指挥官</span></span><br><span class="line">            <span class="keyword">val</span> logData = sc.textFile(logFile, <span class="number">2</span>).cache()<span class="comment">//底层文本文件加载进来后生成RDD 在内存当中进行缓存</span></span><br><span class="line">            <span class="keyword">val</span> numAs = logData.filter(line =&gt; line.contains(<span class="string">&quot;a&quot;</span>)).count()<span class="comment">//logData已经是个RDD lambda表达式</span></span><br><span class="line">            <span class="keyword">val</span> numBs = logData.filter(line =&gt; line.contains(<span class="string">&quot;b&quot;</span>)).count()</span><br><span class="line">            println(<span class="string">&quot;Lines with a: %s, Lines with b: %s&quot;</span>.format(numAs, numBs))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不同于 Spark shell，独立应用程序需要通过 <code>val sc = new SparkContext(conf)</code> 初始化 SparkContext，SparkContext 的参数 SparkConf 包含了应用程序的信息。 </p></blockquote></li><li><p>该程序依赖 Spark API，因此需要通过 sbt 进行编译打包。 在~/sparkapp这个目录中新建文件simple.sbt（.sbt即可），命令如下： </p><p><img src="images/image-20201210060518843.png" alt="image-20201210060518843"></p><p>内容，给出相关依赖说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name :&#x3D; &quot;Simple Project&quot;</span><br><span class="line">version :&#x3D; &quot;1.0&quot;</span><br><span class="line">scalaVersion :&#x3D; &quot;2.11.12&quot;</span><br><span class="line">libraryDependencies +&#x3D; &quot;org.apache.spark&quot; %% &quot;spark-core&quot; % &quot;2.4.0&quot;</span><br></pre></td></tr></table></figure><blockquote><p>%%：不指定版本</p><p>%：需要指定版本</p></blockquote></li><li><p>sbt打包scala程序</p><p>查看当前目录结构</p><img src="images/image-20201210105652926.png" alt="image-20201210105652926" style="zoom:50%;"><p>打包：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/sbt/sbt package</span><br></pre></td></tr></table></figure></li><li><p>生成jar包位置在target，通过 spark-submit 运行程序</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/spark/bin/spark-submit --class &quot;SimpleApp&quot; ~/sparkapp/target/scala-2.11/simple-project_2.11-1.0.jar</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令执行后会输出太多信息，可以不使用上面命令，而使用下面命令查看想要的结果</span></span><br><span class="line">/usr/local/spark/bin/spark-submit --class &quot;SimpleApp&quot; ~/sparkapp/target/scala-2.11/simple-project_2.11-1.0.jar 2&gt;&amp;1 | grep &quot;Lines with a:&quot;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用Maven对Java独立应用程序进行编译打包"><a href="#使用Maven对Java独立应用程序进行编译打包" class="headerlink" title="使用Maven对Java独立应用程序进行编译打包"></a>使用Maven对Java独立应用程序进行编译打包</h3><ol><li><p>java应用程序</p><p>程序根目录</p><p><img src="images/image-20201210064136385.png" alt="image-20201210064136385"></p><p>main/java 下建立一个名为 SimpleApp.java 的文件，内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** SimpleApp.java ***/</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.function.Function;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.SparkConf;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String logFile = <span class="string">&quot;file:///usr/local/spark/README.md&quot;</span>; <span class="comment">// Should be some file on your system</span></span><br><span class="line">        SparkConf conf=<span class="keyword">new</span> SparkConf().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;SimpleApp&quot;</span>);</span><br><span class="line">        JavaSparkContext sc=<span class="keyword">new</span> JavaSparkContext(conf);</span><br><span class="line">        JavaRDD&lt;String&gt; logData = sc.textFile(logFile).cache(); </span><br><span class="line">        <span class="keyword">long</span> numAs = logData.filter(<span class="keyword">new</span> Function&lt;String, Boolean&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(String s)</span> </span>&#123; <span class="keyword">return</span> s.contains(<span class="string">&quot;a&quot;</span>); &#125;</span><br><span class="line">        &#125;).count(); </span><br><span class="line">        <span class="keyword">long</span> numBs = logData.filter(<span class="keyword">new</span> Function&lt;String, Boolean&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(String s)</span> </span>&#123; <span class="keyword">return</span> s.contains(<span class="string">&quot;b&quot;</span>); &#125;</span><br><span class="line">        &#125;).count(); </span><br><span class="line">        System.out.println(<span class="string">&quot;Lines with a: &quot;</span> + numAs + <span class="string">&quot;, lines with b: &quot;</span> + numBs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>该程序依赖Spark Java API,因此需要通过Maven进行编译打包。在./sparkapp2目录中新建文件pom.xml，命令如下： </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.edu.xmu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simple-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Simple Project<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.com/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- Spark dependency --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li><li><p>使用Maven打Java程序</p><p><img src="images/image-20201210110856328.png" alt="image-20201210110856328"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/sparkapp2</span><br><span class="line">/usr/local/maven/bin/mvn package</span><br></pre></td></tr></table></figure></li><li><p>通过spark-submit 运行程序</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/spark/bin/spark-submit --class &quot;SimpleApp&quot; ~/sparkapp2/target/simple-project-1.0.jar</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令执行后会输出太多信息，可以不使用上面命令，而使用下面命令查看想要的结果</span></span><br><span class="line">/usr/local/spark/bin/spark-submit --class &quot;SimpleApp&quot; ~/sparkapp2/target/simple-project-1.0.jar 2&gt;&amp;1 | grep &quot;Lines with a&quot;</span><br></pre></td></tr></table></figure><h3 id="使用Maven对Scala独立应用程序进行编译打包"><a href="#使用Maven对Scala独立应用程序进行编译打包" class="headerlink" title="使用Maven对Scala独立应用程序进行编译打包"></a>使用Maven对Scala独立应用程序进行编译打包</h3></li><li><p>Scala应用程序</p><p><img src="images/image-20201210064404674.png" alt="image-20201210064404674"></p><p>main/scala 下建立一个名为 SimpleApp.scala 的文件，内容：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SimpleApp.scala */</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkContext</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkContext</span>._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SimpleApp</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">            <span class="keyword">val</span> logFile = <span class="string">&quot;file:///usr/local/spark/README.md&quot;</span> <span class="comment">// Should be some file on your system</span></span><br><span class="line">            <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;Simple Application&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">            <span class="keyword">val</span> logData = sc.textFile(logFile, <span class="number">2</span>).cache()</span><br><span class="line">            <span class="keyword">val</span> numAs = logData.filter(line =&gt; line.contains(<span class="string">&quot;a&quot;</span>)).count()</span><br><span class="line">            <span class="keyword">val</span> numBs = logData.filter(line =&gt; line.contains(<span class="string">&quot;b&quot;</span>)).count()</span><br><span class="line">            println(<span class="string">&quot;Lines with a: %s, Lines with b: %s&quot;</span>.format(numAs, numBs))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>不同于 Spark shell，独立应用程序需要通过 <code>val sc = new SparkContext(conf)</code> 初始化 SparkContext，SparkContext 的参数 SparkConf 包含了应用程序的信息。 </p></blockquote></li><li><p>使用Maven进行编译打包</p><p><img src="images/image-20201210133606699.png" alt="image-20201210133606699"></p><p>该程序依赖Spark Java API,因此需要通过Maven进行编译打包。在./sparkapp3目录中新建文件pom.xml，如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.edu.xmu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simple-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Simple Project<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.com/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- Spark dependency --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/main/scala<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-scala-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scalaVersion</span>&gt;</span>2.11.12<span class="tag">&lt;/<span class="name">scalaVersion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">args</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span>&gt;</span>-target:jvm-1.8<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">args</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>打包：</p><p><img src="images/image-20201210064613262.png" alt="image-20201210064613262"></p></li><li><p>通过spark-submit运行程序</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/spark/bin/spark-submit --class &quot;SimpleApp&quot; ~/sparkapp3/target/simple-project-1.0.jar</span><br><span class="line"><span class="meta">#</span><span class="bash">上面命令执行后会输出太多信息，可以不使用上面命令，而使用下面命令查看想要的结果</span></span><br><span class="line">/usr/local/spark/bin/spark-submit --class &quot;SimpleApp&quot; ~/sparkapp3/target/simple-project-1.0.jar 2&gt;&amp;1 | grep &quot;Lines with a:&quot;</span><br></pre></td></tr></table></figure><blockquote><p>其他参数：</p><img src="images/image-20201214124640721.png" alt="image-20201214124640721" style="zoom:50%;"></blockquote></li></ol><p>集群环境搭建：</p><p><a href="https://www.icourse163.org/learn/XMU-1205811805?tid=1460184441#/learn/content?type=detail&amp;id=1236291022&amp;sm=1">https://www.icourse163.org/learn/XMU-1205811805?tid=1460184441#/learn/content?type=detail&amp;id=1236291022&amp;sm=1</a></p><h2 id="RDD编程"><a href="#RDD编程" class="headerlink" title="RDD编程"></a>RDD编程</h2><p>Spark的数据抽象：RDD</p><h3 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h3><ul><li><p>从文件系统中加载数据</p><p><strong>调用sparkcontext提供的.textFile()方法</strong>，读取数据生成内存中的RDD</p><blockquote><p>支持的数据类型有本地文件系统（file 三斜杠）、分布式文件系统HDFS（hdfs://）、Amazon S3等</p></blockquote><img src="images/image-20201214131115717.png" alt="image-20201214131115717" style="zoom:50%;"><img src="images/image-20201214131151513.png" alt="image-20201214131151513" style="zoom:50%;"><blockquote><p>文本文件中每一行为RDD中一个元素</p></blockquote><img src="images/image-20201214131300745.png" alt="image-20201214131300745" style="zoom:50%;"><blockquote><p>下两行等价的条件是用户名为hadoop</p></blockquote></li><li><p>通过并行集合（数组）</p><p><strong>调用SparkContext对象提供的Parallelize方法</strong></p><img src="images/image-20201214131433233.png" alt="image-20201214131433233" style="zoom:50%;"><img src="images/image-20201214131515827.png" alt="image-20201214131515827" style="zoom:50%;"><img src="images/image-20201214131455601.png" alt="image-20201214131455601" style="zoom:50%;"></li></ul><h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><h4 id="transformation-1"><a href="#transformation-1" class="headerlink" title="transformation"></a>transformation</h4><ol><li><p>filter</p><img src="images/image-20201214144412031.png" alt="image-20201214144412031" style="zoom: 67%;"></li><li><p>map</p><img src="images/image-20201214144548579.png" alt="image-20201214144548579" style="zoom:67%;"></li><li><p>flatMap</p><img src="images/image-20201214144907279.png" alt="image-20201214144907279" style="zoom:67%;"></li><li><p>groupByKey()</p><img src="images/image-20201214145031235.png" alt="image-20201214145031235" style="zoom:67%;"></li><li><p>reduceByKey(func)</p><img src="images/image-20201214145126930.png" alt="image-20201214145126930" style="zoom:67%;"></li></ol><h4 id="action-1"><a href="#action-1" class="headerlink" title="action"></a>action</h4><ol><li>count</li><li>collect</li><li>first</li><li>take</li><li>reduce</li><li>foreach</li></ol><blockquote><p>转换操作具备延后性，直到遇到动作操作才从头到尾开始计算</p></blockquote><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>允许用户把<strong>反复使用数据集</strong>持久化到内存，</p><img src="images/image-20201214150110609.png" alt="image-20201214150110609" style="zoom:67%;"><blockquote><p>一个Spark应用程序提交上来，生成多个job，每个job包含多个stage，每个stage包含多个任务</p><p>每个action储发，产生一个job</p></blockquote><blockquote><p><strong>如何持久化</strong>？使用persist()对一个RDD标记为持久化，也就是说并不是马上计算生成RDD并把他持久化，而是到动作类型操作执行时才真正持久化</p></blockquote><ul><li><strong>.persist(MEMORY_ONLY)**：只在内存，不够替换旧（等价于</strong>.cache()**）</li><li>**.persist(MEMORY_AND_DISK)**：如果内存不足，存放底层磁盘</li><li>**.unpersist()**：手动把持久化的RDD从缓存中移除</li></ul><h3 id="分区-1"><a href="#分区-1" class="headerlink" title="分区"></a>分区</h3><h4 id="分区作用和原则"><a href="#分区作用和原则" class="headerlink" title="分区作用和原则"></a>分区作用和原则</h4><p><strong>作用</strong>：</p><ul><li>增加并行度，把庞大RDD分区，散布在不同机器节点，可以分布式并行计算</li><li>减小通信开销，</li></ul><p><strong>原则</strong>：</p><ul><li><p>分区个数尽量等于集群中CPU核心数目。这样才可进行真正并行</p><blockquote><p>对于spark多个模式，可以设置具体参数值设置</p><p>spark.default.parallelism</p><p>本地：local</p><p>mesos：默认分区数目为8</p><p>standalone、yarn：集群中所有CPU核心数目总和与默认值取最大</p></blockquote></li></ul><h4 id="分区设置方法"><a href="#分区设置方法" class="headerlink" title="分区设置方法"></a>分区设置方法</h4><p>语法格式</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">sc.textFile(path, partitionNum)</span><br></pre></td></tr></table></figure><ul><li><p>使用reparitition方法重新设置分区个数</p><img src="images/image-20201214151611237.png" alt="image-20201214151611237" style="zoom:67%;"></li></ul><blockquote><p>分区有：</p><ul><li><p>自定义分区</p><ol><li>定义Partitioner类</li><li>继承org.apache.spark.Partitioner</li><li>覆盖方法：<ul><li>numPartitions：Int 返回创建出来的分区个数</li><li>getPatition(key:Any):Int 返回给定键的分区编号</li><li>equals()：java判断相等性的标准方法</li></ul></li></ol><img src="images/image-20201214152156542.png" alt="image-20201214152156542" style="zoom:67%;"><p>使用<strong>单例对象</strong>，程序的入口函数，首先对data进行转换变为键值对(_,1)<strong>因为partitioner自定义分区类只针对键值对</strong></p><img src="images/image-20201214155146812.png" alt="image-20201214155146812" style="zoom:67%;"></li><li><p>HashPartitioner</p></li><li><p>RangePartitioner</p></li></ul></blockquote><h3 id="键值对RDD"><a href="#键值对RDD" class="headerlink" title="键值对RDD"></a>键值对RDD</h3><h4 id="创建：-1"><a href="#创建：-1" class="headerlink" title="创建："></a>创建：</h4><ul><li>从文件加载、flatMap</li></ul><h4 id="常见转换操作"><a href="#常见转换操作" class="headerlink" title="常见转换操作"></a>常见转换操作</h4><ul><li><p>reduceByKey(func)</p><p>使用func函数合并具有相同键的值（进行汇总求和）</p></li><li><p>groupByKey()</p><p>把具有相同键的值分组</p></li><li><p>keys</p><p>把Pair RDD中的key返回形成一个新的RDD</p></li><li><p>values</p><p>Pair RDD中的value返回形成一个新的RDD</p></li><li><p>sortByKey()</p><p>返回一个根据键排序的RDD（默认升序）</p></li><li><p>sortBy([_ . _ 1,_ . _2],[true,false])</p></li><li><p>mapValues(func)</p><p>对键值对RDD中的每个value都应用一个函数，可以不变</p></li><li><p>join</p><p>把<strong>几个RDD</strong>当中元素key相同的连接</p></li><li><p>combineByKey</p></li></ul><h3 id="数据读写-1"><a href="#数据读写-1" class="headerlink" title="数据读写"></a>数据读写</h3><h4 id="文件系统数据读写"><a href="#文件系统数据读写" class="headerlink" title="文件系统数据读写"></a>文件系统数据读写</h4><h5 id="本地文件系统"><a href="#本地文件系统" class="headerlink" title="本地文件系统"></a>本地文件系统</h5><p><img src="images/image-20201215113048065.png" alt="image-20201215113048065"></p><p>惰性机制：即使输入错误的语句，也不会马上报错，除非到动作操作</p><blockquote><p>写入文件时只能输入指定目录，即时.txt也无法指定文件，读取时可以输入目录，系统读取所有文件生成RDD</p><p>结果会返回part-0000、0001，0000说明未分区</p></blockquote><h5 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h5><ul><li>读入</li></ul><p><img src="images/image-20201215113224989.png" alt="image-20201215113224989"></p><p>与下等价</p><p><img src="images/image-20201215113306333.png" alt="image-20201215113306333"></p><ul><li>写出</li></ul><img src="images/image-20201215113323379.png" alt="image-20201215113323379" style="zoom:67%;"><blockquote><p>其为HDFS目录</p></blockquote><h4 id="json文件数据读写"><a href="#json文件数据读写" class="headerlink" title="json文件数据读写"></a>json文件数据读写</h4><ul><li>读入</li></ul><p><img src="images/image-20201215113448419.png" alt="image-20201215113448419"></p><ul><li>解析</li></ul><p>使用：scala.util.parsing.json.JSON自带库</p><blockquote><p><strong>JSON.parseFull(jsonString:String)函数解析</strong></p><ul><li>成功返回Some(map:Map[String,Any])</li><li>失败返回None</li></ul></blockquote><p><img src="images/image-20201215113731201.png" alt="image-20201215113731201"></p><blockquote><p>依次遍历进行解析</p></blockquote><h4 id="读写HBase数据"><a href="#读写HBase数据" class="headerlink" title="读写HBase数据"></a>读写HBase数据</h4><p>bug:</p><p><a href="https://blog.csdn.net/qq_43473753/article/details/106263313">https://blog.csdn.net/qq_43473753/article/details/106263313</a></p><h2 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h2><p>只采用了Shark中的将SQL转换成抽象语法树，其他由Spark SQL自己来做</p><ul><li><p>Spark SQL的数据抽象：<strong>DataFrame</strong></p><blockquote><p>认为是带有Schema信息的RDD</p></blockquote></li><li><p>Spark SQL支持关系查询、能够处理结构化、半结构化和非结构化数据、支持复杂分析算法</p><p>DataFrame就是一些关系型表格</p><img src="images/image-20201222223548584.png" alt="image-20201222223548584" style="zoom:50%;"></li></ul><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><img src="images/image-20201222223732807.png" alt="image-20201222223732807" style="zoom: 80%;"><p>Spark SQL是对DataFrame进行一次次转换</p><img src="images/image-20201222223837046.png" alt="image-20201222223837046" style="zoom:50%;"><h4 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h4><ol><li><p>Spark 2.0后使用SparkSession生成，因此需要构建SparkSession对象</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"><span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().getOrCreate()</span><br></pre></td></tr></table></figure><blockquote><p>交互式环境已经默认建好该对象，即spark</p></blockquote></li><li><p>创建DataFrame</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> spark.implicits._<span class="comment">//导入隐式转换的包</span></span><br><span class="line"><span class="comment">//不同格式的文件均可读入，如json、csb、parquet，生成DataFrame</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>json</li></ul><img src="images/image-20201222224627685.png" alt="image-20201222224627685" style="zoom:50%;"><ul><li>parquet</li></ul><img src="images/image-20201222224645546.png" alt="image-20201222224645546" style="zoom:50%;"><ul><li>csv</li></ul><img src="images/image-20201222224653564.png" alt="image-20201222224653564" style="zoom:50%;"></blockquote></li></ol><h4 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h4><p>df.show</p><h4 id="保存DataFrame"><a href="#保存DataFrame" class="headerlink" title="保存DataFrame"></a>保存DataFrame</h4><p>使用spark.write保存DataFrame</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.write.json(people.json)</span><br><span class="line">df.write.parquet(...)</span><br><span class="line">df.write.csv(...)</span><br><span class="line"><span class="comment">//format(&quot;..&quot;)可以转换格式</span></span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>打印模式信息：df.printSchema()</p></li><li><p>选择多列：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.select(df(<span class="string">&quot;name&quot;</span>),df(<span class="string">&quot;age&quot;</span>)+<span class="number">1</span>).show()</span><br></pre></td></tr></table></figure></li><li><p>条件过滤</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.filter(df(<span class="string">&quot;age&quot;</span>) &gt; <span class="number">20</span>).show()</span><br></pre></td></tr></table></figure></li><li><p>分组聚合</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.groupBy(<span class="string">&quot;age&quot;</span>).count().show()</span><br></pre></td></tr></table></figure></li><li><p>排序</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.sort(df(<span class="string">&quot;age&quot;</span>).desc).show()</span><br></pre></td></tr></table></figure></li><li><p>多列排序</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.sort(df(<span class="string">&quot;age&quot;</span>).desc, df(<span class="string">&quot;name&quot;</span>).asc).show()</span><br></pre></td></tr></table></figure><p>先对age降序对name升序</p></li><li><p>队列进行重命名</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.select(df(<span class="string">&quot;name&quot;</span>).as(<span class="string">&quot;username&quot;</span>), df(<span class="string">&quot;age&quot;</span>)).show()</span><br></pre></td></tr></table></figure></li></ul><h3 id="从RDD转换得到DataFrame"><a href="#从RDD转换得到DataFrame" class="headerlink" title="从RDD转换得到DataFrame"></a>从RDD转换得到DataFrame</h3><h4 id="利用反射机制推断RDD模式"><a href="#利用反射机制推断RDD模式" class="headerlink" title="利用反射机制推断RDD模式"></a>利用反射机制推断RDD模式</h4><p>文本到DataFrame，文本文件先转化为RDD再转化为DataFrame</p><p>在利用反射机制推断RDD模式时，需要首先定义一个case class(样例类)，因为，只有case class才能被Spark隐式地转换为DataFrame</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> org.apache.spark.sql.catalyst.encoders.<span class="type">ExpressionEncoder</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.catalyst.encoders.<span class="type">ExpressionEncoder</span></span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">import</span> org.apache.spark.sql.<span class="type">Encoder</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Encoder</span></span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">import</span> spark.implicits._  <span class="comment">//导入包，支持把一个RDD隐式转换为一个DataFrame</span></span><br><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Long</span></span>)  <span class="comment">//定义一个case class</span></span></span><br><span class="line"><span class="class"><span class="title">defined</span> <span class="title">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">val</span> <span class="title">peopleDF</span> </span>= spark.sparkContext.textFile(<span class="string">&quot;file:///usr/local/spark/examples/src/main/resources/people.txt&quot;</span>).map(_.split(<span class="string">&quot;,&quot;</span>)).map(attributes =&gt; <span class="type">Person</span>(attributes(<span class="number">0</span>), attributes(<span class="number">1</span>).trim.toInt)).toDF()<span class="comment">//文本文件加载进来生成一个RDD，经过map操作用逗号拆分然后生成对象</span></span><br><span class="line"><span class="comment">//case class是非常特殊自动定义伴生对象，通过定义伴生对象定义一个方法不需要new</span></span><br><span class="line"><span class="comment">//.toDF转为DataFrame，已经在内存中，是一个关系表</span></span><br><span class="line">peopleDF: org.apache.spark.sql.<span class="type">DataFrame</span> = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; peopleDF.createOrReplaceTempView(<span class="string">&quot;people&quot;</span>)  <span class="comment">//必须注册为临时表才能供下面的查询使用</span></span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">val</span> personsRDD = spark.sql(<span class="string">&quot;select name,age from people where age &gt; 20&quot;</span>)</span><br><span class="line"><span class="comment">//最终生成一个DataFrame，下面是系统执行返回信息</span></span><br><span class="line">personsRDD: org.apache.spark.sql.<span class="type">DataFrame</span> = [name: string, age: bigint]</span><br><span class="line">scala&gt; personsRDD.map(t =&gt; <span class="string">&quot;Name:&quot;</span>+t(<span class="number">0</span>)+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;Age:&quot;</span>+t(<span class="number">1</span>)).show()  <span class="comment">//DataFrame中的每个元素都是一行记录，包含name和age两个字段，分别用t(0)和t(1)来获取值</span></span><br><span class="line"> </span><br><span class="line">+------------------+</span><br><span class="line">|             value|</span><br><span class="line">+------------------+</span><br><span class="line">|<span class="type">Name</span>:<span class="type">Michael</span>,<span class="type">Age</span>:<span class="number">29</span>|</span><br><span class="line">|   <span class="type">Name</span>:<span class="type">Andy</span>,<span class="type">Age</span>:<span class="number">30</span>|</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><h4 id="编程方式定义RDD模式"><a href="#编程方式定义RDD模式" class="headerlink" title="编程方式定义RDD模式"></a>编程方式定义RDD模式</h4><p> 前面一直各个字段（name，age），所以当无法提前定义case class时，就需要采用编程方式定义RDD模式</p><ol><li>制作表头，即模式信息</li><li>制作表中记录</li><li>把表头和表中记录拼装在一起</li></ol><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> org.apache.spark.sql.types._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types._</span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">import</span> org.apache.spark.sql.<span class="type">Row</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Row</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//生成 RDD</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> peopleRDD = spark.sparkContext.textFile(<span class="string">&quot;file:///usr/local/spark/examples/src/main/resources/people.txt&quot;</span>)</span><br><span class="line">peopleRDD: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = file:<span class="comment">///usr/local/spark/examples/src/main/resources/people.txt MapPartitionsRDD[1] at textFile at &lt;console&gt;:26</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义一个模式字符串</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> schemaString = <span class="string">&quot;name age&quot;</span></span><br><span class="line">schemaString: <span class="type">String</span> = name age</span><br><span class="line"> </span><br><span class="line"><span class="comment">//根据模式字符串生成模式</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> fields = schemaString.split(<span class="string">&quot; &quot;</span>).map(fieldName =&gt; <span class="type">StructField</span>(fieldName, <span class="type">StringType</span>, nullable = <span class="literal">true</span>))</span><br><span class="line">fields: <span class="type">Array</span>[org.apache.spark.sql.types.<span class="type">StructField</span>] = <span class="type">Array</span>(<span class="type">StructField</span>(name,<span class="type">StringType</span>,<span class="literal">true</span>), <span class="type">StructField</span>(age,<span class="type">StringType</span>,<span class="literal">true</span>))</span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">val</span> schema = <span class="type">StructType</span>(fields)</span><br><span class="line">schema: org.apache.spark.sql.types.<span class="type">StructType</span> = <span class="type">StructType</span>(<span class="type">StructField</span>(name,<span class="type">StringType</span>,<span class="literal">true</span>), <span class="type">StructField</span>(age,<span class="type">StringType</span>,<span class="literal">true</span>))</span><br><span class="line"><span class="comment">//从上面信息可以看出，schema描述了模式信息，模式中包含name和age两个字段</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//对peopleRDD 这个RDD中的每一行元素都进行解析val peopleDF = spark.read.format(&quot;json&quot;).load(&quot;examples/src/main/resources/people.json&quot;)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">val</span> rowRDD = peopleRDD.map(_.split(<span class="string">&quot;,&quot;</span>)).map(attributes =&gt; <span class="type">Row</span>(attributes(<span class="number">0</span>), attributes(<span class="number">1</span>).trim))</span><br><span class="line">rowRDD: org.apache.spark.rdd.<span class="type">RDD</span>[org.apache.spark.sql.<span class="type">Row</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">3</span>] at map at &lt;console&gt;:<span class="number">29</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//表头和表中记录的拼装</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> peopleDF = spark.createDataFrame(rowRDD, schema)</span><br><span class="line">peopleDF: org.apache.spark.sql.<span class="type">DataFrame</span> = [name: string, age: string]</span><br><span class="line"> </span><br><span class="line"><span class="comment">//必须注册为临时表才能供下面查询使用</span></span><br><span class="line">scala&gt; peopleDF.createOrReplaceTempView(<span class="string">&quot;people&quot;</span>)</span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">val</span> results = spark.sql(<span class="string">&quot;SELECT name,age FROM people&quot;</span>)</span><br><span class="line">results: org.apache.spark.sql.<span class="type">DataFrame</span> = [name: string, age: string]</span><br><span class="line"> </span><br><span class="line">scala&gt; results.map(attributes =&gt; <span class="string">&quot;name: &quot;</span> + attributes(<span class="number">0</span>)+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;age:&quot;</span>+attributes(<span class="number">1</span>)).show()</span><br><span class="line">+--------------------+</span><br><span class="line">|               value|</span><br><span class="line">+--------------------+</span><br><span class="line">|name: <span class="type">Michael</span>,age:<span class="number">29</span>|</span><br><span class="line">|   name: <span class="type">Andy</span>,age:<span class="number">30</span>|</span><br><span class="line">| name: <span class="type">Justin</span>,age:<span class="number">19</span>|</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><p>法2：</p><img src="images/image-20210101212457730.png" alt="image-20210101212457730" style="zoom:67%;"><h3 id="使用Spark-SQL-读写数据库"><a href="#使用Spark-SQL-读写数据库" class="headerlink" title="使用Spark SQL 读写数据库"></a>使用Spark SQL 读写数据库</h3><ul><li>启动mysql服务</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service mysql start</span><br><span class="line">mysql -u -root -p</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database spark;</span><br><span class="line">use spark;</span><br><span class="line">crate table stu(id int(4), name char(20), gender char(4), age int(4));</span><br><span class="line">insert into stu values(1, &#39;Xueian&#39;, &#39;F&#39;, 23);</span><br><span class="line">select * from stu;</span><br></pre></td></tr></table></figure><ul><li>jdbc连接,驱动放于spark安装目录jars下</li><li>书写语句连接数据库</li></ul><blockquote><p>驱动跟着在命令行</p><img src="../../BigData/images/image-20210106184617038.png" alt="image-20210106184617038" style="zoom:67%;"></blockquote><ul><li><p>通过jdbc连接mysql数据库</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> jdbcDF = spark.read.format(<span class="string">&quot;jdbc&quot;</span>).</span><br><span class="line">|option(<span class="string">&quot;url&quot;</span>,<span class="string">&quot;jdbc:mysql://localhost:3306/spark&quot;</span>).</span><br><span class="line">|option(<span class="string">&quot;driver&quot;</span>,<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>).</span><br><span class="line">|option(<span class="string">&quot;dbtable&quot;</span>,<span class="string">&quot;stu&quot;</span>).</span><br><span class="line">|option(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>).</span><br><span class="line">|option(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;hadoop&quot;</span>).</span><br><span class="line">|load()</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">jdbcDF.show() <span class="comment">// 显示</span></span><br></pre></td></tr></table></figure></li><li><p>新增两条记录</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types_<span class="comment">// 表示模式</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Row</span><span class="comment">//封装行对象</span></span><br><span class="line"><span class="comment">// 学生信息</span></span><br><span class="line"><span class="keyword">val</span> studentRDD = spark.sparkContext.parallelize(<span class="type">Array</span>(<span class="string">&quot;3 Rongcheng M 26&quot;</span>,<span class="string">&quot;4 Guanhua M 27&quot;</span>)).map(_.split(<span class="string">&quot; &quot;</span>))</span><br></pre></td></tr></table></figure><p>表头与表中记录拼装</p><ul><li><p>获取表头</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置模式信息</span></span><br><span class="line"><span class="keyword">val</span> schema = <span class="type">StructType</span>(<span class="type">List</span>(<span class="type">StructField</span>(<span class="string">&quot;id&quot;</span>,<span class="type">IntegerType</span>,<span class="literal">true</span>),<span class="type">StructField</span>(<span class="string">&quot;name&quot;</span>,<span class="type">StringType</span>,<span class="literal">true</span>),<span class="type">StructField</span>(<span class="string">&quot;gender&quot;</span>,<span class="type">StringType</span>,<span class="literal">true</span>),<span class="type">StructField</span>(<span class="string">&quot;age&quot;</span>,<span class="type">IntegerType</span>,<span class="literal">true</span>)))</span><br><span class="line"><span class="comment">// 封装至List列表对象中，构成集合，把四个对象传入StructType类，生成模式信息得到表头schema</span></span><br></pre></td></tr></table></figure></li><li><p>表中记录</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成RDD对其进行拆分</span></span><br><span class="line"><span class="keyword">val</span> studentRDD = spark.sparkContext.parallelize(<span class="type">Array</span>(<span class="string">&quot;3 Rongcheng M 26&quot;</span>,<span class="string">&quot;4 Guanhua M 27&quot;</span>)).map(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="../../BigData/images/image-20210106190051816.png" alt="image-20210106190051816" style="zoom:67%;"><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Row对象，每个Row对象都是rowRDD中的一行</span></span><br><span class="line"><span class="comment">// 依次遍历转类型，作为Row构造器处理</span></span><br><span class="line"><span class="keyword">val</span> rowRDD = studentRDD.map(p=&gt;<span class="type">Row</span>(p(<span class="number">0</span>).toInt,p(<span class="number">1</span>).trim,p(<span class="number">2</span>).trim,p(<span class="number">3</span>).toInt))</span><br></pre></td></tr></table></figure></li><li><p>拼接</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建立起Row对象和模式之间的对应关系，也就是把数据和模式对应起来</span></span><br><span class="line"><span class="keyword">val</span> studentDF = spark.createDataFrame(rowRDD,schema)</span><br></pre></td></tr></table></figure></li><li><p>追加至关系数据库</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个prop变量保存JDBC连接参数</span></span><br><span class="line"><span class="keyword">val</span> prop = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">prop.put(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>) <span class="comment">// 用户名</span></span><br><span class="line">prop.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;hadoop&quot;</span>) <span class="comment">//密码</span></span><br><span class="line">prop.put(<span class="string">&quot;driver&quot;</span>,<span class="string">&quot;com.mysql.jdba.Driver&quot;</span>) <span class="comment">//驱动程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接数据库 采用append模式，追加记录到数据库spark的stu表</span></span><br><span class="line"><span class="comment">// jdbc全称路径，表名以及封装的其他信息</span></span><br><span class="line">studentDF.write.mode(<span class="string">&quot;append&quot;</span>).jdbc(<span class="string">&quot;jdbc:mysql://localhost:3306/spark&quot;</span>,<span class="string">&quot;spark.student&quot;</span>,prop)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><p>分两种数据：静态数据和流数据</p><p>流数据是动态数据，比如每时每刻摄像头采集的数据，对数据进行实时分析</p><p>流数据：大量快速时变的到达</p><ul><li>数据快速持续到达，潜在大小也许无穷无尽</li><li>数据来源众多，格式复杂</li><li>数据量大</li><li>注重数据的整体价值</li><li>数据顺序颠倒，或不完整</li></ul><p>对两种典型数据有两种计算，分别是批量计算和实时计算</p><p>对于批量计算处理大规模静态数据，无法满足秒级响应，因此MapReduce不适合实时</p><p><strong>实时计算：</strong>实时获取不同数据源的海量数据、经过实时分析处理、获得有价值的信息</p><h4 id="流数据基本理念："><a href="#流数据基本理念：" class="headerlink" title="流数据基本理念："></a>流数据基本理念：</h4><p>数据的价值会随着时间流逝而降低</p><p>因此需要高性能（每秒几十万数据）、海量式（TB、PB级数据规模）、低延迟（实时性，达到秒级、毫秒级响应）、分布式（大数据基本架构，平滑扩展）可扩展、易用性（快速开发和部署）、高可靠的引擎</p><p>典型的三类流计算框架</p><ol><li>IBM…</li><li>Twitter Storm，Yahoo S4</li><li>百度DStream 银河流计算平台</li></ol><h4 id="传统的数据处理流程："><a href="#传统的数据处理流程：" class="headerlink" title="传统的数据处理流程："></a>传统的数据处理流程：</h4><ul><li>存储的数据是旧的，不具备时效性</li><li>需要用户主动发出查询来获取结果</li></ul><h4 id="流数据处理流程"><a href="#流数据处理流程" class="headerlink" title="流数据处理流程"></a>流数据处理流程</h4><img src="images/image-20210114155342020.png" alt="image-20210114155342020" style="zoom:67%;"><h5 id="数据实时采集"><a href="#数据实时采集" class="headerlink" title="数据实时采集"></a>数据实时采集</h5><p>如日志数据</p><ul><li>facebook Scribe</li><li>LinkerIn Kafka</li><li>taobao Time Tunnel</li><li>Apache Flume</li></ul><h5 id="数据实时计算"><a href="#数据实时计算" class="headerlink" title="数据实时计算"></a>数据实时计算</h5><img src="images/image-20210114155545489.png" alt="image-20210114155545489" style="zoom:50%;"><h5 id="实时查询服务"><a href="#实时查询服务" class="headerlink" title="实时查询服务"></a>实时查询服务</h5><p>用户实时查询栈是存储</p><p>一般采用<strong>订阅</strong>的方式，主动推送</p><h3 id="Spark-Streaming-1"><a href="#Spark-Streaming-1" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h3><img src="images/image-20210114163331112.png" alt="image-20210114163331112" style="zoom:50%;"><p>把实时的输入数据流切分，每段交给spark核心引擎处理，流处理转为批处理，由于线程级别并行，响应级别高，因此变相的流计算</p><img src="images/image-20210114163413372.png" alt="image-20210114163413372" style="zoom:67%;"><h4 id="数据抽象：DStream"><a href="#数据抽象：DStream" class="headerlink" title="数据抽象：DStream"></a>数据抽象：DStream</h4><blockquote><p>DStream本质上是一堆RDD</p><img src="images/image-20210114163541042.png" alt="image-20210114163541042" style="zoom:50%;"></blockquote><h4 id="与Storm区别"><a href="#与Storm区别" class="headerlink" title="与Storm区别"></a>与Storm区别</h4><ul><li><p>因此Spark Streaming本质上不是流计算，无法实现毫秒级响应</p></li><li><p>RDD有更高的容错性</p></li><li><p>既需要实时数据，有需要历史数据一起进行分析，可以用Spark Streaming</p></li></ul><img src="images/image-20210114163824232.png" alt="image-20210114163824232" style="zoom:67%;"><h4 id="Spark架构"><a href="#Spark架构" class="headerlink" title="Spark架构"></a>Spark架构</h4><img src="images/image-20210114164007427.png" alt="image-20210114164007427" style="zoom:67%;"><h3 id="DStream操作"><a href="#DStream操作" class="headerlink" title="DStream操作"></a>DStream操作</h3><img src="images/image-20210114164344142.png" alt="image-20210114164344142" style="zoom:67%;"><blockquote><p>集群管理器：Cluster Managger</p><p>管家节点：Driver</p><p>Exceutor进程派生出多个Task线程（<strong>线程级并发</strong>）</p><p><strong>Receiver驻留Task，处理流数据，负责一个Input DStream</strong>，挂接Inpu DStream</p></blockquote><h4 id="Input-DStream类型："><a href="#Input-DStream类型：" class="headerlink" title="Input DStream类型："></a>Input DStream类型：</h4><ul><li>套接字流</li><li>文件流</li><li>从Kafka中读取的输入流</li></ul><h4 id="Spark-Streaming-程序"><a href="#Spark-Streaming-程序" class="headerlink" title="Spark Streaming 程序"></a>Spark Streaming 程序</h4><ol><li><p>通过创建输入DStream <strong>定义输入源</strong></p><blockquote><p>数据源头：</p><ul><li>对文件进行监控：文件流</li><li>通过Kafka抛数据：Kafka数据流</li><li>创建一个RDD队列：RDD队列流</li></ul></blockquote></li><li><p>对DStream应用<strong>转换操作和输出操作</strong>，来<strong>定义流计算</strong></p></li><li><p>streamingContext.start()开始程序，接收数据和处理流程</p><p>streamingContext.awaitTermination()，合适时结束</p><p>streamingContext.stop()，手动结束流计算进程</p></li></ol><h4 id="streaming-Context"><a href="#streaming-Context" class="headerlink" title="streaming Context"></a>streaming Context</h4><ul><li>创建对象：</li></ul><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.streaming._</span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sc.<span class="type">Seconds</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming._</span><br><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;TestDStream&quot;</span>).setMaster(<span class="string">&quot;local[2]&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf.seconds(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="基本输入源"><a href="#基本输入源" class="headerlink" title="基本输入源"></a>基本输入源</h3><h4 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h4><p>对某目录进行监控，发现文件变化，捕捉，如<strong>日志捕捉</strong></p><ul><li><p>shell创建文件流</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.streaming._</span><br><span class="line"><span class="comment">// 分段周期20秒</span></span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sc.<span class="type">Seconds</span>(<span class="number">20</span>))</span><br><span class="line"><span class="comment">// 文件流input stream</span></span><br><span class="line"><span class="keyword">val</span> lines = ssc.textFileStream(<span class="string">&quot;file:///usr/local/spark/mycode/streaming/logfile&quot;</span>)</span><br><span class="line"><span class="comment">// 流计算过程</span></span><br><span class="line"><span class="keyword">val</span> words = lines.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="keyword">val</span> wordCounts = words.map(x=&gt;(x,<span class="number">1</span>)).reduceByKey(_+_)</span><br><span class="line">wordCounts.print()</span><br><span class="line"><span class="comment">// 启动流计算</span></span><br><span class="line">ssc.start()</span><br><span class="line"><span class="comment">// 遇错停止，否则不断工作</span></span><br><span class="line">ssc.awaitTermination()</span><br></pre></td></tr></table></figure></li><li><p>独立应用程序编写创建文件流</p><img src="images/image-20210114171950800.png" alt="image-20210114171950800" style="zoom:67%;"><img src="images/image-20210114172011516.png" alt="image-20210114172011516" style="zoom:50%;"><img src="images/image-20210114172028144.png" alt="image-20210114172028144" style="zoom:50%;"><p>注意：注意一些依赖库的变化</p></li></ul><h4 id="套接字流"><a href="#套接字流" class="headerlink" title="套接字流"></a>套接字流</h4><img src="images/image-20210114172324134.png" alt="image-20210114172324134" style="zoom: 80%;"><h5 id="使用NC产生数据"><a href="#使用NC产生数据" class="headerlink" title="使用NC产生数据"></a><strong>使用NC产生数据</strong></h5><p>独立程序编写：</p><p><strong>构建TCP客户端</strong>向服务端发送请求，请求数据，服务端会发送数据到Spark Streaming组件，然后进行词频统计</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.storage.<span class="type">StorageLevel</span></span><br><span class="line"><span class="comment">// 单例对象</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">NetworkWordCount</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">// 服务器主机的地址和端口号</span></span><br><span class="line">            <span class="type">System</span>.err.println(<span class="string">&quot;Usage: NetworkWordCount&lt;hostname&gt;&lt;port&gt;&quot;</span>)</span><br><span class="line">            <span class="type">System</span>.exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置log4j日志级别显示</span></span><br><span class="line">        <span class="comment">// 定义在org.apache.spark.examples.streaming中的StreamingExample.scala代码文件，单例对象，不需要实例化，直接静态方法</span></span><br><span class="line">        <span class="type">StreamingExamples</span>.setStreamingLogLevels()</span><br><span class="line">        <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;NetworkWordCount&quot;</span>).setMaster(<span class="string">&quot;local[2]&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf.<span class="type">Seconds</span>(<span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 定义输入数据流，表套接字数据流，args[0]为服务器主机名，args[1]为端口号，后为数据的保存方式，此处为内存+磁盘</span></span><br><span class="line">        <span class="keyword">val</span> lines = ssc.socketTextStream(args(<span class="number">0</span>),args(<span class="number">1</span>).toInt,<span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK_SER</span>)</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        <span class="keyword">val</span> words = lines.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">        <span class="keyword">val</span> wordCounts = words.map(x=&gt;(x,<span class="number">1</span>)).reduceByKey(_+_)</span><br><span class="line">        wordCounts.print()</span><br><span class="line">        ssc.start()</span><br><span class="line">        ssc.awaitTermination()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置log级别的代码：</p><p><img src="images/image-20210114174143273.png" alt="image-20210114174143273"></p><p><strong>启动服务端</strong></p><p>linux本地可以运行netcat：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lk &lt;port&gt;</span><br></pre></td></tr></table></figure><blockquote><p>l 启动监听 k 连续监听</p></blockquote><p>此时可以在服务端输入数据，由客户端处理</p><h5 id="使用Socket编程实现自定义数据源"><a href="#使用Socket编程实现自定义数据源" class="headerlink" title="使用Socket编程实现自定义数据源"></a><strong>使用Socket编程实现自定义数据源</strong></h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.&#123;<span class="type">PrintWriter</span>&#125;</span><br><span class="line"><span class="keyword">import</span> java.net.<span class="type">ServerSocket</span></span><br><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DataSourceSocket</span></span>&#123;</span><br><span class="line">    <span class="comment">// 返回0-length随机数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span></span>(length: <span class="type">Int</span>)=&#123;</span><br><span class="line">        <span class="keyword">val</span> rdm = <span class="keyword">new</span> java.uril.<span class="type">Random</span></span><br><span class="line">        rdm.nextInt(length)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>])&#123;</span><br><span class="line">        <span class="comment">// 需要文件名从文件中抓取数据传送给客户端、监听端口号、数据传输间隔时间</span></span><br><span class="line">        <span class="keyword">if</span>(args.length!=<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="type">System</span>.err.println(<span class="string">&quot;Usage:&lt;filename&gt;&lt;port&gt;&lt;millisecond&gt;&quot;</span>)</span><br><span class="line">            <span class="type">System</span>.exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> fileName = args(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 读取文件形成列表</span></span><br><span class="line">        <span class="keyword">val</span> lines = <span class="type">Source</span>.fromFile(fileName).getLines.toList</span><br><span class="line">        <span class="comment">// 取随机行就是随机数</span></span><br><span class="line">        <span class="keyword">val</span> rowCount = lines.length</span><br><span class="line">        <span class="comment">// TCP服务端构建ServerSocket监听端口号 : args(1).toInt绑定</span></span><br><span class="line">        <span class="keyword">val</span> listener = <span class="keyword">new</span> <span class="type">ServerSocket</span>(args(<span class="number">1</span>).toInt)</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 进入阻塞状态，等待连接唤醒</span></span><br><span class="line">            <span class="keyword">val</span> socket = listener.accept()</span><br><span class="line">            <span class="comment">// 激活后进入新线程即一旦客户端发起连接，派生线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="type">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span> </span>= &#123;</span><br><span class="line">                    <span class="comment">// socket.getInetAddress客户端地址</span></span><br><span class="line">                    println(<span class="string">&quot;Got client connected from:&quot;</span>+socket.getInetAddress)</span><br><span class="line">                    <span class="comment">// 生成输出流</span></span><br><span class="line">                    <span class="keyword">val</span> out = <span class="keyword">new</span> <span class="type">PrintWriter</span>(socket.getOutputStream(),<span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">// 建立连接不断发送数据</span></span><br><span class="line">                    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                        <span class="comment">// 每睡几毫秒，就发一次</span></span><br><span class="line">                        <span class="type">Thread</span>.sleep(args(<span class="number">2</span>).toLong)</span><br><span class="line">                        <span class="comment">// 随即行</span></span><br><span class="line">                        <span class="keyword">val</span> content = lines(index(rowCount))</span><br><span class="line">                        println(content)</span><br><span class="line">                        out.write(content+&#x27;\n&#x27;)</span><br><span class="line">                        <span class="comment">// 发出</span></span><br><span class="line">                        out.flush()</span><br><span class="line">                    &#125;</span><br><span class="line">                    socket.close()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while(true)中内容：</p><img src="images/image-20210114180406318.png" alt="image-20210114180406318" style="zoom:67%;"><h4 id="RDD队列流"><a href="#RDD队列流" class="headerlink" title="RDD队列流"></a>RDD队列流</h4><p>输入数据是一个RDD队列</p><blockquote><p>以下每隔一秒发送RDD队列到Spark Streaming</p><p>而Spark Streaming每隔1秒对数据进行处理</p></blockquote><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.<span class="type">StreamingContext</span>._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.&#123;<span class="type">Seconds</span>,<span class="type">StreamingContext</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">QueueStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>])&#123;</span><br><span class="line">        <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;TestRDDQueue&quot;</span>).setMaster(<span class="string">&quot;local[2]&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf.<span class="type">Seconds</span>(<span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 生成RDD队列，该对象每个类型是RDD，RDD中是Int类</span></span><br><span class="line">        <span class="keyword">val</span> rddQueue = <span class="keyword">new</span> scala.collection.mutable.<span class="type">SynchronizedQueue</span>[<span class="type">RDD</span>[<span class="type">Int</span>]]()</span><br><span class="line">        <span class="comment">// 创建输入流（队列流类型）</span></span><br><span class="line">        <span class="keyword">val</span> queueStream = ssc.queueStream(rddQueue)</span><br><span class="line">        <span class="comment">// 处理部分</span></span><br><span class="line">        <span class="comment">// 对队列流数据进行map操作</span></span><br><span class="line">        <span class="keyword">val</span> mappedStream = queueStream.map(r=&gt;(r%<span class="number">10</span>,<span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 词频统计</span></span><br><span class="line">        <span class="keyword">val</span> reducesStream = mappedStream.reduceByKey(_+_)</span><br><span class="line">        <span class="comment">// 统计结果打印</span></span><br><span class="line">        reduceStream.print()</span><br><span class="line">        ssc.start()</span><br><span class="line">        <span class="comment">// for循环向队列输送数据</span></span><br><span class="line">        <span class="keyword">for</span>(i&lt;- <span class="number">1</span> to <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">// 1到100 分两个区</span></span><br><span class="line">            rddQueue += ssc.sparkContext.makeRDD(<span class="number">1</span> to <span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line">            <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        ssc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高级数据源"><a href="#高级数据源" class="headerlink" title="高级数据源"></a>高级数据源</h3><blockquote><p>使用Apache Kafka作为Spark Streaming数据源</p></blockquote><h4 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h4><h5 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h5><blockquote><p>高吞吐量的分布式发布订阅消息系统</p><p>订阅消息、分发消息</p><p><strong>作为消息分发系统，起到信息传递中枢作用</strong></p></blockquote><h6 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h6><p><strong>服务器</strong>，kafka集群有多个服务器即Borker</p><h6 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h6><p><strong>主题</strong>，消息扔给Topic，订阅也是Topic，因此有分区概念</p><h6 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h6><img src="images/image-20210114213524708.png" alt="image-20210114213524708" style="zoom:67%;"><h6 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h6><p><strong>生产者</strong>，负责把生产出来的消息发送给kafka Broker</p><h6 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h6><p><strong>消费者</strong>，向Kafka broker读取消息的客户端</p><p>如Spark Streaming</p><h6 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h6><p>每个Consumer只属于某个Consumer Group，若不指定则属于默认的组</p><h6 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h6><img src="images/image-20210114213819810.png" alt="image-20210114213819810" style="zoom:80%;"><h5 id="kafka启动"><a href="#kafka启动" class="headerlink" title="kafka启动"></a>kafka启动</h5><p>需要借助zookeeper服务，因此需要启动(需要跟配置文件参数)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入kafka所在的目录</span></span><br><span class="line">cd /usr/local/kafka</span><br><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties</span><br></pre></td></tr></table></figure><blockquote><p>关闭窗口会终止服务</p></blockquote><p>启动Kafka服务，同上</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/kafka</span><br><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure><p><a href="http://dblab.xmu.edu.cn/blog/1096-2/">http://dblab.xmu.edu.cn/blog/1096-2/</a></p><p>导入jar包：</p><p><a href="http://dblab.xmu.edu.cn/blog/1358-2/">http://dblab.xmu.edu.cn/blog/1358-2/</a></p><h4 id="生产者程序"><a href="#生产者程序" class="headerlink" title="生产者程序"></a>生产者程序</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.spark.examples.streaming</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">HashMap</span></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.&#123;<span class="type">KafkaProducer</span>, <span class="type">ProducerConfig</span>, <span class="type">ProducerRecord</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.kafka._</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KafkaWordProducer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">      <span class="comment">// 需要参数 Broker地址， topic主题，每秒几个消息，每条消息几个单词</span></span><br><span class="line">      <span class="keyword">if</span> (args.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">          <span class="type">System</span>.err.println(<span class="string">&quot;Usage: KafkaWordCountProducer &lt;metadataBrokerList&gt; &lt;topic&gt; &quot;</span> +</span><br><span class="line">            <span class="string">&quot;&lt;messagesPerSec&gt; &lt;wordsPerMessage&gt;&quot;</span>)</span><br><span class="line">          <span class="type">System</span>.exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">val</span> <span class="type">Array</span>(brokers, topic, messagesPerSec, wordsPerMessage) = args</span><br><span class="line">      <span class="comment">// Zookeeper connection properties 哈希映射</span></span><br><span class="line">      <span class="keyword">val</span> props = <span class="keyword">new</span> <span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Object</span>]()</span><br><span class="line">      <span class="comment">// 需要提供Broker地址</span></span><br><span class="line">      props.put(<span class="type">ProducerConfig</span>.<span class="type">BOOTSTRAP_SERVERS_CONFIG</span>, brokers)</span><br><span class="line">      props.put(<span class="type">ProducerConfig</span>.<span class="type">VALUE_SERIALIZER_CLASS_CONFIG</span>,</span><br><span class="line">      <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>)</span><br><span class="line">      props.put(<span class="type">ProducerConfig</span>.<span class="type">KEY_SERIALIZER_CLASS_CONFIG</span>,</span><br><span class="line">      <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> producer = <span class="keyword">new</span> <span class="type">KafkaProducer</span>[<span class="type">String</span>, <span class="type">String</span>](props)</span><br><span class="line">      <span class="comment">// 不断发送消息</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="comment">// 每秒几个消息</span></span><br><span class="line">          (<span class="number">1</span> to messagesPerSec.toInt).foreach &#123; messageNum =&gt;</span><br><span class="line">              <span class="comment">// 每条消息包含wordsPerMessage个单词</span></span><br><span class="line">              <span class="keyword">val</span> str = (<span class="number">1</span> to wordsPerMessage.toInt).map(x =&gt; scala.util.<span class="type">Random</span>.nextInt(<span class="number">10</span>).toString).mkString(<span class="string">&quot; &quot;</span>)</span><br><span class="line">              print(str)</span><br><span class="line">              println()</span><br><span class="line">              <span class="comment">// Kafka只接受ProducerRecord对象，因此封装，往topic传，key，value</span></span><br><span class="line">              <span class="keyword">val</span> message = <span class="keyword">new</span> <span class="type">ProducerRecord</span>[<span class="type">String</span>, <span class="type">String</span>](topic, <span class="literal">null</span>, str)</span><br><span class="line">              producer.send(message)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者程序"><a href="#消费者程序" class="headerlink" title="消费者程序"></a>消费者程序</h4><p>相关数据扔到kafka后，编写spark streaming获取数据进行词频统计</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.spark.examples.streaming</span><br><span class="line"><span class="keyword">import</span> org.apache.spark._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.kafka._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.<span class="type">StreamingContext</span>._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.kafka.<span class="type">KafkaUtils</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KafkaWordCount</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>])&#123;</span><br><span class="line">        <span class="type">StreamingExamples</span>.setStreamingLogLevels()</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;KafkaWordCount&quot;</span>).setMaster(<span class="string">&quot;local[2]&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sc,<span class="type">Seconds</span>(<span class="number">10</span>))</span><br><span class="line">        <span class="comment">// 检查点，防止数据丢失</span></span><br><span class="line">        ssc.checkpoint(<span class="string">&quot;file:///usr/local/spark/mycode/kafka/checkpoint&quot;</span>) <span class="comment">//设置检查点，如果存放在HDFS上面，则写成类似ssc.checkpoint(&quot;/user/hadoop/checkpoint&quot;)这种形式，但是，要启动hadoop</span></span><br><span class="line">        <span class="keyword">val</span> zkQuorum = <span class="string">&quot;localhost:2181&quot;</span> <span class="comment">//Zookeeper服务器地址</span></span><br><span class="line">        <span class="keyword">val</span> group = <span class="string">&quot;1&quot;</span>  <span class="comment">//topic所在的group，可以设置为自己想要的名称，比如不用1，而是val group = &quot;test-consumer-group&quot; </span></span><br><span class="line">        <span class="keyword">val</span> topics = <span class="string">&quot;wordsender&quot;</span>  <span class="comment">//topics的名称          </span></span><br><span class="line">        <span class="keyword">val</span> numThreads = <span class="number">1</span>  <span class="comment">//每个topic的分区数</span></span><br><span class="line">        <span class="keyword">val</span> topicMap =topics.split(<span class="string">&quot;,&quot;</span>).map((_,numThreads.toInt)).toMap <span class="comment">//需要map形式提供给createStream</span></span><br><span class="line">        <span class="keyword">val</span> lineMap = <span class="type">KafkaUtils</span>.createStream(ssc,zkQuorum,group,topicMap)<span class="comment">//数据源创建完毕</span></span><br><span class="line">        <span class="comment">// 数据源创建后 接下来编写转换</span></span><br><span class="line">        <span class="keyword">val</span> lines = lineMap.map(_._2)</span><br><span class="line">        <span class="keyword">val</span> words = lines.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">        <span class="keyword">val</span> pair = words.map(x =&gt; (x,<span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 转换操作</span></span><br><span class="line">        <span class="keyword">val</span> wordCounts = pair.reduceByKeyAndWindow(_ + _,_ - _,<span class="type">Minutes</span>(<span class="number">2</span>),<span class="type">Seconds</span>(<span class="number">10</span>),<span class="number">2</span>) </span><br><span class="line">        wordCounts.print</span><br><span class="line">        ssc.start</span><br><span class="line">        ssc.awaitTermination</span><br><span class="line">    &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><h5 id="编写日志格式设置程序"><a href="#编写日志格式设置程序" class="headerlink" title="编写日志格式设置程序"></a>编写日志格式设置程序</h5><p>设置log4j</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.spark.examples.streaming</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.internal.<span class="type">Logging</span></span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.&#123;<span class="type">Level</span>, <span class="type">Logger</span>&#125;</span><br><span class="line"><span class="comment">/** Utility functions for Spark Streaming examples. */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamingExamples</span> <span class="keyword">extends</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** Set reasonable logging levels for streaming if the user has not configured log4j. */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setStreamingLogLevels</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> log4jInitialized = <span class="type">Logger</span>.getRootLogger.getAllAppenders.hasMoreElements</span><br><span class="line">    <span class="keyword">if</span> (!log4jInitialized) &#123;</span><br><span class="line">      <span class="comment">// We first log something to initialize Spark&#x27;s default logging, then we override the</span></span><br><span class="line">      <span class="comment">// logging level.</span></span><br><span class="line">      logInfo(<span class="string">&quot;Setting log level to [WARN] for streaming example.&quot;</span> +</span><br><span class="line">        <span class="string">&quot; To override add a custom log4j.properties to the classpath.&quot;</span>)</span><br><span class="line">      <span class="type">Logger</span>.getRootLogger.setLevel(<span class="type">Level</span>.<span class="type">WARN</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://dblab.xmu.edu.cn/blog/1358-2/">http://dblab.xmu.edu.cn/blog/1358-2/</a></p><h3 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h3><h4 id="DStream无状态转换"><a href="#DStream无状态转换" class="headerlink" title="DStream无状态转换"></a>DStream无状态转换</h4><ul><li><p>map(func):一对一转换</p></li><li><p>flapMap(func):1个映射多个</p></li><li><p>filter(func):过滤</p></li><li><p>repartition(numPartitions):改变DStream用的分区数目</p></li><li><p>reduce(func):聚合运算</p></li><li><p>count():统计</p></li><li><p>union(otherStream):合并两个DStream</p></li><li><p>countByValue():用在元素类型为K的DStream上统计</p></li><li><p>reduceByKey(func,[numTasks]):key相同进行聚合</p></li><li><p>join(otherStream,[numTasks])</p></li><li><p>cogroup(otherStream,[numTasks]):(K,V)、(K,W)-&gt;(K,SEQ(V),SEQ(W))</p></li><li><p>transform(func):对整个源DStream应用RDD-to-RDD函数转换得到新的DStream</p></li></ul><blockquote><p>无状态?</p><p>只针对当前批次，新的到达，前面的丢失</p></blockquote><h4 id="DStream有状态转换"><a href="#DStream有状态转换" class="headerlink" title="DStream有状态转换"></a>DStream有状态转换</h4><h5 id="滑动窗口转换操作"><a href="#滑动窗口转换操作" class="headerlink" title="滑动窗口转换操作"></a>滑动窗口转换操作</h5><img src="images/image-20210114222708185.png" alt="image-20210114222708185" style="zoom:67%;"><blockquote><p><strong>参数</strong>：</p><p>滑动窗口大小、滑动窗口时间间隔大小</p></blockquote><p><strong>方法</strong></p><ul><li><p>winndow(windowLength,slideInterval)</p></li><li><p>countByWindow(windowLength,slideInterval):返回流中元素的一个滑动窗口数</p></li><li><p>reduceByWindow(func,windowLength,slideInterval):返回一个单元素流，即聚合得到的值对应的流</p></li><li><p>reduceByKeyAndWindow(func,windowLength,slideInterval,[numTasks]):对当前窗口进行reduceByKey计算（numTasks几个线程并行进行）</p><blockquote><p>额外的invfunc：逆函数，如下第二个参数，逆向操作的原因就是提高整个程序的运算效率，在滑动时部分淘汰部分还在，为了防止重新计算，可以用逆向操作</p><img src="images/image-20210114223258049.png" alt="image-20210114223258049" style="zoom:50%;"><p><img src="images/image-20210114223139842.png" alt="image-20210114223139842"></p></blockquote></li></ul><h5 id="updateStateByKey操作"><a href="#updateStateByKey操作" class="headerlink" title="updateStateByKey操作"></a>updateStateByKey操作</h5><blockquote><p>在跨批次之间维护状态</p></blockquote><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.spark.examples.streaming</span><br><span class="line"><span class="keyword">import</span> org.apache.spark._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.storage.<span class="type">StorageLevel</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">NetworkWordCountStateful</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="comment">//定义状态更新函数 values传入sequence序列 state维护当前历史状态的词频，若首次出现是None</span></span><br><span class="line">    <span class="keyword">val</span> updateFunc = (values: <span class="type">Seq</span>[<span class="type">Int</span>], state: <span class="type">Option</span>[<span class="type">Int</span>]) =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> currentCount = values.foldLeft(<span class="number">0</span>)(_ + _)<span class="comment">//值的序列进行以0为初始总值相加</span></span><br><span class="line">      <span class="keyword">val</span> previousCount = state.getOrElse(<span class="number">0</span>)<span class="comment">//获取历史结果</span></span><br><span class="line">      <span class="type">Some</span>(currentCount + previousCount)<span class="comment">//累加返回给Some</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StreamingExamples</span>.setStreamingLogLevels()  <span class="comment">//设置log4j日志级别</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;NetworkWordCountStateful&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">    sc.checkpoint(<span class="string">&quot;file:///usr/local/spark/mycode/streaming/stateful/&quot;</span>)    <span class="comment">//设置检查点，检查点具有容错机制</span></span><br><span class="line">    <span class="keyword">val</span> lines = sc.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>)<span class="comment">//套接字数据源</span></span><br><span class="line">    <span class="keyword">val</span> words = lines.flatMap(_.split(<span class="string">&quot; &quot;</span>))<span class="comment">//转换语句</span></span><br><span class="line">    <span class="keyword">val</span> wordDstream = words.map(x =&gt; (x, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">val</span> stateDstream = wordDstream.updateStateByKey[<span class="type">Int</span>](updateFunc)<span class="comment">//跨批次状态维护</span></span><br><span class="line">    stateDstream.print()</span><br><span class="line">    sc.start()</span><br><span class="line">    sc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：还要设置日志格式</p><h3 id="输出操作"><a href="#输出操作" class="headerlink" title="输出操作"></a>输出操作</h3><h4 id="输出到文本文件"><a href="#输出到文本文件" class="headerlink" title="输出到文本文件"></a>输出到文本文件</h4><p>新增下：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">stateDstream.savaAsTextFiles(<span class="string">&quot;file:///usr/local/spark/mycode/streaming/dstreamoutput/output.txt&quot;</span>)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sc.start()</span><br><span class="line">sc.awaitTermination()</span><br></pre></td></tr></table></figure><p>生成多个文件，每10秒一个</p><h4 id="输出到mysql"><a href="#输出到mysql" class="headerlink" title="输出到mysql"></a>输出到mysql</h4><p>新增下：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面是新增的语句，把DStream保存到MySQL数据库中  stateDstream本身是RDD集合</span></span><br><span class="line">stateDstream.foreachRDD(rdd =&gt; &#123;</span><br><span class="line">    <span class="comment">//内部函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span></span>(records: <span class="type">Iterator</span>[(<span class="type">String</span>,<span class="type">Int</span>)]) &#123;</span><br><span class="line">        <span class="keyword">var</span> conn: <span class="type">Connection</span> = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 动态sql</span></span><br><span class="line">        <span class="keyword">var</span> stmt: <span class="type">PreparedStatement</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> url = <span class="string">&quot;jdbc:mysql://localhost:3306/spark&quot;</span></span><br><span class="line">            <span class="keyword">val</span> user = <span class="string">&quot;root&quot;</span></span><br><span class="line">            <span class="keyword">val</span> password = <span class="string">&quot;hadoop&quot;</span></span><br><span class="line">            <span class="comment">// 驱动程序</span></span><br><span class="line">            conn = <span class="type">DriverManager</span>.getConnection(url, user, password)</span><br><span class="line">            records.foreach(p =&gt; &#123;</span><br><span class="line">                <span class="comment">// 动态sql语句</span></span><br><span class="line">                <span class="keyword">val</span> sql = <span class="string">&quot;insert into wordcount(word,count) values (?,?)&quot;</span></span><br><span class="line">                stmt = conn.prepareStatement(sql);</span><br><span class="line">                stmt.setString(<span class="number">1</span>, p._1.trim)</span><br><span class="line">                stmt.setInt(<span class="number">2</span>,p._2.toInt)</span><br><span class="line">                stmt.executeUpdate()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; e.printStackTrace()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">                stmt.close()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                conn.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重分区以后的RDD遍历每一个分区</span></span><br><span class="line">    <span class="keyword">val</span> repartitionedRDD = rdd.repartition(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 把partition里每条记录用func函数写到底层的mysql数据库中，会传递给func Iterator类型数据</span></span><br><span class="line">    repartitionedRDD.foreachPartition(func)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>mysql中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; use spark</span><br><span class="line">mysql&gt; create table wordcount (word char(20), count int(4));</span><br><span class="line">mysql&gt; select * from wordcount</span><br><span class="line">&#x2F;&#x2F;这个时候wordcount表是空的，没有任何记录</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="http://dblab.xmu.edu.cn/blog/1391-2/">http://dblab.xmu.edu.cn/blog/1391-2/</a></p><h3 id="Structured-Streaming"><a href="#Structured-Streaming" class="headerlink" title="Structured Streaming"></a>Structured Streaming</h3><blockquote><p>spark2.0之前,将RDD抽象</p><p>Structured Streaming用<strong>DataFrame抽象</strong></p><p>还引入<strong>持续流式处理模型,可以将流处理延迟降低至毫秒级别</strong></p></blockquote><ul><li><p>structured streaming就是将不断输入的流式数据,变为内存中一个没有边界的数据库表</p></li><li><p>DataFrame这种数据抽象是关系表,没到达一个数据在里面增加一条记录,每增加一个记录,更新查询结果</p></li></ul><p><img src="images/image-20210114232148964.png" alt="image-20210114232148964"></p><blockquote><p>建模为结构化数据表</p><p>重新抽象了流式计算,基于DataFrame的数据抽象</p><p>易于实现数据的exactly-once(at-least once是所有数据至少处理一次,那是之前,而exactly-once保证数据只被处理一次),保证数据至少处理一次,而且只处理一次</p></blockquote><h2 id="Spark-MLlib"><a href="#Spark-MLlib" class="headerlink" title="Spark MLlib"></a>Spark MLlib</h2><h3 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h3><p>mapreduce基于磁盘架构进行设计，多次反复迭代会带来磁盘IO开销</p><p>而spark是基于内存的计算框架，实现管道化的处理，在内存中完成数据交接，适合大量迭代计算，虽然shuffle要进磁盘但也大大减少磁盘IO开销</p><blockquote><p>MLlib就是基于海量数据的机器学习库，<strong>分布式实现</strong></p><p>提供流水线，调整机器学习工作流</p><p>提供持久性，保存算法、加载算法、模型、管道这些的保存</p><ul><li><p>spark.mllib是基于RDD的数据抽象</p></li><li><p>新版本spark.ml是基于DataFrame的数据抽象，可以使Spark SQL融合进来</p></li></ul></blockquote><img src="images/image-20210106224943530.png" alt="image-20210106224943530" style="zoom: 50%;"><img src="images/image-20210106224952149.png" alt="image-20210106224952149" style="zoom:50%;"><p><img src="images/image-20210106225226139.png" alt="image-20210106225226139"></p><h3 id="机器学习流水线"><a href="#机器学习流水线" class="headerlink" title="机器学习流水线"></a>机器学习流水线</h3><h4 id="pipeline概述"><a href="#pipeline概述" class="headerlink" title="pipeline概述"></a>pipeline概述</h4><h5 id="DataFrame-1"><a href="#DataFrame-1" class="headerlink" title="DataFrame"></a>DataFrame</h5><p>采用DataFrame结构化数据作为抽象</p><p>数据加载封装在DataFrame中，调用接口进行相关转换</p><h5 id="Transformer转换器"><a href="#Transformer转换器" class="headerlink" title="Transformer转换器"></a>Transformer转换器</h5><p>把一个DataFrame转换为另一个DataFrame</p><p>即通过算法对数据进行训练，得到<strong>模型（该模型即转换器）</strong>，可以对测试数据集（封装在DataFrame）进行打标签操作</p><h6 id="转换器实现的方法为Transform"><a href="#转换器实现的方法为Transform" class="headerlink" title="转换器实现的方法为Transform()"></a><strong>转换器实现的方法为Transform()</strong></h6><blockquote><p>提供DataFrame，接收后转为另一个DataFrame</p></blockquote><h5 id="Estimator评估器"><a href="#Estimator评估器" class="headerlink" title="Estimator评估器"></a>Estimator评估器</h5><p>学习算法或在训练数据上的训练方法的概念抽象</p><blockquote><p>用评估器对DataFrame数据进行操作，会<strong>转换得到一个转换器</strong>，实际上是一个算法，进行训练得到模型</p></blockquote><h6 id="评估器实现的方法为fit"><a href="#评估器实现的方法为fit" class="headerlink" title="评估器实现的方法为fit()"></a><strong>评估器实现的方法为fit()</strong></h6><blockquote><p>传递DataFrame，自动训练得到转换器</p></blockquote><h5 id="PipeLine"><a href="#PipeLine" class="headerlink" title="PipeLine"></a>PipeLine</h5><p>转换器-评估器反复组合，流水线是完成机器学习基本工作</p><h6 id="构建Pipeline流水线："><a href="#构建Pipeline流水线：" class="headerlink" title="构建Pipeline流水线："></a><strong>构建Pipeline流水线：</strong></h6><ol><li><p>定义Pipeline中各个流水线阶段PipelineStage（包括转换器、评估器）</p></li><li><p>按照处理逻辑转换器和评估器有序地组织起来构建成PipeLine</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成机器学习流水线，传递各个阶段名称</span></span><br><span class="line"><span class="keyword">val</span> pipeline = <span class="keyword">new</span> <span class="type">Pipeline</span>().setStages(<span class="type">Array</span>(stage1,stage2,stage3,...))</span><br></pre></td></tr></table></figure><blockquote><p>注意得到的流水线大多时候为评估器，因此需要fit</p></blockquote></li><li><p>训练流水线，得到PipeLine Model。用PipeLine Model预测数据打标签</p><img src="images/image-20210106230721415.png" alt="image-20210106230721415" style="zoom:67%;"><blockquote><p>Tokenizer是一个转换器，进行分词处理，是模型了</p><p>HashingTF也是一个转换器，将单词转换为特征向量，模型</p><p>Logistic Regression是一个评估器，还是一个算法，训练的</p><p><strong>流水线本身是一个评估器</strong></p><img src="images/image-20210106231012167.png" alt="image-20210106231012167" style="zoom:67%;"></blockquote></li></ol><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>以逻辑斯蒂回归为例</p><h5 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h5><p>含Spark为有，否则无，对数据打标签</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol><li><p>构建SparkSession对象（同Spark SQL）</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"><span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().</span><br><span class="line">master(<span class="string">&quot;local&quot;</span>).</span><br><span class="line">appName(<span class="string">&quot;my App Name&quot;</span>).</span><br><span class="line">gerOrCreate()</span><br></pre></td></tr></table></figure></li><li><p>引入要包含的包并构建训练数据集</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.ml.feature._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.classification.<span class="type">LogisticRegression</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.&#123;<span class="type">Pipeline</span>,<span class="type">PipelineModel</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.linalg.<span class="type">Vector</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Row</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器类型sequence toDF上字段名称</span></span><br><span class="line"><span class="keyword">val</span> training = spark.createDataFrame(<span class="type">Seq</span>(</span><br><span class="line">|(<span class="number">0</span>L,<span class="string">&quot;a b c d e spark&quot;</span>,<span class="number">1.0</span>),</span><br><span class="line">|(<span class="number">1</span>L,<span class="string">&quot;b d&quot;</span>,<span class="number">0.0</span>),</span><br><span class="line">|(<span class="number">2</span>L,<span class="string">&quot;spark f g h&quot;</span>,<span class="number">1.0</span>)</span><br><span class="line">|(<span class="number">3</span>L,<span class="string">&quot;hadoop mapreduce&quot;</span>,<span class="number">0.0</span>)</span><br><span class="line">|)).toDF(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;text&quot;</span>,<span class="string">&quot;label&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>定义Pipeline中各个流水线阶段PipelineStage</p><img src="images/image-20210106232104604.png" alt="image-20210106232104604" style="zoom:50%;"><ol><li><p>分词</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设定输入列text进行单词拆分，每个做分词</span></span><br><span class="line"><span class="comment">// 切分后输出到words列，以数组形式保存</span></span><br><span class="line"><span class="keyword">val</span> tokenizer = <span class="keyword">new</span> <span class="type">Tokenizer</span>().</span><br><span class="line">|setInputCol(<span class="string">&quot;text&quot;</span>).</span><br><span class="line">|setOutputCol(<span class="string">&quot;words&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>单词转换为特征向量</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setNumFeatures特征向量维度</span></span><br><span class="line"><span class="comment">// setInputCol输入列</span></span><br><span class="line"><span class="comment">// OutputCol输出的列</span></span><br><span class="line"><span class="keyword">val</span> hashingTF = <span class="keyword">new</span> <span class="type">HashingTF</span>().</span><br><span class="line">|setNumFeatures(<span class="number">1000</span>).</span><br><span class="line">|setInputCol(tokenizer.getOutputCol).</span><br><span class="line">|setOutputCol(<span class="string">&quot;features&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>逻辑斯蒂回归算法</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 评估器对象</span></span><br><span class="line"><span class="comment">// 不断迭代最大10</span></span><br><span class="line"><span class="keyword">val</span> lr = <span class="keyword">new</span> <span class="type">LogisticRegression</span>().</span><br><span class="line">|setMaxIter(<span class="number">10</span>).</span><br><span class="line">|serRegParam(<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure></li></ol></li><li><p>按照处理逻辑有序地组织PipelineStages，创建Pipeline</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组封装</span></span><br><span class="line"><span class="keyword">val</span> pipeline = <span class="keyword">new</span> <span class="type">Pipeline</span>().</span><br><span class="line">|setStages(<span class="type">Array</span>(tokenizer, hashingTF, lr))</span><br></pre></td></tr></table></figure></li><li><p>还包含一个评估器，评估器还没训练，需要fit</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// training是构建的训练数据DataFrame</span></span><br><span class="line"><span class="keyword">val</span> model = pipeline.fit(training)</span><br></pre></td></tr></table></figure><p>训练结束得到PipelineModel</p></li></ol><h5 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h5><ol><li><p>测试数据封装(无标签)</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> test = spark.createDataFrame(<span class="type">Seq</span>(</span><br><span class="line">|(<span class="number">4</span>L,<span class="string">&quot;spark i j k&quot;</span>),</span><br><span class="line">|(<span class="number">5</span>L,<span class="string">&quot;l m n&quot;</span>),</span><br><span class="line">|(<span class="number">6</span>L,<span class="string">&quot;spark a&quot;</span>)</span><br><span class="line">|(<span class="number">7</span>L,<span class="string">&quot;apache hadoop&quot;</span>)</span><br><span class="line">|)).toDF(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;text&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>测试数据按顺序通过拟合的流水线，生成预测结果</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreach按指定格式打印</span></span><br><span class="line"><span class="comment">// 遍历到的DataFrame为当前Row对象，case会把id提取到ID字段里面，text提取赋值给text变量，prob概率向量提取...</span></span><br><span class="line"><span class="comment">// println中为s插值，凡是变量则加$，打印时把变量值替换掉把值打印</span></span><br><span class="line">model.transform(test).</span><br><span class="line">|select(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;text&quot;</span>,<span class="string">&quot;probability&quot;</span>,<span class="string">&quot;prediction&quot;</span>).</span><br><span class="line">|collect().</span><br><span class="line">|foreach &#123; <span class="keyword">case</span> <span class="type">Row</span>(id:<span class="type">Long</span>,text:<span class="type">String</span>,prob:<span class="type">Vector</span>,prediction:<span class="type">Double</span>)=&gt;</span><br><span class="line">|println(<span class="string">s&quot;(<span class="subst">$id</span>,<span class="subst">$text</span>)--&gt;prob=<span class="subst">$prob</span>,prediction=&amp;prediction&quot;</span>)</span><br><span class="line">|&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如：</p><img src="images/image-20210106233918354.png" alt="image-20210106233918354" style="zoom:67%;"></li></ol><h3 id="特征抽取、转化和选择"><a href="#特征抽取、转化和选择" class="headerlink" title="特征抽取、转化和选择"></a>特征抽取、转化和选择</h3><h4 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h4><p>词频-逆向文件频率</p><ul><li>IDF</li></ul><p>$$<br>IDF(t,D) = log\frac{|D|+1}{DF(t,D)+1}<br>$$</p><ul><li>度量值表示：</li></ul><p>$$<br>TFIDF(t,d,D)=TF(t,d)\cdot IDF(t,D)<br>$$</p><h5 id="TF"><a href="#TF" class="headerlink" title="TF"></a>TF</h5><blockquote><p>使用HashingTF转换器，可以让词条集合转化为固定长度特征向量</p></blockquote><h5 id="IDF"><a href="#IDF" class="headerlink" title="IDF"></a>IDF</h5><blockquote><p>使用评估器，给予数据集训练得到IDFModel</p></blockquote><p>用TF的特征向量作为输入传到IDFModel</p><h5 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h5><blockquote><p>输入数据-&gt;分解器Tokenizer-&gt;得到词袋-&gt;HashingTF得到特征向量-&gt;IDF调整得到的特征向量</p></blockquote><ol><li><p>导入TF-IDF所需要的包</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.ml.feature.&#123;<span class="type">HashingTF</span>,<span class="type">IDF</span>,<span class="type">Tokenizer</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启RDD隐式转换</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> spark.implicits._</span><br></pre></td></tr></table></figure></li><li><p>创建一个简单DataFrame，每个句子代表一个文档</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sentenceData = spark.createDataFrame(<span class="type">Seq</span>(</span><br><span class="line">|(<span class="number">0</span>,<span class="string">&quot;I heard about Spark and I love Spark&quot;</span>),</span><br><span class="line">|(<span class="number">0</span>,<span class="string">&quot;I wish Java could use case classes&quot;</span>),</span><br><span class="line">|(<span class="number">1</span>,<span class="string">&quot;Logistic regression models are neat&quot;</span>)</span><br><span class="line">|)).toDF(<span class="string">&quot;label&quot;</span>,<span class="string">&quot;sentence&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>得到文档集合后，即可用tokenizer对句子进行分词</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> tokenizer = <span class="keyword">new</span> <span class="type">Tokenizer</span>().setInputCol(<span class="string">&quot;sentence&quot;</span>).setOutputCol(<span class="string">&quot;words&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> wordsData = tokenizer.transform(sentenceData)</span><br><span class="line">wordsData.show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li><li><p>使用HashingTF的transform()方法把句子哈希成特征向量</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> hashingTF = <span class="keyword">new</span> <span class="type">HashingTF</span>().</span><br><span class="line">|setInputCol(<span class="string">&quot;words&quot;</span>).setOutputCol(<span class="string">&quot;rawFeatures&quot;</span>).setNumFeatures(<span class="number">2000</span>)</span><br><span class="line"><span class="keyword">val</span> featurizedData = hashingTF.transform(wordsData)</span><br><span class="line">featurizedData.select(<span class="string">&quot;rawFeatures&quot;</span>).show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p><img src="images/image-20210107101021538.png" alt="image-20210107101021538"></p><blockquote><p>2000为哈希桶数目，后数组表示分词后每个词在哈希桶映射到的编号，后为词频</p></blockquote></li><li><p>调权重：使用IDF来对单纯的词频特征向量进行修正(评估器)</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> idf = <span class="keyword">new</span> <span class="type">IDF</span>().setInputCol(<span class="string">&quot;rawFeatures&quot;</span>).setOutputCol(<span class="string">&quot;features&quot;</span>)</span><br><span class="line"><span class="comment">// 训练</span></span><br><span class="line"><span class="keyword">val</span> idfModel = idf.fit(featurizedData)</span><br></pre></td></tr></table></figure></li><li><p>用数据进行预测，调用IDFModel的transform()方法</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rescaledData = idfModel.transform(featurizedData)</span><br><span class="line"><span class="comment">// 取前三个</span></span><br><span class="line">rescaledData.select(<span class="string">&quot;features&quot;</span>,<span class="string">&quot;label&quot;</span>).take(<span class="number">3</span>).foreach(println)</span><br></pre></td></tr></table></figure><p>词频变了，单词重要性变了，即得到每一个单词对应的TF-IDF度量值</p><img src="images/image-20210107101555327.png" alt="image-20210107101555327" style="zoom:50%;"></li></ol><h4 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h4><p>词嵌入方法，计算每个单词在给定语料库环境下的分布式词向量，一定程度上刻画语义</p><p>本质上是评估器，需要训练得到word2vecmodel，从而进行映射转成固定大小向量</p><h5 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h5><ol><li><p>首先导入Word2Vec所需要的包，并创建三个词语序列，每个代表一个文档</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.ml.feature.<span class="type">Word2Vec</span></span><br><span class="line"><span class="keyword">val</span> documentDF = spark.createDataFrame(<span class="type">Seq</span>(</span><br><span class="line">|<span class="string">&quot;Hi I heard about Spark&quot;</span>.split(<span class="string">&quot; &quot;</span>),</span><br><span class="line">|<span class="string">&quot;I wish Java could use case classes&quot;</span>.split(<span class="string">&quot; &quot;</span>),</span><br><span class="line">|<span class="string">&quot;Logistic regression models are neat&quot;</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">|).map(<span class="type">Tuple1</span>.apply)).toDF(<span class="string">&quot;text&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>新建Word2Vec</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 特征向量维度为3，单词出现0次以上列入统计</span></span><br><span class="line"><span class="keyword">val</span> word2Vec = <span class="keyword">new</span> <span class="type">Word2Vec</span>().</span><br><span class="line">|setInputCol(<span class="string">&quot;text&quot;</span>).</span><br><span class="line">|setOutputCol(<span class="string">&quot;result&quot;</span>).</span><br><span class="line">|setVectorSize(<span class="number">3</span>).</span><br><span class="line">|setMinCount(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>读入训练数据，用fit()方法生成一个Word2VecModel</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> model = word2Vec.fit(documentDF)</span><br></pre></td></tr></table></figure></li><li><p>利用Word2VecModel把文档转变成特征向量</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = model.transform(documentDF)</span><br><span class="line">result.select(<span class="string">&quot;result&quot;</span>).take(<span class="number">3</span>).foreach(println)</span><br></pre></td></tr></table></figure><img src="images/image-20210107102904893.png" alt="image-20210107102904893" style="zoom:67%;"></li></ol><h4 id="CountVectorizer"><a href="#CountVectorizer" class="headerlink" title="CountVectorizer"></a>CountVectorizer</h4><p>通过技术把文档转向量，如果不存在先验字典会通过评估器进行训练，生成CountVectorizerModel</p><blockquote><p>产生文档关于词语的稀疏表示，传递给其他算法进一步使用</p></blockquote><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>CountVectorizer训练中会根据语料库中的词频排序从高到低进行选择</p><ul><li><p>vocabsize</p><p>指定词汇表最大含量（前n个词频最大的）</p></li><li><p>minDF</p><p>指定词汇表中的词语至少在多少个不同文档中出现</p></li></ul><h5 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a>过程</h5><h6 id="无先验"><a href="#无先验" class="headerlink" title="无先验"></a>无先验</h6><ol><li><p>首先导入CountVectorizer所需要的包</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.ml.feature.&#123;<span class="type">CountVectorizer</span>,<span class="type">CountVectorizerModel</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>构建相关数据</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> df = spark.createDataFrame(<span class="type">Seq</span>(</span><br><span class="line">|(<span class="number">0</span>,<span class="type">Array</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>)),</span><br><span class="line">|(<span class="number">1</span>,<span class="type">Array</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;a&quot;</span>))</span><br><span class="line">|)).toDF(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;words&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过CountVectorizer设定超参数，训练一个CountVectorizerModel</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> cvModel: <span class="type">CountVectorizerModel</span> = <span class="keyword">new</span> <span class="type">CountVectorizer</span>().</span><br><span class="line">|setInputCol(<span class="string">&quot;words&quot;</span>).</span><br><span class="line">|setOutputCol(<span class="string">&quot;features&quot;</span>).</span><br><span class="line">|setVocabSize(<span class="number">3</span>).</span><br><span class="line">|setMinDF(<span class="number">2</span>).</span><br><span class="line">|fit(df)</span><br></pre></td></tr></table></figure></li><li><p>通过CountVectorizerModel的vocabulary成员获得到模型的词汇表</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">cvModel.vocabulary</span><br></pre></td></tr></table></figure></li><li><p>使用这一模型对DataFrame进行变换，得到文档的向量化表示</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">cvModel.transform(df).show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li></ol><h6 id="含先验"><a href="#含先验" class="headerlink" title="含先验"></a>含先验</h6><p>可以指定先验的词汇表，不需要训练</p><ol><li><p>用先验的词汇表直接生成得到一个模型</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">cal cvm = <span class="keyword">new</span> <span class="type">CountVectorizerModel</span>(<span class="type">Array</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>)).</span><br><span class="line">|setInoutCol(<span class="string">&quot;words&quot;</span>).</span><br><span class="line">|setOutputCol(<span class="string">&quot;features&quot;</span>)</span><br><span class="line">cvm.transform(df).select(<span class="string">&quot;features&quot;</span>).foreach&#123;println&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="分类和回归"><a href="#分类和回归" class="headerlink" title="分类和回归"></a>分类和回归</h3><h4 id="逻辑斯蒂回归分类器"><a href="#逻辑斯蒂回归分类器" class="headerlink" title="逻辑斯蒂回归分类器"></a>逻辑斯蒂回归分类器</h4><ol><li><p>导入需要的包</p><img src="images/image-20210107112820800.png" alt="image-20210107112820800" style="zoom:50%;"></li><li><p>隐式转换问题</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"><span class="comment">// 样例类定义</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Iris</span>(<span class="params">features:org.apache.spark.ml.linalg.<span class="type">Vector</span>,label:<span class="type">String</span></span>)</span></span><br></pre></td></tr></table></figure></li><li><p>读取数据</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> data = spark.spark.<span class="type">Context</span>.textFile(<span class="string">&quot;file:///usr/local/spark/iris.txt&quot;</span>).map(_.split(<span class="string">&quot;,&quot;</span>)).map(p=&gt;<span class="type">Iris</span>(<span class="type">Vectors</span>.dense(p(<span class="number">0</span>).toDouble,p(<span class="number">1</span>).toDouble,p(<span class="number">2</span>).toDouble,p(<span class="number">3</span>).toDouble),p(<span class="number">4</span>).toString())).toDF()</span><br><span class="line">data.show()</span><br></pre></td></tr></table></figure></li><li><p>得到数据注册成一个表Iris，通过SQL语句进行数据查询</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册临时表</span></span><br><span class="line">data.createOrReplaceTempView(<span class="string">&quot;iris&quot;</span>)</span><br><span class="line"><span class="comment">// 查询sql</span></span><br><span class="line"><span class="keyword">val</span> df = spark.sql(<span class="string">&quot;select * from iris where label != &#x27;Iris-setosa&#x27;&quot;</span>)</span><br><span class="line"><span class="comment">// 标签放前</span></span><br><span class="line">df.map(t=&gt;t(<span class="number">1</span>)+<span class="string">&quot;:&quot;</span>+t(<span class="number">0</span>)).collect().foreach(println)</span><br></pre></td></tr></table></figure></li><li><p>分别获取标签列和特征列，进行索引，并进行重命名</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串转为数值形式</span></span><br><span class="line"><span class="keyword">val</span> labelIndexer = <span class="keyword">new</span> <span class="type">StringIndexer</span>().setInputCol(<span class="string">&quot;label&quot;</span>).setOutputCol(<span class="string">&quot;indexedLabel&quot;</span>).fit(df)</span><br><span class="line"><span class="comment">// 特征向量也进行转换为数值型</span></span><br><span class="line"><span class="keyword">val</span> featureIndexer = <span class="keyword">new</span> <span class="type">VectorIndexer</span>().setInputCol(<span class="string">&quot;features&quot;</span>).setOutputCol(<span class="string">&quot;indexedFeatures&quot;</span>).fit(df)</span><br></pre></td></tr></table></figure></li><li><p>数据集划分</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">Array</span>(trainingData,testData) = df.randomSplit(<span class="type">Array</span>(<span class="number">0.7</span>,<span class="number">0.3</span>))</span><br></pre></td></tr></table></figure></li><li><p><strong>设置logistic的参数</strong></p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 索引后的标签indexedLabel 特征列indexedFeatures，最大迭代10</span></span><br><span class="line"><span class="keyword">val</span> lr = <span class="keyword">new</span> <span class="type">LogisticRegression</span>().setLabelCol(<span class="string">&quot;indexedLabel&quot;</span>).setFeaturesCol(<span class="string">&quot;indexedFeatures&quot;</span>).setMaxIter(<span class="number">10</span>).setRegParam(<span class="number">0.3</span>).setElasticNetParam(<span class="number">0.8</span>)</span><br></pre></td></tr></table></figure></li><li><p>设置一个labelConverter，把预测的类别重新转化成字符型</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> labelConverter = <span class="keyword">new</span> <span class="type">IndexToString</span>().setInputCol(<span class="string">&quot;prediction&quot;</span>).setOutputCol(<span class="string">&quot;predictedLabel&quot;</span>).setLabels(labelIndexer.labels)</span><br></pre></td></tr></table></figure><p><strong>labelIndexer.labels</strong>：包含的数据型</p></li><li><p>构建pipeline，设置stage，调用fit()来训练模型</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">IrPipeline</span> = <span class="keyword">new</span> <span class="type">Pipeline</span>().setStages(<span class="type">Array</span>(labelIndexer,featureIndexer,lr,labelConverter))</span><br><span class="line"><span class="keyword">val</span> <span class="type">IrPiprlineModel</span> = <span class="type">IrPipeline</span>.fit(trainingData)</span><br></pre></td></tr></table></figure></li><li><p>PipelineModel调用transform()进行预测</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">IrPredictions</span> = <span class="type">IrPipelineModel</span>.transform(testData)</span><br><span class="line"><span class="type">IrPredictions</span>.select(<span class="string">&quot;predictedLabel&quot;</span>,<span class="string">&quot;label&quot;</span>,<span class="string">&quot;features&quot;</span>,<span class="string">&quot;probability&quot;</span>).collect().foreach &#123;<span class="keyword">case</span> <span class="type">Row</span>(predictedLabel:<span class="type">String</span>,label:<span class="type">String</span>,features:<span class="type">Vector</span>,prob:<span class="type">Vector</span>)=&gt;println(<span class="string">s&quot;(<span class="subst">$label</span>,<span class="subst">$features</span>)--&gt;prob=<span class="subst">$prob</span>,predictedLabel=<span class="subst">$predictedLabel</span>&quot;</span>)&#125;</span><br></pre></td></tr></table></figure><img src="images/image-20210107115337108.png" alt="image-20210107115337108" style="zoom:50%;"></li><li><p>模型评估，计算预测准确率和错误率</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> evaluator = <span class="keyword">new</span> <span class="type">MulticlassClassificationEvaluator</span>().setLabelCol(<span class="string">&quot;indexedLabel&quot;</span>).setPredictionCol(<span class="string">&quot;prediction&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">IrAccuarcy</span> = evaluator.evaluate(<span class="type">IrPredictions</span>)</span><br><span class="line">println(<span class="string">&quot;Test Error = &quot;</span>+(<span class="number">1.0</span> - <span class="type">IrAccuarcy</span>))</span><br></pre></td></tr></table></figure></li><li><p>通过model来获取训练得到的逻辑斯蒂模型</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">IrModel</span> = <span class="type">IrPipelineModel</span>.stages(<span class="number">2</span>).asInstanceOf[<span class="type">LogisticRegressionModel</span>]</span><br></pre></td></tr></table></figure></li><li><p>打印参数</p><p><img src="images/image-20210107115822876.png" alt="image-20210107115822876"></p></li></ol><h4 id="决策树分类器"><a href="#决策树分类器" class="headerlink" title="决策树分类器"></a>决策树分类器</h4><p>树形结构，训练数据训练</p><h5 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h5><p>特征选择、决策树生成、决策树剪枝</p><ul><li><p>通常特征选择的准则是信心增益，选择信息增益最大的特征</p><img src="images/image-20210107120050779.png" alt="image-20210107120050779" style="zoom:50%;"></li><li><p>决策树生成</p></li><li><p>决策树剪枝</p><p>对未知测试数据的分类没有那么准确：过拟合现象</p></li></ul><h5 id="过程-4"><a href="#过程-4" class="headerlink" title="过程"></a>过程</h5><ol><li><p>导入需要的包</p><img src="images/image-20210107120155383.png" alt="image-20210107120155383" style="zoom: 67%;"></li><li><p>隐式、读取</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"><span class="comment">// 样例类定义</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Iris</span>(<span class="params">features:org.apache.spark.ml.linalg.<span class="type">Vector</span>,label:<span class="type">String</span></span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> data = spark.spark.<span class="type">Context</span>.textFile(<span class="string">&quot;file:///usr/local/spark/iris.txt&quot;</span>).map(_.split(<span class="string">&quot;,&quot;</span>)).map(p=&gt;<span class="type">Iris</span>(<span class="type">Vectors</span>.dense(p(<span class="number">0</span>).toDouble,p(<span class="number">1</span>).toDouble,p(<span class="number">2</span>).toDouble,p(<span class="number">3</span>).toDouble),p(<span class="number">4</span>).toString())).toDF()</span><br><span class="line">data.show()</span><br></pre></td></tr></table></figure></li><li><p>得到数据注册成一个表Iris，通过SQL语句进行数据查询</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册临时表</span></span><br><span class="line">data.createOrReplaceTempView(<span class="string">&quot;iris&quot;</span>)</span><br><span class="line"><span class="comment">// 查询sql</span></span><br><span class="line"><span class="keyword">val</span> df = spark.sql(<span class="string">&quot;select * from iris&quot;</span>)</span><br><span class="line"><span class="comment">// 标签放前</span></span><br><span class="line">df.map(t=&gt;t(<span class="number">1</span>)+<span class="string">&quot;:&quot;</span>+t(<span class="number">0</span>)).collect().foreach(println)</span><br></pre></td></tr></table></figure></li><li><p>分别获取标签列和特征列，进行索引，并进行重命名</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串转为数值形式</span></span><br><span class="line"><span class="keyword">val</span> labelIndexer = <span class="keyword">new</span> <span class="type">StringIndexer</span>().setInputCol(<span class="string">&quot;label&quot;</span>).setOutputCol(<span class="string">&quot;indexedLabel&quot;</span>).fit(df)</span><br><span class="line"><span class="comment">// 特征向量也进行转换为数值型 设最大分类</span></span><br><span class="line"><span class="keyword">val</span> featureIndexer = <span class="keyword">new</span> <span class="type">VectorIndexer</span>().setInputCol(<span class="string">&quot;features&quot;</span>).setOutputCol(<span class="string">&quot;indexedFeatures&quot;</span>).setMaxCategories(<span class="number">4</span>).fit(df)</span><br></pre></td></tr></table></figure></li><li><p>数据集划分</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">Array</span>(trainingData,testData) = df.randomSplit(<span class="type">Array</span>(<span class="number">0.7</span>,<span class="number">0.3</span>))</span><br></pre></td></tr></table></figure></li><li><p>进一步处理特征和标签，以及数据分组</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> labelConverter = <span class="keyword">new</span> <span class="type">IndexToString</span>().setInputCol(<span class="string">&quot;prediction&quot;</span>).setOutputCol(<span class="string">&quot;predictedLabel&quot;</span>).setLabels(labelIndexer.labels)</span><br></pre></td></tr></table></figure></li><li><p>构建决策树分类模型</p><ol><li><p>导入所需要的包</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.ml.classification.<span class="type">DecisionTreeClassificationModel</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.classification.<span class="type">DecisionTreeClassifier</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.evaluation.<span class="type">MulticlassClassificationEvaluator</span></span><br></pre></td></tr></table></figure></li><li><p>基本配置</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 训练决策树模型，通过setter方法来设置决策树参数，也可以用ParamMap来设置，可以设置的参数可以通过explainParams()获取</span></span><br><span class="line"><span class="keyword">val</span> dtClassifier = <span class="keyword">new</span> <span class="type">DecisionTreeClassifier</span>().setLabelCol(<span class="string">&quot;indexedLabel&quot;</span>).setFeaturesCol(<span class="string">&quot;indexedFeatures&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol></li><li><p>定义评估器</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> pipelinedClassifier = <span class="keyword">new</span> <span class="type">Pipeline</span>().setStages(<span class="type">Array</span>(labelIndexer,featureIndexer,dtClassifier,labelConverter))</span><br></pre></td></tr></table></figure></li><li><p>训练模型，并进行预测</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> modelClassifier = pipelinedClassifier.fit(trainingData)</span><br><span class="line"><span class="keyword">val</span> predictionsClassifier = modelClassifier.transform(testData)</span><br><span class="line"><span class="comment">// 预测结果</span></span><br><span class="line">predictionsClassifier.select(<span class="string">&quot;predictedLabel&quot;</span>,<span class="string">&quot;label&quot;</span>,<span class="string">&quot;features&quot;</span>.show(<span class="number">20</span>))</span><br></pre></td></tr></table></figure></li><li><p>评估决策树分类器模型</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> evaluatorClassifier = <span class="keyword">new</span> <span class="type">MulticlassClassificationEvaluator</span>().setLabelCol(<span class="string">&quot;indexedLabel&quot;</span>),setPredictionCol(<span class="string">&quot;prediction&quot;</span>).setMetricName(<span class="string">&quot;accuracy&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> accuracy = evaluatorClassifier.evaluate(predictionsClassifier)</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Test Error=&quot;</span>+(<span class="number">1.0</span> - arruracy))</span><br></pre></td></tr></table></figure></li><li><p>获取整个模型并打印</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取整个模型</span></span><br><span class="line"><span class="keyword">val</span> treeModelClassifier = modelClassifier.stages(<span class="number">2</span>).asInstanceOf[<span class="type">DecisionTreeClassificationModel</span>]</span><br></pre></td></tr></table></figure><p>打印：</p><img src="images/image-20210107121901044.png" alt="image-20210107121901044" style="zoom: 67%;"></li></ol><h2 id="图计算"><a href="#图计算" class="headerlink" title="图计算"></a>图计算</h2><blockquote><p>针对图结构数据的处理</p><p>图结构数据可以很好的表达数据之间的关联性，关联性计算是大数据计算的核心—-通过获得数据的关联性，可以从噪音很多的海量数据中抽取有用信息。如通过关联性得到相似用户推荐、通过图结构计算找到意见领袖</p></blockquote><h3 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a>概述</h3><blockquote><p><strong>BSP模型</strong>叫整体同步并行计算模型或者简称为大同步模型</p><p>包括通过网络连接起来的处理器，并行分布式处理；计算是一系列的全局超步（迭代）；</p><p>一个超步的垂直结构如下</p><img src="images/image-20210116230136553.png" alt="image-20210116230136553" style="zoom: 67%;"><ul><li><strong>局部计算</strong>：自身的计算任务只读取本地值（各个处理器异步独立执行互不干涉）</li><li><strong>通讯</strong>：不同处理器交换数据，使下次更好的迭代计算</li><li><strong>栅栏同步</strong>：不同的处理器各自允许，速度不同，速度快的会等待，被栅栏拦住</li></ul></blockquote><h3 id="Pregel"><a href="#Pregel" class="headerlink" title="Pregel"></a>Pregel</h3><p>基于BSP模型实现的并行图处理系统</p><h4 id="图计算模型"><a href="#图计算模型" class="headerlink" title="图计算模型"></a>图计算模型</h4><h5 id="有向图和顶点"><a href="#有向图和顶点" class="headerlink" title="有向图和顶点"></a>有向图和顶点</h5><img src="images/image-20210116230559940.png" alt="image-20210116230559940" style="zoom:67%;"><ol><li>Pregel计算模型以有向图作为输入</li><li>有向图的每个顶点都有一个String类型的顶点ID</li><li>每个顶点都有一个可修改的用户自定义值与之关联</li><li>每条有向边都和其源顶点关联，并记录了其目标顶点ID</li><li>边上有一个可修改的用户自定义值与之关联</li></ol><blockquote><img src="images/image-20210116230924348.png" alt="image-20210116230924348" style="zoom:80%;"><ul><li><p>在每个超步S中，图中所有顶点都会并行执行相同的用户自定义函数</p></li><li><p>每个顶点可以接收前一个超步(S-1)中发送给它的消息，修改其自身及其出射边的状态，并发送消息给其他顶点，甚至是修改整个图的拓扑结构</p></li><li><p>边并不是核心对象，在边上面不会有相应计算，只有顶点才会执行用户自定义函数进行相应计算</p></li></ul></blockquote><p>顶点之间的消息传递方法：</p><ul><li><p>远程读取</p></li><li><p>基于共享内存</p></li><li><p>而Pregel采用消息传递模型</p><blockquote><p>因为消息传递具有足够的表达能力</p><p>有助于提升系统的整体性能（远程读取有较高延迟，图结构不需要远程读取；而共享内存扩展性不好）</p></blockquote></li></ul><h5 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h5><ul><li><p>Pregel计算过程是由被称为”超步”的迭代组成的</p></li><li><p>在<strong>每个超步</strong>中，<strong>每个顶点</strong>上面都会并行执行用户自定义的函数</p></li></ul><p>读取前一个超步顶点发送的消息，然后处理消息后修改出射边状态，再把相关消息发送给下个超步的顶点（下个超步处理）</p><ul><li><p>在Pregel计算过程中，一个算法什么时候结束由所有顶点状态决定</p><img src="images/image-20210116231751907.png" alt="image-20210116231751907" style="zoom:50%;"><blockquote><p>所有顶点非活跃状态，并且顶点之间无消息传递发生，则结束</p></blockquote><ol><li>在第0个超步，所有顶点处于活跃状态</li><li>一个顶点不需要继续执行进一步计算时就会把自己状态设置为停机，除非给其发送了消息被激活</li><li>Pregel计算框架必须根据条件判断来决定是否将非活跃状态点显式唤醒进入活跃状态</li></ol></li></ul><h4 id="C"><a href="#C" class="headerlink" title="C++###########"></a>C++###########</h4><h4 id="Pregel体系结构"><a href="#Pregel体系结构" class="headerlink" title="Pregel体系结构"></a>Pregel体系结构</h4><h5 id="Pregel执行过程和容错性"><a href="#Pregel执行过程和容错性" class="headerlink" title="Pregel执行过程和容错性"></a>Pregel执行过程和容错性</h5><h6 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h6><p>在Pregel计算框架中，大型图会被划分成许多个分区，每个分区包含了一部分顶点以及以其为起点的边。而顶点分配到哪个分区是由一个函数决定的，系统默认函数为hash(ID) mod N，其中N为所有分区总数，ID是这个顶点的标识符</p><blockquote><p><img src="images/image-20210117171718862.png" alt="image-20210117171718862"></p><ol><li>选择集群中的多台机器执行图计算任务，有一台机器被选为Master其他机器作为Worker</li><li>Master把一个图分成多个分区，并把分区分配到多个Worker，一个Worker会领到一个或多个分区，每个Worker知道所有其他Worker所分配到的分区情况</li><li>Master会把用户输入划分成多个部分，然后Master会为每个Worker分配用户输入的一部分。如果一个Worker从输入内容中加载到的顶点刚好是自己所分配到的分区中的顶点，就会立即更新相应的数据结构；否则该Worker会根据加载到的顶点的ID把它发送到其所属的分区所在Worker上。当所有输入都被加载后，图中所有顶点都会被标记为”活跃”状态</li><li>Master向每个Worker发送指令，Worker收到指令后，开始运行一个超步。当一个超步中所有工作都完成后，Worker通知Master，并把自己下一个超步还处于活跃状态的顶点数量报告给Master</li><li>计算过程结束后，Master给所有Worker发送指令，通知每个Worker对自己的计算结果进行持久化存储</li></ol></blockquote><h6 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h6><p><img src="images/image-20210117172720743.png" alt="image-20210117172720743"></p><h5 id="Worker、Master和Aggregator"><a href="#Worker、Master和Aggregator" class="headerlink" title="Worker、Master和Aggregator"></a>Worker、Master和Aggregator</h5><h6 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h6><blockquote><p>一般在执行过程中，信息存在内存中</p><p>信息有：顶点当前值，出射边列表，消息队列，标志位</p><p>前两个保存一份，后两个保存两份（一份为当前超步一份为下一个超步）</p></blockquote><blockquote><p>Worker对自己管辖分区中每个顶点进行遍历，并调用Compute函数</p></blockquote><blockquote><p>如果一个顶点V在超步S接收到消息表示V将会在下一个超步S+1中处于”活跃”状态</p><p>如果目标顶点在<strong>同台机器</strong>，直接把消息放入与目标顶点U对应的输入消息队列中；如果在<strong>远程机器</strong>，<strong>暂时缓存本地</strong>，当缓存中的消息数目达到一个事先设定的<em>阈值</em>时，这些缓存消息会被批量异步发送出去，传输到目标顶点所在的Woker上</p></blockquote><h6 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h6><ul><li><p>扮演管家角色，主要协调Worker执行各个任务</p></li><li><p>维护关于当前处于有效状态的所有Worker的各种信息，包括每个Worker的ID和地址信息，以及每个Worker被分配到的分区信息</p></li><li><p>Master中保存这些信息的数据结构的大小，<strong>只与分区的数量有关</strong>，而与顶点和边的数量无关</p></li></ul><p><strong>Master指令</strong>：Master向所有处于有效状态的Worker发送相同指令，然后等待Worker回应，在指定时间内某一个Worker没有回应说明该Worker已经失效，Master会进入恢复模式</p><blockquote><p>在每个超步中，图计算的各个任务(包括输入输出、计算保存、检查点恢复)，会在”路障”之前结束</p></blockquote><p><strong>Master在内部运行了一个HTTP服务器来显示图计算过程的各种信息</strong></p><h6 id="Aggregator"><a href="#Aggregator" class="headerlink" title="Aggregator"></a>Aggregator</h6><ul><li>在执行图计算过程的某个超步S中，每个Worker会利用一个Aggregator对当前本地分区中包含的所有顶点的值进行归约，得到一个本地的局部规约值</li><li>在超步S结束时，所有Worker会将所有包含局部归约值的Aggregator的值进行最后汇总，得到全局值，提交给Master</li><li>在下一个超步S+1开始时，Master会将Aggregator的全局值发送给每个Worker</li></ul><p>应用：<a href="https://www.icourse163.org/learn/XMU-1002335004?tid=1460162442#/learn/content?type=detail&amp;id=1236280069&amp;cid=1256005043&amp;replay=true">https://www.icourse163.org/learn/XMU-1002335004?tid=1460162442#/learn/content?type=detail&amp;id=1236280069&amp;cid=1256005043&amp;replay=true</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大数据概述&quot;&gt;&lt;a href=&quot;#大数据概述&quot; class=&quot;headerlink&quot; title=&quot;大数据概述&quot;&gt;&lt;/a&gt;大数据概述&lt;/h1&gt;&lt;h2 id=&quot;大数据概念和影响&quot;&gt;&lt;a href=&quot;#大数据概念和影响&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="大数据" scheme="https://www.gtxhjh.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.gtxhjh.cn/2021/01/27/hello-world/"/>
    <id>https://www.gtxhjh.cn/2021/01/27/hello-world/</id>
    <published>2021-01-27T14:10:33.217Z</published>
    <updated>2021-01-27T14:10:33.217Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
