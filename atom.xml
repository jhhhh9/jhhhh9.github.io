<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿花花花deCSNotes</title>
  
  
  <link href="https://www.gtxhjh.cn/atom.xml" rel="self"/>
  
  <link href="https://www.gtxhjh.cn/"/>
  <updated>2021-03-01T15:25:04.117Z</updated>
  <id>https://www.gtxhjh.cn/</id>
  
  <author>
    <name>JH</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第六章-垃圾回收概述和相关算法</title>
    <link href="https://www.gtxhjh.cn/2021/03/01/JVM-6/"/>
    <id>https://www.gtxhjh.cn/2021/03/01/JVM-6/</id>
    <published>2021-03-01T15:22:26.000Z</published>
    <updated>2021-03-01T15:25:04.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><p><img src="/2021/03/01/JVM-6/image-20210227220704364.png" alt="image-20210227220704364"></p><ul><li><p>Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C++语言没有垃圾收集技术，需要程序员手动的收集。</p></li><li><p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</p></li><li><p>关于垃圾收集有三个经典问题：</p><ul><li>  哪些内存需要回收？</li><li>  什么时候回收？</li><li>  如何回收？</li></ul></li><li><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p></li></ul><h2 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h2><p>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</p><blockquote><p>外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.</p></blockquote><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p><p><strong>十几年前磁盘碎片整理的日子</strong></p><p><img src="/2021/03/01/JVM-6/image-20210227221410879.png" alt="image-20210227221410879"></p><h2 id="为什么需要GC？"><a href="#为什么需要GC？" class="headerlink" title="为什么需要GC？"></a>为什么需要GC？</h2><p><strong>想要学习GC，首先需要理解为什么需要GC？</strong></p><ol><li><p> 对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p></li><li><p> 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong>。</p></li><li><p> 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成<strong>STW</strong>的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p></li></ol><h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><ol><li><p>在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MibBridge *pBridge= <span class="keyword">new</span> cmBaseGroupBridge（）；</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span>（pBridge-&gt;Register（kDestroy）！=NO ERROR）</span><br><span class="line"><span class="keyword">delete</span> pBridge；</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p></li><li><p>有了垃圾回收机制后，上述代码极有可能变成这样</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MibBridge *pBridge=<span class="keyword">new</span> cmBaseGroupBridge(); </span><br><span class="line">pBridge-&gt;Register(kDestroy);</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li> 现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。</li></ol><h2 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h2><h3 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h3><blockquote><p><strong>官网介绍</strong>：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p></blockquote><p><strong>自动内存管理的优点</strong></p><ul><li><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p><blockquote><p>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</p></blockquote></li><li><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p></li></ul><p><strong>关于自动内存管理的担忧</strong></p><ul><li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</li><li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</li><li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</li></ul><h3 id="应该关心哪些区域的回收？"><a href="#应该关心哪些区域的回收？" class="headerlink" title="应该关心哪些区域的回收？"></a>应该关心哪些区域的回收？</h3><p><img src="/2021/03/01/JVM-6/image-20210227225133463.png" alt="image-20210227225133463"></p><ul><li><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收，</p><blockquote><p>其中，<strong>Java堆是垃圾收集器的工作重点</strong></p></blockquote></li><li><p>从次数上讲：</p><ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ul></li></ul><h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><blockquote><p>GC分两个阶段：标记阶段、清楚阶段</p></blockquote><h2 id="标记阶段的目的"><a href="#标记阶段的目的" class="headerlink" title="标记阶段的目的"></a>标记阶段的目的</h2><p><strong>垃圾标记阶段：主要是为了判断对象是否存活</strong></p><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。</strong>只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</p><blockquote><p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p></blockquote><p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p><h2 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><ul><li><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<strong>引用计数器属性。用于记录对象被引用的情况</strong>。</p><blockquote><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收</p></blockquote><p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性</p><p>缺点：</p><ul><li><p>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong></p></li><li><p>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong></p></li><li><p>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法</p><blockquote><p><strong>循环引用</strong></p><p><img src="/2021/03/01/JVM-6/image-20210228204539356.png" alt="image-20210228204539356"></p><p>当p的指针断开的时候，内部的引用形成一个循环，计数器都还算1，无法被回收，这就是循环引用，从而造成内存泄漏</p></blockquote></li></ul></li></ul><h3 id="证明：java使用的不是引用计数算法"><a href="#证明：java使用的不是引用计数算法" class="headerlink" title="证明：java使用的不是引用计数算法"></a>证明：java使用的不是引用计数算法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 证明：java使用的不是引用计数算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefCountGC</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个成员属性唯一的作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//5MB</span></span><br><span class="line"></span><br><span class="line">    Object reference = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RefCountGC obj1 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        RefCountGC obj2 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line"></span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line">        obj2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//显式的执行垃圾回收行为</span></span><br><span class="line">        <span class="comment">//这里发生GC，obj1和obj2能否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/03/01/JVM-6/image-20210228204906218.png" alt="image-20210228204906218"></p><p><strong>没有进行GC时</strong></p><p>把下面的几行代码注释掉，让它来不及</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.gc();<span class="comment">//把这行代码注释掉</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 38400K, used 14234K [0x00000000d5f80000, 0x00000000d8a00000, 0x0000000100000000)</span><br><span class="line">  eden space 33280K, 42% used [0x00000000d5f80000,0x00000000d6d66be8,0x00000000d8000000)</span><br><span class="line">  from space 5120K, 0% used [0x00000000d8500000,0x00000000d8500000,0x00000000d8a00000)</span><br><span class="line">  to   space 5120K, 0% used [0x00000000d8000000,0x00000000d8000000,0x00000000d8500000)</span><br><span class="line"> ParOldGen       total 87552K, used 0K [0x0000000081e00000, 0x0000000087380000, 0x00000000d5f80000)</span><br><span class="line">  object space 87552K, 0% used [0x0000000081e00000,0x0000000081e00000,0x0000000087380000)</span><br><span class="line"> Metaspace       used 3496K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p><strong>进行GC</strong></p><p>打开那行代码的注释</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 13569K-&gt;808K(38400K)] 13569K-&gt;816K(125952K), <span class="number">0.0012717</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 808K-&gt;0<span class="title">K</span><span class="params">(38400K)</span>] [ParOldGen: 8K-&gt;670<span class="title">K</span><span class="params">(87552K)</span>] 816K-&gt;670<span class="title">K</span><span class="params">(125952K)</span>, [Metaspace: 3491K-&gt;3491<span class="title">K</span><span class="params">(1056768K)</span>], 0.0051769 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 38400K, used 333K [<span class="number">0x00000000d5f80000</span>, <span class="number">0x00000000d8a00000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 33280K, <span class="number">1</span>% used [<span class="number">0x00000000d5f80000</span>,<span class="number">0x00000000d5fd34a8</span>,<span class="number">0x00000000d8000000</span>)</span><br><span class="line">  from space 5120K, <span class="number">0</span>% used [<span class="number">0x00000000d8000000</span>,<span class="number">0x00000000d8000000</span>,<span class="number">0x00000000d8500000</span>)</span><br><span class="line">  to   space 5120K, <span class="number">0</span>% used [<span class="number">0x00000000d8500000</span>,<span class="number">0x00000000d8500000</span>,<span class="number">0x00000000d8a00000</span>)</span><br><span class="line"> ParOldGen       total 87552K, used 670K [<span class="number">0x0000000081e00000</span>, <span class="number">0x0000000087380000</span>, <span class="number">0x00000000d5f80000</span>)</span><br><span class="line">  object space 87552K, <span class="number">0</span>% used [<span class="number">0x0000000081e00000</span>,<span class="number">0x0000000081ea7990</span>,<span class="number">0x0000000087380000</span>)</span><br><span class="line"> Metaspace       used 3498K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 387<span class="title">K</span>, <span class="title">capacity</span> 390<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Process</span> <span class="title">finished</span> <span class="title">with</span> <span class="title">exit</span> <span class="title">code</span> 0</span></span><br></pre></td></tr></table></figure><p>从打印日志就可以明显看出来，已经进行了GC。如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</li><li>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li><li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li><li>Python如何解决循环引用？<ul><li>  手动解除：很好理解，就是在合适的时机，解除引用关系。</li><li>  使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</li></ul></li></ul><h2 id="标记阶段：可达性分析算法（根搜索算法、追踪性垃圾收集）"><a href="#标记阶段：可达性分析算法（根搜索算法、追踪性垃圾收集）" class="headerlink" title="标记阶段：可达性分析算法（根搜索算法、追踪性垃圾收集）"></a>标记阶段：可达性分析算法（根搜索算法、追踪性垃圾收集）</h2><ul><li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。</li><li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing Garbage Collection）</li></ul><h3 id="可达性分析实现思路"><a href="#可达性分析实现思路" class="headerlink" title="可达性分析实现思路"></a>可达性分析实现思路</h3><blockquote><p>所谓”GCRoots”根集合就是一组<strong>必须活跃的引用</strong></p></blockquote><ul><li>其基本思路如下：</li></ul><ol><li> 可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong></li><li> 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li><li> 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li> 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ol><p><img src="/2021/03/01/JVM-6/image-20210228210001463.png" alt="image-20210228210001463"></p><h3 id="GC-Roots可以是哪些元素？"><a href="#GC-Roots可以是哪些元素？" class="headerlink" title="GC Roots可以是哪些元素？"></a>GC Roots可以是哪些元素？</h3><ul><li>虚拟机栈中引用的对象<ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等</li></ul></li><li>本地方法栈内JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象<ul><li>比如：Java类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池（StringTable）里的引用</li></ul></li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。<ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。</li></ul></li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><p><img src="/2021/03/01/JVM-6/image-20210228210954656.png" alt="image-20210228210954656"></p><ol><li><p>总结一句话就是，除了堆空间的周边，比如：虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</p></li><li><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集</strong>和<strong>局部回收</strong>（PartialGC）。</p><blockquote><p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑（比如：考虑非新生代的为GC Roots），才能保证可达性分析的准确性。</p></blockquote></li></ol><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</li><li>这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li></ul><h2 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="headerlink" title="对象的 finalization 机制"></a>对象的 finalization 机制</h2><blockquote><p>对象销毁前的回调函数：finalize()</p><p>Object 类中 finalize() 源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 等待被重写</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="finalize-方法机制"><a href="#finalize-方法机制" class="headerlink" title="finalize() 方法机制"></a>finalize() 方法机制</h3><ul><li><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</p></li><li><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个<em>对象的finalize()方法</em>。</p></li><li><p><strong>finalize() 方法允许在子类中被重写</strong>，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p></li><li><p>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：</p><ol><li> 在finalize()时可能会导致对象复活。</li><li> finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li><li> 一个糟糕的finalize()会严重影响GC的性能。比如finalize是个死循环</li></ol></li><li><p>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在<strong>本质上不同于C++中的析构函数</strong>。</p></li><li><p>finalize()方法对应了一个finalize线程，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</p></li></ul><h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><blockquote><p>由于finalize()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态</strong></p></blockquote><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：</p><ol><li> <strong>可触及的</strong>：从根节点开始，可以到达这个对象。</li><li> <strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li><li> <strong>不可触及的</strong>：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong>。</li></ol><p>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p><ol><li> 如果对象objA到GC Roots没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行finalize()方法<ol><li> 如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li> 如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</li><li> <strong>finalize()方法是对象逃脱死亡的最后机会</strong>，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，<strong>一个对象的finalize()方法只会被调用一次</strong>。</li></ol></li></ol><p><strong>通过 JVisual VM 查看 Finalizer 线程</strong></p><img src="/2021/03/01/JVM-6/../../../../../jvm/JVM/JVM系列-第10章-垃圾回收概述和相关算法.assets/0008.png"><h3 id="代码演示-finalize-方法可复活对象"><a href="#代码演示-finalize-方法可复活对象" class="headerlink" title="代码演示 finalize() 方法可复活对象"></a>代码演示 finalize() 方法可复活对象</h3><p>我们重写 CanReliveObj 类的 finalize()方法，在调用其 finalize()方法时，将 obj 指向当前类对象 this</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Object类中finalize()方法，即对象的finalization机制。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanReliveObj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj;<span class="comment">//类变量，属于 GC Root</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法只能被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> CanReliveObj();</span><br><span class="line">            <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc();<span class="comment">//调用垃圾回收器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第1次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第2次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>如果注释掉finalize()方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此方法只能被调用一次</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.finalize();</span><br><span class="line">       System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">       obj = <span class="keyword">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>次 gc</span><br><span class="line">obj is dead</span><br><span class="line">第<span class="number">2</span>次 gc</span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure><p><strong>放开finalize()方法</strong></p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>次 gc</span><br><span class="line">调用当前类重写的finalize()方法</span><br><span class="line">obj is still alive</span><br><span class="line">第<span class="number">2</span>次 gc</span><br><span class="line">obj is dead</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一次自救成功，但由于 finalize() 方法只会执行一次，所以第二次自救失败</p><h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><h3 id="MAT-介绍"><a href="#MAT-介绍" class="headerlink" title="MAT 介绍"></a>MAT 介绍</h3><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p><p>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</p><p>大家可以在<a href="http://www.eclipse.org/mat/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E4%BD%BF%E7%94%A8MAT">http://www.eclipse.org/mat/下载并使用MAT</a></p><blockquote><p>1、虽然Jvisualvm很强大，但是在内存分析方面，还是MAT更好用一些</p><p>2、此小节主要是为了实时分析GC Roots是哪些东西，中间需要用到一个dump的文件</p></blockquote><h3 id="获取-dump-文件方式"><a href="#获取-dump-文件方式" class="headerlink" title="获取 dump 文件方式"></a>获取 dump 文件方式</h3><p><strong>方式一：命令行使用 jmap</strong></p><img src="/2021/03/01/JVM-6/../../../../../jvm/JVM/JVM系列-第10章-垃圾回收概述和相关算法.assets/0009.png"><p><strong>方式二：使用JVisualVM导出</strong></p><ol><li> 捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</li><li> 操作步骤下面演示</li></ol><h3 id="捕捉-dump-示例"><a href="#捕捉-dump-示例" class="headerlink" title="捕捉 dump 示例"></a>捕捉 dump 示例</h3><h4 id="使用JVisualVM捕捉-heap-dump"><a href="#使用JVisualVM捕捉-heap-dump" class="headerlink" title="使用JVisualVM捕捉 heap dump"></a>使用JVisualVM捕捉 heap dump</h4><p>代码：</p><ul><li>  numList 和 birth 在第一次捕捉内存快照的时候，为 GC Roots</li><li>  之后 numList 和 birth 置为 null ，对应的引用对象被回收，在第二次捕捉内存快照的时候，就不再是 GC Roots</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCRootsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Date birth = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line">        numList = <span class="keyword">null</span>;</span><br><span class="line">        birth = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>如何捕捉堆内存快照</strong></p><p>1、先执行第一步，然后停下来，去生成此步骤dump文件</p><p><img src="/2021/03/01/JVM-6/image-20210301214430100.png" alt="image-20210301214430100"></p><p>2、 打开JVisualVM，在左侧Application子窗口中点击相应的应用程序，并选择监视monitor子标签页，点击Heap Dump(堆Dump)按钮</p><p><img src="/2021/03/01/JVM-6/image-20210301214714825.png" alt="image-20210301214714825"></p><p>3、右键 –&gt; 另存为即可</p><p><img src="/2021/03/01/JVM-6/image-20210301214744267.png" alt="image-20210301214744267"></p><p>4、输入命令，继续执行程序</p><p><img src="/2021/03/01/JVM-6/image-20210301214907870.png" alt="image-20210301214907870"></p><p>5、我们接着捕获第二张堆内存快照</p><p><img src="/2021/03/01/JVM-6/image-20210301214940096.png" alt="image-20210301214940096"></p><h4 id="使用-MAT-查看堆内存快照"><a href="#使用-MAT-查看堆内存快照" class="headerlink" title="使用 MAT 查看堆内存快照"></a>使用 MAT 查看堆内存快照</h4><p>1、打开 MAT ，选择File –&gt; Open File，打开刚刚的两个dump文件，<strong>我们先打开第一个dump文件</strong></p><blockquote><p>点击Open Heap Dump也行</p></blockquote><p><img src="/2021/03/01/JVM-6/image-20210301215133120.png" alt="image-20210301215133120"></p><p>2、选择Java Basics –&gt; GC Roots</p><p><img src="/2021/03/01/JVM-6/image-20210301215204319.png" alt="image-20210301215204319"></p><p>3、第一次捕捉堆内存快照时，GC Roots 中包含我们定义的两个局部变量，类型分别为 ArrayList 和 Date，Total:21</p><p><img src="/2021/03/01/JVM-6/image-20210301215435660.png" alt="image-20210301215435660"></p><p>4、打开第二个dump文件，第二次捕获内存快照时，由于两个局部变量引用的对象被释放，所以这两个局部变量不再作为 GC Roots ，从 Total Entries = 19 也可以看出（少了两个 GC Roots）</p><p><img src="/2021/03/01/JVM-6/image-20210301215521930.png" alt="image-20210301215521930"></p><h3 id="JProfiler-GC-Roots-溯源"><a href="#JProfiler-GC-Roots-溯源" class="headerlink" title="JProfiler GC Roots 溯源"></a>JProfiler GC Roots 溯源</h3><p>1、在实际开发中，我们很少会查看所有的GC Roots。一般都是查看某一个或几个对象的GC Root是哪个，这个过程叫<strong>GC Roots 溯源</strong></p><p>2、下面我们使用使用 JProfiler 进行 GC Roots 溯源演示</p><p>依然用下面这个代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCRootsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Date birth = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line">        numList = <span class="keyword">null</span>;</span><br><span class="line">        birth = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1、</p><p><img src="/2021/03/01/JVM-6/image-20210301220119181.png" alt="image-20210301220119181"></p><p>2、</p><p><img src="/2021/03/01/JVM-6/image-20210301220148600.png" alt="image-20210301220148600"></p><p><img src="/2021/03/01/JVM-6/image-20210301220201027.png" alt="image-20210301220201027"></p><p>可以发现颜色变绿了，可以动态的看变化</p><p>3、右击对象，选择 Show Selection In Heap Walker，单独的查看某个对象</p><p><img src="/2021/03/01/JVM-6/image-20210301220335451.png" alt="image-20210301220335451"></p><p><img src="/2021/03/01/JVM-6/image-20210301220348017.png" alt="image-20210301220348017"></p><p>4、选择Incoming <strong>References</strong>，表示追寻 GC Roots 的源头</p><p>点击Show Paths To GC Roots，在弹出界面中选择默认设置即可</p><p><img src="/2021/03/01/JVM-6/image-20210301220456852.png" alt="image-20210301220456852"></p><p><img src="/2021/03/01/JVM-6/image-20210301220531435.png" alt="image-20210301220531435"></p><p><img src="/2021/03/01/JVM-6/image-20210301220544949.png" alt="image-20210301220544949"></p><h3 id="JProfiler-分析-OOM"><a href="#JProfiler-分析-OOM" class="headerlink" title="JProfiler 分析 OOM"></a>JProfiler 分析 OOM</h3><blockquote><p>这里是简单的讲一下，后面篇章会详解</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms8m -Xmx8m </span></span><br><span class="line"><span class="comment"> * -XX:+HeapDumpOnOutOfMemoryError  这个参数的意思是当程序出现OOM的时候就会在当前工程目录生成一个dump文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1MB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> HeapOOM());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出日志</p><p><img src="/2021/03/01/JVM-6/image-20210301220837683.png" alt="image-20210301220837683"></p><p>打开这个dump文件</p><p>1、看Biggest Objects</p><p><img src="/2021/03/01/JVM-6/image-20210301221114955.png" alt="image-20210301221114955"></p><p>2、从 main() 线程中看出问题的代码</p><p><img src="/2021/03/01/JVM-6/image-20210301221235162.png" alt="image-20210301221235162"></p><h2 id="垃圾清除阶段"><a href="#垃圾清除阶段" class="headerlink" title="垃圾清除阶段"></a>垃圾清除阶段</h2><ul><li>当成功<strong>区分</strong>出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，<strong>释放</strong>掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是<ol><li>标记-清除算法（Mark-Sweep）</li><li>复制算法（Copying）</li><li>标记-压缩算法（Mark-Compact）</li></ol></li></ul><h2 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h2><p><strong>背景</strong></p><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会<strong>停止整个程序</strong>（也被称为<strong>stop the world</strong>），<strong>然后进行两项工作</strong>，第一项则是标记，第二项则是清除（STW-标记-清除）</p><ol><li><p>标记：Collector从引用根节点开始遍历，<strong>标记所有被引用的对象</strong>。一般是在对象的Header中记录为可达对象。</p><blockquote><p>注意：标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象</p></blockquote></li><li><p>清除：Collector对堆内存从头到尾进行<strong>线性的遍历</strong>，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</p></li></ol><p><img src="/2021/03/01/JVM-6/image-20210301221957995.png" alt="image-20210301221957995"></p><h3 id="标记-清除算法的缺点"><a href="#标记-清除算法的缺点" class="headerlink" title="标记-清除算法的缺点"></a>标记-清除算法的缺点</h3><ul><li><p>效率不算高(遍历的问题)</p></li><li><p>在进行GC的时候，需要停止整个应用程序(<strong>STW</strong>)，用户体验较差</p></li><li><p>这种方式清理出来的空闲内存是不连续的，产生<strong>内存碎片</strong>，需要维护一个<strong>空闲列表</strong></p><blockquote><p>关于空闲列表是在为对象分配内存的时候提过：</p><ol><li>如果内存规整<ul><li>  采用指针碰撞的方式进行内存分配</li></ul></li><li>如果内存不规整<ul><li>  虚拟机需要维护一个空闲列表</li><li>  采用空闲列表分配内存</li></ul></li></ol></blockquote></li></ul><h3 id="何为清除？"><a href="#何为清除？" class="headerlink" title="何为清除？"></a>何为清除？</h3><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是<strong>覆盖原有的地址</strong>）</p><h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><p><strong>背景</strong></p><ol><li> 为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</li></ol><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p><img src="/2021/03/01/JVM-6/image-20210301222929517.png" alt="image-20210301222929517"></p><blockquote><p>新生代里面就用到了复制算法，Eden区和S0区存活对象整体复制到S1区</p></blockquote><h3 id="复制算法的优缺点"><a href="#复制算法的优缺点" class="headerlink" title="复制算法的优缺点"></a>复制算法的优缺点</h3><p><strong>优点</strong></p><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><p><strong>缺点</strong></p><ul><li><p>此算法的缺点也是很明显的，就是需要两倍的内存空间。</p></li><li><p>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</p><img src="/2021/03/01/JVM-6/../../../../../jvm/JVM/JVM系列-第10章-垃圾回收概述和相关算法.assets/image-20210301223619585.png" alt="image-20210301223619585" style="zoom:67%;"></li></ul><h3 id="复制算法的应用场景"><a href="#复制算法的应用场景" class="headerlink" title="复制算法的应用场景"></a>复制算法的应用场景</h3><ol><li> 如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，效率较高</li><li> 老年代大量的对象存活，那么复制的对象将会有很多，效率会很低</li><li> 在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</li></ol><p><img src="/2021/03/01/JVM-6/image-20210301224150017.png" alt="image-20210301224150017"></p><h2 id="清除阶段：标记-压缩算法（或标记-整理、Mark-Compact）算法"><a href="#清除阶段：标记-压缩算法（或标记-整理、Mark-Compact）算法" class="headerlink" title="清除阶段：标记-压缩算法（或标记-整理、Mark - Compact）算法"></a>清除阶段：标记-压缩算法（或标记-整理、Mark - Compact）算法</h2><p><strong>背景</strong></p><ul><li><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他的算法。</strong></p></li><li><p>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p></li><li><p>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p></li></ul><h3 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h3><ol><li><p> 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p></li><li><p> 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p></li></ol><p><img src="/2021/03/01/JVM-6/image-20210301224448732.png" alt="image-20210301224448732"></p><h3 id="标记-压缩算法与标记-清除算法的比较"><a href="#标记-压缩算法与标记-清除算法的比较" class="headerlink" title="标记-压缩算法与标记-清除算法的比较"></a>标记-压缩算法与标记-清除算法的比较</h3><ol><li><p> 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<strong>标记-清除-压缩（Mark-Sweep-Compact）算法</strong>。</p></li><li><p>二者的本质差异在于标记-清除算法是一种<strong>非移动式的回收算法</strong>，标记-压缩是<strong>移动式的</strong>。是否移动回收后的存活对象是一项优缺点并存的风险决策。</p></li></ol><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><blockquote><p>即复制算法和标记压缩算法可以用指针碰撞，标记清除算法用空闲列表分配</p></blockquote><h3 id="标记-压缩算法的优缺点"><a href="#标记-压缩算法的优缺点" class="headerlink" title="标记-压缩算法的优缺点"></a>标记-压缩算法的优缺点</h3><p><strong>优点</strong></p><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><p><strong>缺点</strong></p><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）</li><li>移动过程中，需要全程暂停用户应用程序。即：<strong>STW</strong></li></ul><h2 id="三种清除阶段的算法比较"><a href="#三种清除阶段的算法比较" class="headerlink" title="三种清除阶段的算法比较"></a>三种清除阶段的算法比较</h2><blockquote><p><strong>对比三种清除阶段的算法</strong></p></blockquote><ul><li><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p></li><li><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p></li></ul><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>Q：难道就没有一种最优的算法吗？</p><p>A：无，没有最好的算法，只有最合适的算法</p><h3 id="为什么要使用分代收集算法"><a href="#为什么要使用分代收集算法" class="headerlink" title="为什么要使用分代收集算法"></a>为什么要使用分代收集算法</h3><ul><li><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p></li><li><p>分代收集算法，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</strong>一般是把Java堆分为新生代和老年代，这样就可以<strong>根据各个年代的特点使用不同的回收算法</strong>，以提高垃圾回收的效率。</p></li><li><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关:</p><ul><li>  比如<strong>Http请求中的Session对象、线程、Socket连接</strong>，这类对象跟业务直接挂钩，因此生命周期比较长。</li><li>  但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：<strong>String对象</strong>，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li></ul></li></ul><blockquote><p><strong>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</strong></p></blockquote><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><h4 id="年轻代（Young-Gen）"><a href="#年轻代（Young-Gen）" class="headerlink" title="年轻代（Young Gen）"></a>年轻代（Young Gen）</h4><blockquote><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁</p></blockquote><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收</p><p>而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p><h4 id="老年代（Tenured-Gen）"><a href="#老年代（Tenured-Gen）" class="headerlink" title="老年代（Tenured Gen）"></a>老年代（Tenured Gen）</h4><blockquote><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁</p></blockquote><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由<strong>标记-清除或者是标记-清除与标记-整理的混合实现</strong>。</p><ul><li><p>Mark阶段的开销与存活对象的数量成正比。</p></li><li><p>Sweep阶段的开销与所管理区域的大小成正相关。</p></li><li><p>Compact阶段的开销与存活对象的数据成正比。</p></li></ul><blockquote><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p></blockquote><h2 id="增量收集算法和分区算法"><a href="#增量收集算法和分区算法" class="headerlink" title="增量收集算法和分区算法"></a>增量收集算法和分区算法</h2><h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><blockquote><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World</strong>状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p></blockquote><h4 id="增量收集算法基本思想"><a href="#增量收集算法基本思想" class="headerlink" title="增量收集算法基本思想"></a>增量收集算法基本思想</h4><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以<strong>让垃圾收集线程和应用程序线程交替执行</strong>。<strong>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</strong></p><blockquote><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong></p></blockquote><h4 id="增量收集算法的缺点"><a href="#增量收集算法的缺点" class="headerlink" title="增量收集算法的缺点"></a>增量收集算法的缺点</h4><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong>。</p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><blockquote><p>主要针对G1收集器来说的</p></blockquote><p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。(目的是降低延迟)</p><ul><li>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</li><li>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li></ul><p><img src="/2021/03/01/JVM-6/image-20210301231908806.png" alt="image-20210301231908806"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾回收概述&quot;&gt;&lt;a href=&quot;#垃圾回收概述&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收概述&quot;&gt;&lt;/a&gt;垃圾回收概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2021/03/01/JVM-6/image-20210227220704364.pn</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="垃圾回收算法" scheme="https://www.gtxhjh.cn/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第五章-StringTable</title>
    <link href="https://www.gtxhjh.cn/2021/02/25/JVM-5/"/>
    <id>https://www.gtxhjh.cn/2021/02/25/JVM-5/</id>
    <published>2021-02-25T11:46:27.000Z</published>
    <updated>2021-02-25T11:47:47.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StringTable（字符串常量池）"><a href="#StringTable（字符串常量池）" class="headerlink" title="StringTable（字符串常量池）"></a>StringTable（字符串常量池）</h1><h2 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h2><ul><li><p>String：字符串，使用一对 “” 引起来表示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;atguigu&quot;</span> ;   <span class="comment">// 字面量的定义方式</span></span><br><span class="line">String s2 =  <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// new 对象的方式</span></span><br></pre></td></tr></table></figure></li><li><p>String被声明为final的，不可被继承</p></li><li><p>String实现了Serializable接口：表示字符串是支持序列化的</p></li><li><p>实现了Comparable接口：表示String可以比较大小</p></li><li><p>String在jdk8及以前内部定义了<code>final char value[]</code>用于存储字符串数据。JDK9时改为<code>byte[]</code></p><p><img src="/2021/02/25/JVM-5/image-20210225150804954.png" alt="image-20210225150804954"></p><p>为什么 JDK9 改变了 String 的结构</p><blockquote><p><strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/254">http://openjdk.java.net/jeps/254</a></p></blockquote><p><strong>为什么改为 byte[] 存储？</strong></p><p>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)，从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费。</p><p>之前 String 类使用 UTF-16 的 char[] 数组存储，现在改为 <strong>byte[] 数组</strong> 外加一个<strong>编码标识</strong>存储。该编码表示如果你的字符是ISO-8859-1或者Latin-1，那么只需要一个字节存。如果你是其它字符集，比如UTF-8，你仍然用两个字节存</p><blockquote><p>String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</p></blockquote><p>同时基于String的数据结构，例如<strong>StringBuffer和StringBuilder也同样做了修改</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value</span><br></pre></td></tr></table></figure></li><li><p>String：代表不可变的字符序列。简称：不可变性。</p><ul><li><p><strong>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</strong></p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String s1 = <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span></span><br><span class="line">       String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">       s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">       System.out.println(s1 == s2);<span class="comment">//判断地址：true  --&gt; false</span></span><br><span class="line">    </span><br><span class="line">       System.out.println(s1);<span class="comment">//</span></span><br><span class="line">       System.out.println(s2);<span class="comment">//abc</span></span><br><span class="line">    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>字节码指令</p><ul><li>  取字符串 “abc” 时，使用的是同一个符号引用：#2</li><li>  取字符串 “hello” 时，使用的是另一个符号引用：#3</li></ul></li><li><p><strong>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    s2 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    System.out.println(s2);<span class="comment">//abcdef</span></span><br><span class="line">    System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s2 = s1.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">    System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">    System.out.println(s2);<span class="comment">//mbc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一道笔试题</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span>[] ch = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span> ch[])</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringExer ex = <span class="keyword">new</span> StringExer();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);<span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>str 的内容并没有变：“test ok” 位于字符串常量池中的另一个区域（地址），进行赋值操作并没有修改原来 str 指向的引用的内容</p></li></ul></li><li><p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p></li><li><p><strong>==String 的底层结构==</strong></p><p><strong>字符串常量池是不会存储相同内容的字符串的</strong>（类似set(map)）</p><p>String的String Pool（字符串常量池）是一个固定大小的<strong>Hashtable</strong>，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()方法时性能会大幅下降。</p><blockquote><p>使用**-XX:StringTablesize**可设置StringTable的长度</p><p>在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求</p><p>在JDK7中，StringTable的长度默认值是60013，StringTablesize设置没有要求</p><p>在JDK8中，StringTable的长度默认值是60013，StringTable可以设置的最小值为1009</p></blockquote><p>例：</p><img src="/2021/02/25/JVM-5/../../../../../jvm/JVM/JVM系列-第9章-StringTable(字符串常量池).assets/0001.png"><img src="/2021/02/25/JVM-5/../../../../../jvm/JVM/JVM系列-第9章-StringTable(字符串常量池).assets/0002.png"><p><strong>测试不同 StringTable 长度下，程序的性能</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产生10万个长度不超过10的字符串，包含a-z,A-Z</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerateString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileWriter fw =  <span class="keyword">new</span> FileWriter(<span class="string">&quot;words.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//1 - 10</span></span><br><span class="line">           <span class="keyword">int</span> length = (<span class="keyword">int</span>)(Math.random() * (<span class="number">10</span> - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">            fw.write(getString(length) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">//65 - 90, 97-122</span></span><br><span class="line">            <span class="keyword">int</span> num = (<span class="keyword">int</span>)(Math.random() * (<span class="number">90</span> - <span class="number">65</span> + <span class="number">1</span>) + <span class="number">65</span>) + (<span class="keyword">int</span>)(Math.random() * <span class="number">2</span>) * <span class="number">32</span>;</span><br><span class="line">            str += (<span class="keyword">char</span>)num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;words.txt&quot;</span>));</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            String data;</span><br><span class="line">            <span class="keyword">while</span>((data = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                data.intern(); <span class="comment">//如果字符串常量池中没有对应data的字符串的话，则在常量池中生成</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1009:143ms  100009:47ms</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>  -XX:StringTableSize=1009 ：程序耗时 143ms</p></li><li><p>  -XX:StringTableSize=100009 ：程序耗时 47ms</p></li></ul></li></ul><h2 id="String-的内存分配"><a href="#String-的内存分配" class="headerlink" title="String 的内存分配"></a>String 的内存分配</h2><ul><li><p>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种<strong>常量池</strong>的概念</p></li><li><p><strong>常量池就类似一个Java系统级别提供的缓存</strong>。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种</p><ol><li><p><strong>直接使用双引号声明出来的String对象会直接存储在常量池</strong>中。比如：<code>String info=&quot;atguigu.com&quot;;</code></p></li><li><p>如果<strong>不是用双引号声明的String对象，可以使用String提供的intern()方法</strong>。这个后面重点谈</p></li></ol></li><li><p>Java 6及以前，字符串常量池存放在<strong>永久代</strong></p></li><li><p>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到<strong>Java堆</strong>内</p><ul><li>  所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行<strong>调优应用时仅需要调整堆大小</strong>就可以了。</li><li>  字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。</li></ul></li><li><p>Java8<strong>元空间</strong>，<strong>字符串常量在堆</strong></p></li></ul><p><img src="/2021/02/25/JVM-5/image-20210225155913559.png" alt="image-20210225155913559"></p><p><img src="/2021/02/25/JVM-5/image-20210225155918417.png" alt="image-20210225155918417"></p><h3 id="StringTable-为什么要调整？"><a href="#StringTable-为什么要调整？" class="headerlink" title="StringTable 为什么要调整？"></a>StringTable 为什么要调整？</h3><blockquote><p><strong>官方文档</strong>:<a href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes</a></p></blockquote><ol><li>为什么要调整位置？<ul><li>  永久代(permSize)的默认空间大小比较小</li><li>  即时空间大，但是永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space</li><li>  堆中空间足够大，字符串可被及时回收</li></ul></li><li> 在JDK 7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。</li><li> 此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。</li></ol><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=6m -XX:MaxPermSize=6m -Xms6m -Xmx6m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=6m -Xms6m -Xmx6m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用Set保持着常量池引用，避免full gc回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">//在short可以取值的范围内足以让6MB的PermSize或heap产生OOM了。</span></span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：字符串在堆中（JDK8）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.HashMap.resize(HashMap.java:<span class="number">703</span>)</span><br><span class="line">at java.util.HashMap.putVal(HashMap.java:<span class="number">662</span>)</span><br><span class="line">at java.util.HashMap.put(HashMap.java:<span class="number">611</span>)</span><br><span class="line">at java.util.HashSet.add(HashSet.java:<span class="number">219</span>)</span><br><span class="line">at com.atguigu.java.StringTest3.main(StringTest3.java:<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="String-的基本操作"><a href="#String-的基本操作" class="headerlink" title="String 的基本操作"></a>String 的基本操作</h2><p>Java语言规范里要求<strong>完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量）</strong>，并且必须是指向同一个String类实例。</p><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println();<span class="comment">//2293</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//2294</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2303</span></span><br><span class="line">        <span class="comment">//如下的字符串&quot;1&quot; 到 &quot;10&quot;不会再次加载</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析字符串常量池的变化</p><p>1、程序启动时已经加载了 2293 个字符串常量</p><p><img src="/2021/02/25/JVM-5/image-20210225160931495.png" alt="image-20210225160931495"></p><p>2、加载了一个换行符（println），所以多了一个</p><p><img src="/2021/02/25/JVM-5/image-20210225160947588.png" alt="image-20210225160947588"></p><p>3、加载了字符串常量 “1”~“9”</p><p><img src="/2021/02/25/JVM-5/image-20210225161004900.png" alt="image-20210225161004900"></p><p>4、加载字符串常量 “10”</p><p><img src="/2021/02/25/JVM-5/image-20210225161011686.png" alt="image-20210225161011686"></p><p>5、之后的字符串”1” 到 “10”不会再次加载</p><p><img src="/2021/02/25/JVM-5/image-20210225161037262.png" alt="image-20210225161037262"></p><h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方示例代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//line 1</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();<span class="comment">//line 3</span></span><br><span class="line">        Memory mem = <span class="keyword">new</span> Memory();<span class="comment">//line 4</span></span><br><span class="line">        mem.foo(obj);<span class="comment">//line 5</span></span><br><span class="line">    &#125;<span class="comment">//line 9</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123;<span class="comment">//line 6</span></span><br><span class="line">        String str = param.toString();<span class="comment">//line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;<span class="comment">//line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析运行时内存（foo() 方法是实例方法，其实图中少了一个 this 局部变量）</p><p><img src="/2021/02/25/JVM-5/image-20210225161300636.png" alt="image-20210225161300636"></p><h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><h3 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h3><ol><li>常量与常量的拼接结果在常量池，原理是<strong>编译期优化</strong></li><li>常量池中不会存在相同内容的变量</li><li>拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在，分为：<ul><li>  如果存在，则返回字符串在常量池中的地址</li><li>  如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址</li></ul></li></ol><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>1、常量与常量的拼接结果在常量池，原理是编译期优化</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">         * String s1 = &quot;abc&quot;; 编译期优化</span></span><br><span class="line"><span class="comment">         * String s2 = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从字节码指令看出：编译器做了优化，将 “a” + “b” + “c” 优化成了 “abc”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0 ldc #2 &lt;abc&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #2 &lt;abc&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line">6 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">9</span> aload_1</span><br><span class="line"><span class="number">10</span> aload_2</span><br><span class="line"><span class="number">11</span> if_acmpne <span class="number">18</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">14</span> iconst_1</span><br><span class="line"><span class="number">15</span> goto <span class="number">19</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">18</span> iconst_0</span><br><span class="line">19 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">22 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">25</span> aload_1</span><br><span class="line"><span class="number">26</span> aload_2</span><br><span class="line">27 invokevirtual #5 &lt;java/lang/String.equals&gt;</span><br><span class="line">30 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">33</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>IDEA 反编译 class 文件后，来看这个问题</p><img src="/2021/02/25/JVM-5/../../../../../jvm/JVM/JVM系列-第9章-StringTable(字符串常量池).assets/0011.png"><p><strong>2、拼接前后，只要其中有一个是变量，结果就在堆中（在堆空间中new String()）、拼接的结果调用intern()方法</strong></p><p><strong>调用 intern() 方法，则主动将字符串对象存入字符串常量池中，并将其地址返回</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">        String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line">        <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">        String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        String s6 = <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">        String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">        <span class="comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span></span><br><span class="line">        String s8 = s6.intern();</span><br><span class="line">        System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从字节码角度来看：拼接前后有变量，都会使用到 StringBuilder 类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0 ldc #6 &lt;javaEE&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #7 &lt;hadoop&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line">6 ldc #8 &lt;javaEEhadoop&gt;</span><br><span class="line"><span class="number">8</span> astore_3</span><br><span class="line">9 ldc #8 &lt;javaEEhadoop&gt;</span><br><span class="line"><span class="number">11</span> astore <span class="number">4</span></span><br><span class="line">13 new #9 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">16</span> dup</span><br><span class="line">17 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">20</span> aload_1</span><br><span class="line">21 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">24 ldc #7 &lt;hadoop&gt;</span><br><span class="line">26 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">29 invokevirtual #12 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">32</span> astore <span class="number">5</span></span><br><span class="line">34 new #9 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">37</span> dup</span><br><span class="line">38 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">41 ldc #6 &lt;javaEE&gt;</span><br><span class="line">43 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">46</span> aload_2</span><br><span class="line">47 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">50 invokevirtual #12 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">53</span> astore <span class="number">6</span></span><br><span class="line">55 new #9 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">58</span> dup</span><br><span class="line">59 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">62</span> aload_1</span><br><span class="line">63 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">66</span> aload_2</span><br><span class="line">67 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">70 invokevirtual #12 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">73</span> astore <span class="number">7</span></span><br><span class="line">75 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">78</span> aload_3</span><br><span class="line"><span class="number">79</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">81</span> if_acmpne <span class="number">88</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">84</span> iconst_1</span><br><span class="line"><span class="number">85</span> goto <span class="number">89</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">88</span> iconst_0</span><br><span class="line">89 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">92 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">95</span> aload_3</span><br><span class="line"><span class="number">96</span> aload <span class="number">5</span></span><br><span class="line"><span class="number">98</span> if_acmpne <span class="number">105</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">101</span> iconst_1</span><br><span class="line"><span class="number">102</span> goto <span class="number">106</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">105</span> iconst_0</span><br><span class="line">106 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">109 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">112</span> aload_3</span><br><span class="line"><span class="number">113</span> aload <span class="number">6</span></span><br><span class="line"><span class="number">115</span> if_acmpne <span class="number">122</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">118</span> iconst_1</span><br><span class="line"><span class="number">119</span> goto <span class="number">123</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">122</span> iconst_0</span><br><span class="line">123 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">126 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">129</span> aload_3</span><br><span class="line"><span class="number">130</span> aload <span class="number">7</span></span><br><span class="line"><span class="number">132</span> if_acmpne <span class="number">139</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">135</span> iconst_1</span><br><span class="line"><span class="number">136</span> goto <span class="number">140</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">139</span> iconst_0</span><br><span class="line">140 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">143 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">146</span> aload <span class="number">5</span></span><br><span class="line"><span class="number">148</span> aload <span class="number">6</span></span><br><span class="line"><span class="number">150</span> if_acmpne <span class="number">157</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">153</span> iconst_1</span><br><span class="line"><span class="number">154</span> goto <span class="number">158</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">157</span> iconst_0</span><br><span class="line">158 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">161 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">164</span> aload <span class="number">5</span></span><br><span class="line"><span class="number">166</span> aload <span class="number">7</span></span><br><span class="line"><span class="number">168</span> if_acmpne <span class="number">175</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">171</span> iconst_1</span><br><span class="line"><span class="number">172</span> goto <span class="number">176</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">175</span> iconst_0</span><br><span class="line">176 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">179 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">182</span> aload <span class="number">6</span></span><br><span class="line"><span class="number">184</span> aload <span class="number">7</span></span><br><span class="line"><span class="number">186</span> if_acmpne <span class="number">193</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">189</span> iconst_1</span><br><span class="line"><span class="number">190</span> goto <span class="number">194</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">193</span> iconst_0</span><br><span class="line">194 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">197</span> aload <span class="number">6</span></span><br><span class="line">199 invokevirtual #13 &lt;java/lang/String.intern&gt;</span><br><span class="line"><span class="number">202</span> astore <span class="number">8</span></span><br><span class="line">204 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">207</span> aload_3</span><br><span class="line"><span class="number">208</span> aload <span class="number">8</span></span><br><span class="line"><span class="number">210</span> if_acmpne <span class="number">217</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">213</span> iconst_1</span><br><span class="line"><span class="number">214</span> goto <span class="number">218</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">217</span> iconst_0</span><br><span class="line">218 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">221</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h3 id="字符串拼接的底层细节"><a href="#字符串拼接的底层细节" class="headerlink" title="字符串拼接的底层细节"></a>字符串拼接的底层细节</h3><h4 id="案例一：加上变量"><a href="#案例一：加上变量" class="headerlink" title="案例一：加上变量"></a>案例一：加上变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">      String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">      String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">      String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span></span><br><span class="line"><span class="comment">      9 new #9 &lt;java/lang/StringBuilder&gt;</span></span><br><span class="line"><span class="comment">      12 dup</span></span><br><span class="line"><span class="comment">      13 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span></span><br><span class="line"><span class="comment">      ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">      16 aload_1</span></span><br><span class="line"><span class="comment">17 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span></span><br><span class="line"><span class="comment">      ② s.append(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">      20 aload_2</span></span><br><span class="line"><span class="comment">21 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span></span><br><span class="line"><span class="comment">      ③ s.append(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">      24 invokevirtual #12 &lt;java/lang/StringBuilder.toString&gt;</span></span><br><span class="line"><span class="comment">      ④ s.toString()  --&gt; 类似于 new String(&quot;ab&quot;)堆中而不在常量池，但不等价</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      String s4 = s1 + s2;<span class="comment">//</span></span><br><span class="line">      System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>字节码指令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0 ldc #14 &lt;a&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #15 &lt;b&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line">6 ldc #16 &lt;ab&gt;</span><br><span class="line"><span class="number">8</span> astore_3</span><br><span class="line">    </span><br><span class="line">9 new #9 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">12</span> dup</span><br><span class="line">13 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">    </span><br><span class="line"><span class="number">16</span> aload_1</span><br><span class="line">17 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">    </span><br><span class="line"><span class="number">20</span> aload_2</span><br><span class="line">21 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">    </span><br><span class="line">24 invokevirtual #12 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">27</span> astore <span class="number">4</span></span><br><span class="line">29 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">32</span> aload_3</span><br><span class="line"><span class="number">33</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">35</span> if_acmpne <span class="number">42</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">38</span> iconst_1</span><br><span class="line"><span class="number">39</span> goto <span class="number">43</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">42</span> iconst_0</span><br><span class="line">43 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">46</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h4 id="案例二：加上常量引用"><a href="#案例二：加上常量引用" class="headerlink" title="案例二：加上常量引用"></a>案例二：加上常量引用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment">       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span></span><br><span class="line"><span class="comment">    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s4 = s1 + s2;</span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从字节码角度来看：为变量 s4 赋值时，直接使用 #16 符号引用，即字符串常量 “ab”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0 ldc #14 &lt;a&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #15 &lt;b&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line">6 ldc #16 &lt;ab&gt;</span><br><span class="line"><span class="number">8</span> astore_3</span><br><span class="line">    </span><br><span class="line">9 ldc #16 &lt;ab&gt;</span><br><span class="line"><span class="number">11</span> astore <span class="number">4</span></span><br><span class="line">13 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">16</span> aload_3</span><br><span class="line"><span class="number">17</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">19</span> if_acmpne <span class="number">26</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">22</span> iconst_1</span><br><span class="line"><span class="number">23</span> goto <span class="number">27</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">26</span> iconst_0</span><br><span class="line">27 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">30</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h3 id="拼接操作与-append-操作的效率对比"><a href="#拼接操作与-append-操作的效率对比" class="headerlink" title="拼接操作与 append 操作的效率对比"></a>拼接操作与 append 操作的效率对比</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        method1(100000);//4014</span></span><br><span class="line">        method2(<span class="number">100000</span>);<span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> highLevel)</span></span>&#123;</span><br><span class="line">        String src = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; highLevel;i++)&#123;</span><br><span class="line">            src = src + <span class="string">&quot;a&quot;</span>;<span class="comment">//每次循环都会创建一个StringBuilder、String</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(src);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> highLevel)</span></span>&#123;</span><br><span class="line">        <span class="comment">//只需要创建一个StringBuilder</span></span><br><span class="line">        StringBuilder src = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">            src.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(src);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h4><p>通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ol><li>StringBuilder的append()的方式：<ul><li>  自始至终中只创建过一个StringBuilder的对象</li></ul></li><li>使用String的字符串拼接方式：<ul><li>  每次循环都会创建一个StringBuilder、String，创建过多个StringBuilder和String（调的toString方法）的对象，内存占用更大；</li><li>  如果进行GC，需要花费额外的时间（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）。</li></ul></li></ol><h4 id="改进的空间"><a href="#改进的空间" class="headerlink" title="改进的空间"></a>改进的空间</h4><p>在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器实例化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder s = <span class="keyword">new</span> StringBuilder(highLevel); <span class="comment">//new char[highLevel]</span></span><br></pre></td></tr></table></figure><p>这样可以避免频繁扩容</p><h2 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern() 的使用"></a>intern() 的使用</h2><h3 id="intern-方法的说明"><a href="#intern-方法的说明" class="headerlink" title="intern() 方法的说明"></a>intern() 方法的说明</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>intern是一个native方法，调用的是底层C的方法</p></li><li><p>字符串常量池池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址。（这是源码里的大概翻译）</p></li><li><p>如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String myInfo = <span class="keyword">new</span> string(<span class="string">&quot;I love atguigu&quot;</span>).intern();</span><br></pre></td></tr></table></figure><blockquote><p>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>).intern()==<span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p></blockquote></li></ul><h3 id="new-String-的说明"><a href="#new-String-的说明" class="headerlink" title="new String() 的说明"></a>new String() 的说明</h3><h4 id="new-String-“ab”-会创建几个对象？"><a href="#new-String-“ab”-会创建几个对象？" class="headerlink" title="new String(“ab”)会创建几个对象？"></a>new String(“ab”)会创建几个对象？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：</span></span><br><span class="line"><span class="comment"> * new String(&quot;ab&quot;)会创建几个对象？看字节码，就知道是两个。</span></span><br><span class="line"><span class="comment"> *     一个对象是：new关键字在堆空间创建的</span></span><br><span class="line"><span class="comment"> *     另一个对象是：字符串常量池中的对象&quot;ab&quot;。 字节码指令：ldc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码指令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0 new #2 &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line">4 ldc #3 &lt;ab&gt;</span><br><span class="line">6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><code>0 new #2 &lt;java/lang/String&gt;</code>：在堆中创建了一个 String 对象</p><p><code>4 ldc #3 &lt;ab&gt;</code> ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）</p><h4 id="new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="new String(“a”) + new String(“b”) 会创建几个对象？"></a>new String(“a”) + new String(“b”) 会创建几个对象？</h4><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思考：</span></span><br><span class="line"><span class="comment"> * new String(&quot;a&quot;) + new String(&quot;b&quot;)呢？</span></span><br><span class="line"><span class="comment"> *  对象1：new StringBuilder()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  对象2： new String(&quot;a&quot;)</span></span><br><span class="line"><span class="comment"> *  对象3： 常量池中的&quot;a&quot;</span></span><br><span class="line"><span class="comment"> *  对象4： new String(&quot;b&quot;)</span></span><br><span class="line"><span class="comment"> *  对象5： 常量池中的&quot;b&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  深入剖析： StringBuilder的toString():</span></span><br><span class="line"><span class="comment"> *      对象6 ：new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment"> *       强调一下，toString()的调用，在字符串常量池中，没有生成&quot;ab&quot;,无ldc ab</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码指令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0 new #2 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line">4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">7 new #4 &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">10</span> dup</span><br><span class="line">11 ldc #5 &lt;a&gt;</span><br><span class="line">13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">    </span><br><span class="line">19 new #4 &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">22</span> dup</span><br><span class="line">23 ldc #8 &lt;b&gt;</span><br><span class="line">25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">    </span><br><span class="line">31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">34</span> astore_1</span><br><span class="line"><span class="number">35</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>答案是4个或5个或6个</strong></p><p>字节码指令分析：</p><ol><li> <code>0 new #2 &lt;java/lang/StringBuilder&gt;</code> ：<em>拼接字符串</em>会创建一个 StringBuilder 对象</li><li> <code>7 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“a”)</li><li> <code>11 ldc #5 &lt;a&gt;</code> ：在字符串常量池中放入 “a”（如果之前字符串常量池中没有 “a” 的话）</li><li> <code>19 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“b”)</li><li> <code>23 ldc #8 &lt;b&gt;</code> ：在字符串常量池中放入 “b”（如果之前字符串常量池中没有 “b” 的话）</li><li> <code>31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</code> ：调用 StringBuilder 的 toString() 方法，会生成一个 String 对象</li></ol><img src="/2021/02/25/JVM-5/../../../../../jvm/JVM/JVM系列-第9章-StringTable(字符串常量池).assets/0012.png" style="zoom:200%;"><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote><p><strong>有点难的面试题</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何保证变量s指向的是字符串常量池中的数据呢？</span></span><br><span class="line"><span class="comment"> * 有两种方式：</span></span><br><span class="line"><span class="comment"> * 方式一： String s = &quot;shkstart&quot;;//字面量定义的方式</span></span><br><span class="line"><span class="comment"> * 方式二： 调用intern()</span></span><br><span class="line"><span class="comment"> *         String s = new String(&quot;shkstart&quot;).intern();</span></span><br><span class="line"><span class="comment"> *         String s = new StringBuilder(&quot;shkstart&quot;).toString().intern();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">// 堆空间中地址</span></span><br><span class="line">        s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span></span><br><span class="line">        String s2 = <span class="string">&quot;1&quot;</span>; <span class="comment">// 常量池中的地址</span></span><br><span class="line">        System.out.println(s == s2);<span class="comment">//jdk6：false   jdk7/8：false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         1、s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line"><span class="comment">         2、经过上面的分析，我们已经知道执行完pos_1的代码，在堆中有了一个new String(&quot;11&quot;)</span></span><br><span class="line"><span class="comment">         这样的String对象。但是在字符串常量池中没有&quot;11&quot;</span></span><br><span class="line"><span class="comment">         3、接着执行s3.intern()，在字符串常量池中生成&quot;11&quot;</span></span><br><span class="line"><span class="comment">           3-1、在JDK6的版本中，字符串常量池还在永久代，所以直接在永久代生成&quot;11&quot;,也就有了新的地址</span></span><br><span class="line"><span class="comment">           3-2、而在JDK7的后续版本中，字符串常量池被移动到了堆中，此时堆里已经有new String（&quot;11&quot;）了出于节省空间的目的，直接将堆中的那个字符串的引用地址储存在字符串常量池中。没错，字符串常量池中存的是new String（&quot;11&quot;）在堆中的地址，此时常量中并没有创建&quot;11&quot;，而是创建一个指向堆空间中new String（&quot;11&quot;）的地址</span></span><br><span class="line"><span class="comment">         4、所以在JDK7后续版本中，s3和s4指向的完全是同一个地址。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//pos_1 由上new String()分析可以知道堆中有new String(&quot;11&quot;)但是字符常量池中没有&quot;11&quot;</span></span><br><span class="line">    s3.intern();<span class="comment">// 字符常量池生成&quot;11&quot;</span></span><br><span class="line">        </span><br><span class="line">        String s4 = <span class="string">&quot;11&quot;</span>;<span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//jdk6：false  jdk7/8：true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="内存图、内存分析"><a href="#内存图、内存分析" class="headerlink" title="内存图、内存分析"></a>内存图、内存分析</h4><p>JDK6 ：正常眼光判断即可</p><ul><li>  new String() 即在堆中</li><li>  str.intern() 则把字符串放入常量池中</li></ul><p><img src="/2021/02/25/JVM-5/image-20210225185503526.png" alt="image-20210225185503526"></p><p>JDK7及后续版本</p><p><img src="/2021/02/25/JVM-5/image-20210225185510461.png" alt="image-20210225185510461"></p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">//代码顺序换一下，在字符串常量池中生成对象&quot;11&quot;</span></span><br><span class="line">        String s4 = <span class="string">&quot;11&quot;</span>;  </span><br><span class="line">        String s5 = s3.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3 是堆中的 &quot;ab&quot; ，s4 是字符串常量池中的 &quot;ab&quot;</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s5 是从字符串常量池中取回来的引用，当然和 s4 相等</span></span><br><span class="line">        System.out.println(s5 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/02/25/JVM-5/image-20210225191355804.png" alt="image-20210225191355804"></p><h3 id="intern-方法的练习"><a href="#intern-方法的练习" class="headerlink" title="intern() 方法的练习"></a>intern() 方法的练习</h3><p><strong>练习 1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String x = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、jdk6中：在字符串常量池（此时在永久代）中创建一个字符串&quot;ab&quot;</span></span><br><span class="line"><span class="comment">        2、jdk8中：字符串常量池（此时在堆中）中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，  将此引用返回</span></span><br><span class="line"><span class="comment">        3、详解看上面</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        String s2 = s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK6</strong></p><p><img src="/2021/02/25/JVM-5/image-20210225191728914.png" alt="image-20210225191728914"></p><p><strong>JDK7/8</strong></p><p><img src="/2021/02/25/JVM-5/image-20210225191858309.png" alt="image-20210225191858309"></p><p><strong>练习2</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加一行这个</span></span><br><span class="line">        String x = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line"></span><br><span class="line">        String s2 = s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/25/JVM-5/image-20210225192002551.png" alt="image-20210225192002551"></p><p><strong>练习3</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">        s1.intern();</span><br><span class="line">        String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>验证</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对象内存地址可以使用System.identityHashCode(object)方法获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//执行完以后，不会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line">        System.out.println(System.identityHashCode(s1));</span><br><span class="line">        s1.intern();</span><br><span class="line">        System.out.println(System.identityHashCode(s1));</span><br><span class="line">        String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(System.identityHashCode(s2));</span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1836019240</span></span><br><span class="line"><span class="number">1836019240</span></span><br><span class="line"><span class="number">1836019240</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="intern-的效率测试（空间角度）"><a href="#intern-的效率测试（空间角度）" class="headerlink" title="intern() 的效率测试（空间角度）"></a>intern() 的效率测试（空间角度）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用intern()测试执行效率：空间使用上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> String[MAX_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] data = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line"><span class="comment">//            arr[i] = new String(String.valueOf(data[i % data.length]));</span></span><br><span class="line">            arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i % data.length])).intern();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、直接 new String ：由于每个 String 对象都是 new 出来的，所以程序需要维护大量存放在堆空间中的 String 实例，程序内存占用也会变高</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i % data.length]));</span><br></pre></td></tr></table></figure><p><img src="/2021/02/25/JVM-5/image-20210225192835950.png" alt="image-20210225192835950"></p><p><img src="/2021/02/25/JVM-5/image-20210225193045636.png" alt="image-20210225193045636"></p><p>2、使用 intern() 方法：由于数组中字符串的引用都指向字符串常量池中的字符串，所以程序需要维护的 String 对象更少，内存占用也更低</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用了intern()方法使用了字符串常量池里的字符串，那么前面堆里的字符串便会被GC掉，这也是intern省内存的关键原因</span></span><br><span class="line">arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i % data.length])).intern();</span><br></pre></td></tr></table></figure><p><img src="/2021/02/25/JVM-5/image-20210225192925259.png" alt="image-20210225192925259"></p><p><img src="/2021/02/25/JVM-5/image-20210225193115189.png" alt="image-20210225193115189"></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省很大的内存空间。</li><li>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</li></ul><h2 id="StringTable-的垃圾回收"><a href="#StringTable-的垃圾回收" class="headerlink" title="StringTable 的垃圾回收"></a>StringTable 的垃圾回收</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的垃圾回收:</span></span><br><span class="line"><span class="comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringGCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            String.valueOf(j).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><ul><li><p>在 PSYoungGen 区发生了垃圾回收</p></li><li><p>Number of entries 和 Number of literals 明显没有 100000</p><p>以上两点均说明 StringTable 区发生了垃圾回收</p></li></ul><img src="/2021/02/25/JVM-5/../../../../../jvm/JVM/JVM系列-第9章-StringTable(字符串常量池).assets/0022.jpg"><img src="/2021/02/25/JVM-5/../../../../../jvm/JVM/JVM系列-第9章-StringTable(字符串常量池).assets/0023.jpg"><h2 id="G1-垃圾收集器的-String-去重操作"><a href="#G1-垃圾收集器的-String-去重操作" class="headerlink" title="G1 垃圾收集器的 String 去重操作"></a>G1 垃圾收集器的 String 去重操作</h2><blockquote><p><strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/192">http://openjdk.java.net/jeps/192</a></p></blockquote><h3 id="String去重操作的背景"><a href="#String去重操作的背景" class="headerlink" title="String去重操作的背景"></a>String去重操作的背景</h3><blockquote><p>注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的</p></blockquote><ol><li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul><li>  堆存活数据集合里面String对象占了25%</li><li>  堆存活数据集合里面重复的String对象有13.5%</li><li>  String对象的平均长度是45</li></ul></li><li> 许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<strong>Java堆中存活的数据集合差不多25%是String对象</strong>。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：<code>str1.equals(str2)= true</code>。<strong>堆上存在重复的String对象必然是一种内存的浪费</strong>。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li></ol><h3 id="String-去重的的实现"><a href="#String-去重的的实现" class="headerlink" title="String 去重的的实现"></a>String 去重的的实现</h3><ol><li> 当垃圾收集器工作的时候，会访问堆上存活的对象。<strong>对每一个访问的对象都会检查是否是候选的要去重的String对象</strong>。</li><li> 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li><li> 使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li> 如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li> 如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。</li></ol><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><ul><li>UseStringDeduplication(bool) ：开启String去重，默认是不开启的，需要手动开启。</li><li>PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息</li><li>stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;StringTable（字符串常量池）&quot;&gt;&lt;a href=&quot;#StringTable（字符串常量池）&quot; class=&quot;headerlink&quot; title=&quot;StringTable（字符串常量池）&quot;&gt;&lt;/a&gt;StringTable（字符串常量池）&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="字符串常量池" scheme="https://www.gtxhjh.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>第四章-执行引擎</title>
    <link href="https://www.gtxhjh.cn/2021/02/24/JVM-4/"/>
    <id>https://www.gtxhjh.cn/2021/02/24/JVM-4/</id>
    <published>2021-02-24T09:29:43.000Z</published>
    <updated>2021-02-24T10:13:46.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h1><p><img src="/2021/02/24/JVM-4/image-20210224143411669.png" alt="image-20210224143411669"></p><h2 id="执行引擎概述-1"><a href="#执行引擎概述-1" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h2><ul><li><p>执行引擎是Java虚拟机核心的组成部分之一。</p></li><li><p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是：</p><ul><li><p>物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上</p></li><li><p>而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<strong>能够执行那些不被硬件直接支持的指令集格式</strong>。</p></li></ul></li><li><p>JVM的主要任务是负责**==装载字节码到其内部==**，但字节码并不能够直接运行在操作系统之上，因为：</p><p><strong>字节码指令</strong>并非等价于本地机器指令，它<strong>内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息</strong></p><p>那么，如果想要让一个Java程序运行起来，==执行引擎==（Execution Engine）的任务就是<strong>将字节码指令解释/编译为对应平台上的本地机器指令才可以</strong></p><blockquote><p>简单来说，J<strong>VM中的执行引擎充当了将高级语言翻译为机器语言的译者</strong></p></blockquote></li></ul><p><img src="/2021/02/24/JVM-4/image-20210224144033917.png" alt="image-20210224144033917"></p><p>注意：</p><blockquote><ul><li><strong>前端编译</strong>：从Java程序员-字节码文件的这个过程叫前端编译</li><li>有字节码后，在虚拟机通过执行引擎翻译成机器指令执行。执行引擎这里有两种行为：一种是解释执行，一种是编译（这里的是<strong>后端编译</strong>）。</li></ul></blockquote><h2 id="执行引擎工作过程"><a href="#执行引擎工作过程" class="headerlink" title="执行引擎工作过程"></a>执行引擎工作过程</h2><blockquote><p><strong>执行引擎工作过程</strong></p></blockquote><ol><li> 执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li> 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li> 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ol><p>从外观上来看，所有的Java虚拟机的执行引擎输入、处理、输出都是一致的：</p><blockquote><p>输入的是字节码二进制流</p><p>处理过程是字节码解析执行、即时编译的等效过程</p><p>输出的是执行过程。</p></blockquote><p><img src="/2021/02/24/JVM-4/image-20210224144618930.png" alt="image-20210224144618930"></p><h1 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h1><h2 id="解释执行和即时编译"><a href="#解释执行和即时编译" class="headerlink" title="解释执行和即时编译"></a>解释执行和即时编译</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤：</p><p><img src="/2021/02/24/JVM-4/image-20210224150702025.png" alt="image-20210224150702025"></p><blockquote><ol><li>前面橙色部分是编译生成生成字节码文件的过程（<strong>javac编译器</strong>来完成，也就是前端编译器），和JVM没有关系</li><li>后面绿色（<strong>解释</strong>执行）和蓝色（即时<strong>编译</strong>）才是JVM需要考虑的过程</li></ol><p>javac编译器（前端编译器）流程图如下所示：</p><p><img src="/2021/02/24/JVM-4/image-20210224150935403.png" alt="image-20210224150935403"></p><p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</p><p><img src="/2021/02/24/JVM-4/image-20210224151156266.png" alt="image-20210224151156266"></p></blockquote><h2 id="什么是解释器？什么是JIT编译器？"><a href="#什么是解释器？什么是JIT编译器？" class="headerlink" title="什么是解释器？什么是JIT编译器？"></a>什么是解释器？什么是JIT编译器？</h2><ul><li><strong>解释器</strong>：当Java虚拟机启动时会根据预定义的规范对字节码采用<strong>逐行</strong>解释的方式<strong>执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li><strong>JIT（Just In Time Compiler）编译器</strong>：就是虚拟机将源代码<strong>一次性直接</strong>编译成和本地机器平台相关的机器语言，<strong>但并不是马上执行</strong>。</li></ul><h2 id="为什么Java是半编译半解释型语言？"><a href="#为什么Java是半编译半解释型语言？" class="headerlink" title="为什么Java是半编译半解释型语言？"></a>为什么Java是半编译半解释型语言？</h2><ul><li>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</li><li>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</li></ul><blockquote><p>JIT编译器将字节码翻译成本地代码后，就可以做一个<strong>缓存</strong>操作，存储在方法区的<strong>JIT 代码缓存</strong>中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化。</p></blockquote><p><strong>用图总结一下</strong></p><p><img src="/2021/02/24/JVM-4/image-20210224151759174.png" alt="image-20210224151759174"></p><h1 id="机器码-指令-汇编语言"><a href="#机器码-指令-汇编语言" class="headerlink" title="机器码 指令 汇编语言"></a>机器码 指令 汇编语言</h1><h2 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h2><ol><li> <strong>各种用二进制编码方式表示的指令</strong>，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</li><li> 机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li><li> 用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li><li> 机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li></ol><h2 id="指令和指令集"><a href="#指令和指令集" class="headerlink" title="指令和指令集"></a>指令和指令集</h2><p><strong>指令</strong></p><ol><li><p> 由于机器码是由0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p></li><li><p> <strong>指令就是把机器码中特定的0和1序列，简化成对应的指令</strong>（一般为英文简写，如mov，inc等），可读性稍好</p></li><li><p> <strong>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同</strong>，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p></li></ol><p><strong>指令集</strong></p><p>不同的硬件平台，各自支持的指令，是有差别的。因此<strong>每个平台所支持的指令，称之为对应平台的指令集</strong>。如常见的</p><ul><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ul><h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><ul><li><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p></li><li><p>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</p></li><li><p>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p><p>由于计算机只认识指令码，所以用汇编语言编写的程序还必须<strong>翻译</strong>（汇编）成机器指令码，计算机才能识别和执行。</p></li></ul><h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><ul><li><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</p></li><li><p>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p></li></ul><p><img src="/2021/02/24/JVM-4/image-20210224154214129.png" alt="image-20210224154214129"></p><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><ol><li><p>字节码是一种<strong>中间状态</strong>（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p></li><li><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p></li><li><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p><p>字节码典型的应用为：Java bytecode</p></li></ol><h2 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h2><p><strong>编译过程又可以分成两个阶段：编译和汇编。</strong></p><ul><li><p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p></li><li><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p></li></ul><p><img src="/2021/02/24/JVM-4/image-20210224154505915.png" alt="image-20210224154505915"></p><h1 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h1><h2 id="为什么要有解释器"><a href="#为什么要有解释器" class="headerlink" title="为什么要有解释器"></a>为什么要有解释器</h2><ul><li><p>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式由高级语言直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法（也就是产生了一个中间产品<strong>字节码</strong>）。</p></li><li><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p></li><li><p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p></li></ul><p><img src="/2021/02/24/JVM-4/image-20210224155641390.png" alt="image-20210224155641390"></p><h2 id="解释器的分类"><a href="#解释器的分类" class="headerlink" title="解释器的分类"></a>解释器的分类</h2><p>在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。</p><ul><li>  <strong>字节码解释器</strong>在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</li><li>  而<strong>模板解释器</strong>将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li></ul><p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p><ul><li>  Interpreter模块：实现了解释器的核心功能</li><li>  Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul><h2 id="解释器的现状"><a href="#解释器的现状" class="headerlink" title="解释器的现状"></a>解释器的现状</h2><ul><li><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。</p></li><li><p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p></li><li><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p></li></ul><h1 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h1><h2 id="Java-代码执行的分类"><a href="#Java-代码执行的分类" class="headerlink" title="Java 代码执行的分类"></a>Java 代码执行的分类</h2><ol><li><p> 第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p></li><li><p> 第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p></li></ol><blockquote><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。<strong>它采用解释器与即时编译器并存的架构</strong>。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。</p></blockquote><h2 id="为啥我们还需要解释器呢？"><a href="#为啥我们还需要解释器呢？" class="headerlink" title="为啥我们还需要解释器呢？"></a>为啥我们还需要解释器呢？</h2><ul><li><p>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p><blockquote><p>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</p></blockquote></li></ul><p><strong>首先明确两点：</strong></p><ul><li>当程序启动后，解释器可以马上发挥作用，<strong>响应速度快</strong>，省去编译的时间，立即执行。</li><li>编译器要想发挥作用，把代码编译成本地代码，<strong>需要一定的执行时间</strong>，但编译为本地代码后，执行效率高。</li></ul><p><strong>所以：</strong></p><p>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</p><p>在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><blockquote><p>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p></blockquote><p>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态（已经运行了一段时间叫热机状态）可以承受的负载要大于冷机状态（刚启动的时候叫冷机状态）</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p><p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—<strong>阿里团队</strong></p><p><img src="/2021/02/24/JVM-4/image-20210224162812293.png" alt="image-20210224162812293"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JITTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="string">&quot;让天下没有难学的技术&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JVisualVM 查看 JIT 编译器执行的编译次数</p><img src="/2021/02/24/JVM-4/../../../../../jvm/JVM/JVM系列-第8章-执行引擎.assets/0012.png"><h2 id="JIT编译器相关概念"><a href="#JIT编译器相关概念" class="headerlink" title="JIT编译器相关概念"></a>JIT编译器相关概念</h2><p>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个<strong>前端编译器</strong>（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。也可能是指虚拟机的<strong>后端运行期编译器</strong>（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。还可能是指使用<strong>静态提前编译器</strong>（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势）</p><p><strong>典型的编译器：</strong></p><ul><li>前端编译器：Sun的javac、Eclipse JDT中的增量式编译器（ECJ）。</li><li>JIT编译器：HotSpot VM的C1、C2编译器。</li><li>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</li></ul><h2 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h2><ul><li><p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<strong>执行的频率</strong>而定。关于那些需要被编译为本地代码的字节码，也被称之为<strong>“热点代码”</strong>，JIT编译器在运行时会<strong>针对那些频繁被调用的“热点代码”</strong>做出<strong>深度优化</strong>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p><blockquote><p>一个被多次调用的方法，或者是一-个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为<strong>栈上替换</strong>，或简称为OSR (On StackReplacement)编译。</p></blockquote><p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠**==热点探测功能==**。</p><p>**目前HotSpot VM所采用的热点探测方式是==基于计数器的热点探测==**。</p><blockquote><p>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p><ul><li><strong>方法调用计数器</strong>用于统计方法的调用次数</li><li><strong>回边计数器</strong>则用于统计循环体执行的循环次数</li></ul></blockquote></li></ul><h3 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h3><ul><li><p>这个计数器就用于统计方法被调用的次数，它的默认阈值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p></li><li><p>这个阈值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</p></li></ul><p><img src="/2021/02/24/JVM-4/image-20210224165554201.png" alt="image-20210224165554201"></p><blockquote><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本</p><ul><li>  如果存在，则优先使用编译后的本地代码来执行</li><li>如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断<strong>方法调用计数器与回边计数器值之和</strong>是否超过方法调用计数器的阈值。<ul><li>  如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li><li>  如果未超过阈值，则使用解释器对字节码文件解释执行</li></ul></li></ul></blockquote><h3 id="热度衰减"><a href="#热度衰减" class="headerlink" title="热度衰减"></a>热度衰减</h3><ul><li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当<strong>超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半</strong>，这个过程称为==方法调用计数器热度的衰减（Counter Decay）==，而这段时间就称为此方法统计的<strong>半衰周期</strong>（Counter Half Life Time）</li><li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 <strong>-XX:-UseCounterDecay</strong> 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li><li>另外，可以使用**-XX:CounterHalfLifeTime**参数设置半衰周期的时间，单位是秒。</li></ul><h3 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h3><p>它的作用是统计一个方法中<strong>循环体代码执行的次数</strong>，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><p><img src="/2021/02/24/JVM-4/image-20210224170104106.png" alt="image-20210224170104106"></p><h2 id="HotSpotVM可以设置程序执行方法-设置模式"><a href="#HotSpotVM可以设置程序执行方法-设置模式" class="headerlink" title="HotSpotVM可以设置程序执行方法-设置模式"></a>HotSpotVM可以设置程序执行方法-设置模式</h2><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ol><li> <strong>-Xint</strong>：完全采用解释器模式执行程序；</li><li> <strong>-Xcomp</strong>：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li> <strong>-Xmixed</strong>：采用解释器+即时编译器的混合模式共同执行程序。</li></ol><img src="/2021/02/24/JVM-4/../../../../../jvm/JVM/JVM系列-第8章-执行引擎.assets/0015.png"><p><strong>代码测试</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试解释器模式和JIT编译模式</span></span><br><span class="line"><span class="comment"> *  -Xint  : 6520ms</span></span><br><span class="line"><span class="comment"> *  -Xcomp : 950ms</span></span><br><span class="line"><span class="comment"> *  -Xmixed : 936ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntCompTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        testPrimeNumber(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPrimeNumber</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">//计算100以内的质数</span></span><br><span class="line">            label:<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= <span class="number">100</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>;k &lt;= Math.sqrt(j);k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j % k == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span> label;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//System.out.println(j);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HotSpotVM-JIT-分类"><a href="#HotSpotVM-JIT-分类" class="headerlink" title="HotSpotVM JIT 分类"></a>HotSpotVM JIT 分类</h2><p>在HotSpot VM中内嵌有两个JIT编译器，分别为<strong>Client Compiler</strong>和<strong>Server Compiler</strong>，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li><p>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；</p><blockquote><p>C1编译器会对字节码进行<strong>简单和可靠的优化，耗时短</strong>，以达到更快的编译速度。</p></blockquote></li><li><p>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。</p><blockquote><p>C2进行<strong>耗时较长的优化，以及激进优化</strong>，但优化的代码执行效率更高。（使用C++）</p></blockquote></li></ul><h2 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h2><ol><li>在不同的编译器上有不同的优化策略，C1编译器上主要有<strong>方法内联，去虚拟化、元余消除</strong>。<ul><li>  方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>  去虚拟化：对唯一的实现类进行内联</li><li>  冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：<ul><li>  标量替换：用标量值代替聚合对象的属性值</li><li>  栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>  同步消除：清除同步操作，通常指synchronized</li></ul></li></ol><blockquote><p>也就是说之前的逃逸分析，只有在C2（server模式下）才会触发。那是否说明C1就用不了了？↓</p></blockquote><h2 id="分层编译策略"><a href="#分层编译策略" class="headerlink" title="分层编译策略"></a>分层编译策略</h2><ul><li><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p></li><li><p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p></li></ul><blockquote><p>一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高</p><p>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</p></blockquote><h3 id="Graal-编译器"><a href="#Graal-编译器" class="headerlink" title="Graal 编译器"></a>Graal 编译器</h3><ul><li><p>自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器</p></li><li><p>编译效果短短几年时间就追平了C2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）</p></li><li><p>目前，带着实验状态标签，需要使用开关参数去激活才能使用</p><blockquote><p>-XX:+UnlockExperimentalvMOptions</p><p>-XX:+UseJVMCICompiler</p></blockquote></li></ul><h3 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h3><ol><li><p>jdk9引入了AOT编译器（静态提前编译器，Ahead of Time Compiler）</p></li><li><p>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p></li><li><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是<strong>在程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<strong>在程序运行之前</strong>，便将字节码转换为机器码的过程。</p><blockquote><p>.java -&gt; .class -&gt; (使用jaotc) .so</p></blockquote></li></ol><p><strong>AOT编译器编译器的优缺点</strong></p><p><strong>最大的好处：</strong></p><p>Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</p><p><strong>缺点：</strong></p><ul><li>破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li><li><strong>降低了Java链接过程的动态性</strong>，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux X64 java base</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;执行引擎概述&quot;&gt;&lt;a href=&quot;#执行引擎概述&quot; class=&quot;headerlink&quot; title=&quot;执行引擎概述&quot;&gt;&lt;/a&gt;执行引擎概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2021/02/24/JVM-4/image-20210224143411669.pn</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="执行引擎" scheme="https://www.gtxhjh.cn/tags/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>第三章_6-对象的实例化内存布局与访问定位</title>
    <link href="https://www.gtxhjh.cn/2021/02/23/JVM-3-6/"/>
    <id>https://www.gtxhjh.cn/2021/02/23/JVM-3-6/</id>
    <published>2021-02-23T08:05:56.000Z</published>
    <updated>2021-02-23T08:10:00.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象的实例化内存布局与访问定位"><a href="#对象的实例化内存布局与访问定位" class="headerlink" title="对象的实例化内存布局与访问定位"></a>对象的实例化内存布局与访问定位</h1><h2 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2><p><strong>大厂面试题</strong></p><p>美团：</p><ol><li> 对象在<code>JVM</code>中是怎么存储的？</li><li> 对象头信息里面有哪些东西？</li></ol><p>蚂蚁金服：</p><p>二面：<code>java</code>对象头里有什么</p><p><img src="/2021/02/23/JVM-3-6/image-20210222221545160.png" alt="image-20210222221545160"></p><h3 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h3><ol><li><p><strong>new</strong></p><ul><li><p>最常见的方式</p></li><li><p>单例类中调用getInstance的静态类方法</p></li><li><p>XXXBuilder/XXXFactory的静态方法</p></li></ul></li><li><p><strong>Class的newInstance方法</strong>（反射的方式），在JDK9里面被标记为过时的方法，因为只能调用空参构造器，并且权限必须为 public</p></li><li><p>**Constructor的newInstance(Xxxx)**（反射的方式），可以调用空参的，或者带参的构造器，权限没有要求</p></li><li><p>**使用clone()**：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone方法</p></li><li><p><strong>使用反序列化</strong>：从文件中，从网络中获取一个对象的二进制流，序列化一般用于Socket的网络传输</p></li><li><p><strong>第三方库 Objenesis</strong></p></li></ol><h3 id="对象创建的步骤"><a href="#对象创建的步骤" class="headerlink" title="对象创建的步骤"></a>对象创建的步骤</h3><blockquote><p><strong>从字节码看待对象的创建过程</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;2, args_size&#x3D;1</span><br><span class="line">         0: new           #2                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Object</span><br><span class="line">         3: dup           </span><br><span class="line">         4: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">        line 10: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">            8       1     1   obj   Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>判断对象对应的类是否加载、链接、初始化</strong></p><p>虚拟机遇到一条<em>new指令</em>，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。</p><p>如果该类没有加载，那么在<strong>双亲委派模式</strong>下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，<em>如果没有</em>找到文件，则抛出ClassNotFoundException异常，<em>如果找到</em>，则进行类加载，并生成对应的Class对象。</p></li><li><p><strong>为对象分配内存</strong></p><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p><ol><li><p>如果内存规整：采用指针碰撞分配内存</p><p>如果内存是规整的，那么虚拟机将采用的是<strong>指针碰撞法</strong>（Bump The Point）来为对象分配内存。</p><blockquote><p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，<strong>分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了</strong>。</p></blockquote><p>如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p><blockquote><p>标记压缩（整理）算法会整理内存碎片解决碎片化问题，堆内存一存对象，另一边为空闲区域</p></blockquote></li><li><p>如果内存不规整</p><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是<strong>空闲列表</strong>来为对象分配内存。</p><blockquote><p>意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</p></blockquote><p><strong>总结：</strong>选择哪种分配方式由Java堆是否规整所决定，而<strong>Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>，标记清除算法清理过后的堆内存，就会存在很多内存碎片。</p></li></ol></li><li><p><strong>处理并发问题</strong></p><ol><li> 采用CAS失败重试、区域加锁保证更新的原子性</li><li> （在Eden区给每个线程分配一块区域）每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）</li></ol></li><li><p><strong>初始化分配到的空间</strong></p><p>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p><p><strong>给对象属性赋值的顺序</strong>：</p><ol><li> 属性的默认值初始化</li><li> 显示初始化/代码块初始化（并列关系，谁先谁后看代码编写的顺序）</li><li> 构造器初始化</li></ol></li><li><p><strong>设置对象的对象头</strong></p><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p></li><li><p><strong>执行init方法进行初始化</strong></p><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p></li></ol><blockquote><p><strong>从字节码角度看 init 方法</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试对象实例化的过程</span></span><br><span class="line"><span class="comment"> *  ① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）</span></span><br><span class="line"><span class="comment"> *  - ⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  给对象的属性赋值的操作：</span></span><br><span class="line"><span class="comment"> *  ① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> Account();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Customer类的字节码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> aload_0</span><br><span class="line"> 1 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">4</span> aload_0</span><br><span class="line"> <span class="number">5</span> sipush <span class="number">1001</span></span><br><span class="line"> 8 putfield #2 &lt;com/atguigu/java/Customer.id&gt;</span><br><span class="line"><span class="number">11</span> aload_0</span><br><span class="line">12 ldc #3 &lt;匿名客户&gt;</span><br><span class="line">14 putfield #4 &lt;com/atguigu/java/Customer.name&gt;</span><br><span class="line"><span class="number">17</span> aload_0</span><br><span class="line">18 new #5 &lt;com/atguigu/java/Account&gt;</span><br><span class="line"><span class="number">21</span> dup</span><br><span class="line">22 invokespecial #6 &lt;com/atguigu/java/Account.&lt;init&gt;&gt;</span><br><span class="line">25 putfield #7 &lt;com/atguigu/java/Customer.acct&gt;</span><br><span class="line"><span class="number">28</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li><p>init() 方法的字节码指令：</p><ul><li>  属性的默认值初始化：<code>id = 1001;</code></li><li>  显示初始化/代码块初始化：<code>name = &quot;匿名客户&quot;;</code></li><li>  构造器初始化：<code>acct = new Account();</code></li></ul></li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><img src="/2021/02/23/JVM-3-6/../../../../../jvm/JVM/JVM系列-第7章-对象的实例化内存布局与访问定位.assets/image-20210222221623357.png" alt="image-20210222221623357" style="zoom:200%;"><blockquote><p><strong>内存布局总结</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> Account();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Customer cust = <span class="keyword">new</span> Customer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解内存布局</p><p><img src="/2021/02/23/JVM-3-6/image-20210222222110165.png" alt="image-20210222222110165"></p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p><strong>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</strong></p><p><img src="/2021/02/23/JVM-3-6/image-20210222222737419.png" alt="image-20210222222737419"></p><p>==定位，通过栈上reference访问==</p><p><strong>对象的两种访问方式：==句柄访问和直接指针==</strong></p><p><strong>1、句柄访问</strong></p><ol><li> 缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低</li><li> 优点：reference中存储<strong>稳定</strong>句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会<em>改变句柄中实例数据指针即可</em>，reference本身不需要被修改</li></ol><p><img src="/2021/02/23/JVM-3-6/image-20210222222834531.png" alt="image-20210222222834531"></p><p><strong>2、直接指针（HotSpot采用）</strong></p><ol><li> 优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</li><li> 缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值</li></ol><p><img src="/2021/02/23/JVM-3-6/image-20210222222903242.png" alt="image-20210222222903242"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对象的实例化内存布局与访问定位&quot;&gt;&lt;a href=&quot;#对象的实例化内存布局与访问定位&quot; class=&quot;headerlink&quot; title=&quot;对象的实例化内存布局与访问定位&quot;&gt;&lt;/a&gt;对象的实例化内存布局与访问定位&lt;/h1&gt;&lt;h2 id=&quot;对象的实例化&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第三章_5-方法区</title>
    <link href="https://www.gtxhjh.cn/2021/02/23/JVM-3-5/"/>
    <id>https://www.gtxhjh.cn/2021/02/23/JVM-3-5/</id>
    <published>2021-02-23T08:05:43.000Z</published>
    <updated>2021-02-23T08:09:25.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p><strong>从线程共享与否的角度来看</strong></p><p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型场景就是数据库连接管理，以及会话管理。</p><p><img src="/2021/02/23/JVM-3-5/image-20210219203739470.png" alt="image-20210219203739470"></p><p><strong>栈、堆、方法区的交互关系</strong></p><p><strong>下面涉及了对象的访问定位</strong></p><ol><li> Person 类的 .class 信息存放在方法区中</li><li> person 变量存放在 Java 栈的局部变量表(栈)中</li><li> 真正的 person 对象存放在 Java 堆中</li></ol><p><img src="/2021/02/23/JVM-3-5/image-20210219204048802.png" alt="image-20210219204048802"></p><blockquote><p>在 person 对象中，有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的</p></blockquote><h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4</a></p></blockquote><h3 id="方法区位置"><a href="#方法区位置" class="headerlink" title="方法区位置"></a>方法区位置</h3><ul><li>《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li><li>所以，<strong>方法区可以看作是一块独立于Java堆的内存空间</strong>。</li></ul><p><img src="/2021/02/23/JVM-3-5/image-20210219212531363.png" alt="image-20210219212531363"></p><h3 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h3><p><strong>方法区主要存放的是 Class，而堆中主要存放的是实例化的对象</strong></p><ul><li>方法区（Method Area）与Java堆一样，是<strong>各个线程共享的内存区域</strong>。多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等待该线程加载完毕，然后直接使用该类，即类只能加载一次。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code><ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><p><strong>代码举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的程序，加载了1600多个类</p><img src="/2021/02/23/JVM-3-5/../../../../../jvm/JVM/JVM系列-第6章-方法区.assets/0004.png"><h3 id="HotSpot方法区演进"><a href="#HotSpot方法区演进" class="headerlink" title="HotSpot方法区演进"></a>HotSpot方法区演进</h3><ul><li>在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。我们可以将方法区类比为Java中的接口，将永久代或元空间类比为Java中具体的实现类(改成使用本地内存并称为元空间)</li><li>本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。<ul><li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOm（因为使用java虚拟机内存，超过-XX:MaxPermsize上限）</li><li>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</li></ul></li><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong>。（那么元空间的大小限制仅限于本地内存的限制）</li><li>永久代、元空间二者并不只是名字变了，内部结构也调整了</li><li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</li></ul><p><img src="/2021/02/23/JVM-3-5/image-20210219213856635.png" alt="image-20210219213856635"></p><h2 id="设置方法区大小与-OOM"><a href="#设置方法区大小与-OOM" class="headerlink" title="设置方法区大小与 OOM"></a>设置方法区大小与 OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p><h3 id="JDK7及以前-永久代"><a href="#JDK7及以前-永久代" class="headerlink" title="JDK7及以前(永久代)"></a>JDK7及以前(永久代)</h3><ol><li> 通过-XX:Permsize来设置永久代初始分配空间。默认值是20.75M</li><li> -XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li> 当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li></ol><p><img src="/2021/02/23/JVM-3-5/image-20210219215529004.png" alt="image-20210219215529004"></p><h3 id="JDK8及以后-元空间"><a href="#JDK8及以后-元空间" class="headerlink" title="JDK8及以后(元空间)"></a>JDK8及以后(元空间)</h3><blockquote><p><strong>JDK8 版本设置元空间大小</strong></p></blockquote><ol><li><p> 元数据区大小可以使用参数 <strong>-XX:MetaspaceSize</strong> 和 <strong>-XX:MaxMetaspaceSize</strong> 指定</p></li><li><p> 默认值依赖于平台，Windows下，-XX:MetaspaceSize 约为21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p></li><li><p> 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p></li><li><p> -XX:MetaspaceSize：设置初始的元空间大小。对于一个 64位 的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，<strong>Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置</strong>。<strong>新的高水位线的值取决于GC后释放了多少元空间</strong>。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p></li><li><p> <strong>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次</strong>。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，<strong>建议将-XX:MetaspaceSize设置为一个相对较高的值</strong>。</p></li></ol><h3 id="方法区OOM"><a href="#方法区OOM" class="headerlink" title="方法区OOM"></a>方法区OOM</h3><p>举例：</p><p>代码：OOMTest 类继承 ClassLoader 类，获得 defineClass() 方法，可自己进行类的加载</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6/7中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OOMTest test = <span class="keyword">new</span> OOMTest();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>不设置元空间的上限</strong></p><p>使用默认的 JVM 参数，元空间不设置上限</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure><p><strong>设置元空间的上限</strong></p><p>JVM 参数</p><p>-XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">8531</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">763</span>)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">642</span>)</span><br><span class="line">at com.atguigu.java.OOMTest.main(OOMTest.java:<span class="number">29</span>)</span><br></pre></td></tr></table></figure><h3 id="如何解决OOM"><a href="#如何解决OOM" class="headerlink" title="如何解决OOM"></a>如何解决OOM</h3><blockquote><p>这个属于<strong>调优的问题</strong>，这里先简单的说一下</p></blockquote><ol><li><p>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</p><blockquote><p><strong>内存泄漏</strong>就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还<strong>和GC ROOT有关联，所以导致以后这些对象也不会被回收</strong>，这就是内存泄漏的问题</p></blockquote></li><li><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p></li><li><p>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p></li></ol><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><h3 id="方法区存储什么？"><a href="#方法区存储什么？" class="headerlink" title="方法区存储什么？"></a>方法区存储什么？</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><img src="/2021/02/23/JVM-3-5/image-20210219221554285.png" alt="image-20210219221554285"></p><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：</p><blockquote><p>它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p></blockquote><p><img src="/2021/02/23/JVM-3-5/image-20210219221729828.png" alt="image-20210219221729828"></p><p><strong>类型信息</strong></p><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ol><li> 这个类型的完整有效名称（全名=包名.类名）</li><li> 这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li><li> 这个类型的修饰符（public，abstract，final的某个子集）</li><li> 这个类型直接接口的一个有序列表</li></ol><p><strong>域（Field）信息</strong></p><blockquote><p>也就是我们常说的成员变量，域信息是比较官方的称呼</p></blockquote><ol><li> JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li><li> 域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</li></ol><p><strong>方法（Method）信息</strong></p><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ol><li> 方法名称</li><li> 方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class</li><li> 方法参数的数量和类型（按顺序）</li><li> 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li> 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li> 异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试方法区的内部构成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String str = <span class="string">&quot;测试方法的内部结构&quot;</span>;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> cal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>javap -v -p MethodInnerStrucTest.class &gt; test.txt</code></p><ul><li>反编译字节码文件，并输出值文本文件中，便于查看。参数 -p 确保能查看 private 权限类型的字段或方法</li></ul><p>字节码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter09/com/atguigu/java/MethodInnerStrucTest.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">13</span>; size <span class="number">1626</span> bytes</span><br><span class="line">  MD5 checksum 0d0fcb54854d4ce183063df985141ad0</span><br><span class="line">  Compiled from <span class="string">&quot;MethodInnerStrucTest.java&quot;</span></span><br><span class="line"><span class="comment">//类型信息      </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java</span>.<span class="title">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #18.#52        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #17.#53        // com/atguigu/java/MethodInnerStrucTest.num:I</span><br><span class="line">   #3 = Fieldref           #54.#55        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Class              #56            // java/lang/StringBuilder</span><br><span class="line">   #5 = Methodref          #4.#52         // java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #6 = String             #57            // count =</span><br><span class="line">   #7 = Methodref          #4.#58         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">   #8 = Methodref          #4.#59         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">   #9 = Methodref          #4.#60         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">  #10 = Methodref          #61.#62        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #11 = Class              #63            // java/lang/Exception</span><br><span class="line">  #12 = Methodref          #11.#64        // java/lang/Exception.printStackTrace:()V</span><br><span class="line">  #13 = Class              #65            // java/lang/String</span><br><span class="line">  #14 = Methodref          #17.#66        // com/atguigu/java/MethodInnerStrucTest.compareTo:(Ljava/lang/String;)I</span><br><span class="line">  #15 = String             #67            // 测试方法的内部结构</span><br><span class="line">  #16 = Fieldref           #17.#68        // com/atguigu/java/MethodInnerStrucTest.str:Ljava/lang/String;</span><br><span class="line">  #17 = Class              #69            // com/atguigu/java/MethodInnerStrucTest</span><br><span class="line">  #18 = Class              #70            // java/lang/Object</span><br><span class="line">  #19 = Class              #71            // java/lang/Comparable</span><br><span class="line">  #20 = Class              #72            // java/io/Serializable</span><br><span class="line">  #21 = Utf8               num</span><br><span class="line">  #22 = Utf8               I</span><br><span class="line">  #23 = Utf8               str</span><br><span class="line">  #24 = Utf8               Ljava/lang/String;</span><br><span class="line">  #25 = Utf8               &lt;init&gt;</span><br><span class="line">  #26 = Utf8               ()V</span><br><span class="line">  #27 = Utf8               Code</span><br><span class="line">  #28 = Utf8               LineNumberTable</span><br><span class="line">  #29 = Utf8               LocalVariableTable</span><br><span class="line">  #30 = Utf8               this</span><br><span class="line">  #31 = Utf8               Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">  #32 = Utf8               test1</span><br><span class="line">  #33 = Utf8               count</span><br><span class="line">  #34 = Utf8               test2</span><br><span class="line">  #35 = Utf8               (I)I</span><br><span class="line">  #36 = Utf8               value</span><br><span class="line">  #37 = Utf8               e</span><br><span class="line">  #38 = Utf8               Ljava/lang/Exception;</span><br><span class="line">  #39 = Utf8               cal</span><br><span class="line">  #40 = Utf8               result</span><br><span class="line">  #41 = Utf8               StackMapTable</span><br><span class="line">  #42 = Class              #63            // java/lang/Exception</span><br><span class="line">  #43 = Utf8               compareTo</span><br><span class="line">  #44 = Utf8               (Ljava/lang/String;)I</span><br><span class="line">  #45 = Utf8               o</span><br><span class="line">  #46 = Utf8               (Ljava/lang/Object;)I</span><br><span class="line">  #47 = Utf8               &lt;clinit&gt;</span><br><span class="line">  #48 = Utf8               Signature</span><br><span class="line">  #49 = Utf8               Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span><br><span class="line">  #50 = Utf8               SourceFile</span><br><span class="line">  #51 = Utf8               MethodInnerStrucTest.java</span><br><span class="line">  #52 = NameAndType        #25:#26        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #53 = NameAndType        #21:#22        // num:I</span><br><span class="line">  #54 = Class              #73            // java/lang/System</span><br><span class="line">  #55 = NameAndType        #74:#75        // out:Ljava/io/PrintStream;</span><br><span class="line">  #56 = Utf8               java/lang/StringBuilder</span><br><span class="line">  #57 = Utf8               count =</span><br><span class="line">  #58 = NameAndType        #76:#77        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #59 = NameAndType        #76:#78        // append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">  #60 = NameAndType        #79:#80        // toString:()Ljava/lang/String;</span><br><span class="line">  #61 = Class              #81            // java/io/PrintStream</span><br><span class="line">  #62 = NameAndType        #82:#83        // println:(Ljava/lang/String;)V</span><br><span class="line">  #63 = Utf8               java/lang/Exception</span><br><span class="line">  #64 = NameAndType        #84:#26        // printStackTrace:()V</span><br><span class="line">  #65 = Utf8               java/lang/String</span><br><span class="line">  #66 = NameAndType        #43:#44        // compareTo:(Ljava/lang/String;)I</span><br><span class="line">  #67 = Utf8               测试方法的内部结构</span><br><span class="line">  #68 = NameAndType        #23:#24        // str:Ljava/lang/String;</span><br><span class="line">  #69 = Utf8               com/atguigu/java/MethodInnerStrucTest</span><br><span class="line">  #70 = Utf8               java/lang/Object</span><br><span class="line">  #71 = Utf8               java/lang/Comparable</span><br><span class="line">  #72 = Utf8               java/io/Serializable</span><br><span class="line">  #73 = Utf8               java/lang/System</span><br><span class="line">  #74 = Utf8               out</span><br><span class="line">  #75 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #76 = Utf8               append</span><br><span class="line">  #77 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #78 = Utf8               (I)Ljava/lang/StringBuilder;</span><br><span class="line">  #79 = Utf8               toString</span><br><span class="line">  #80 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #81 = Utf8               java/io/PrintStream</span><br><span class="line">  #82 = Utf8               println</span><br><span class="line">  #83 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #84 = Utf8               printStackTrace</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//域信息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.lang.String str;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法信息</span></span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java.MethodInnerStrucTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         7: putfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         6: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        10: invokespecial #5                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        13: ldc           #6                  // String count =</span><br><span class="line">        15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: bipush        <span class="number">30</span></span><br><span class="line">         <span class="number">4</span>: istore_2</span><br><span class="line">         <span class="number">5</span>: iload_2</span><br><span class="line">         <span class="number">6</span>: iload_0</span><br><span class="line">         <span class="number">7</span>: idiv</span><br><span class="line">         <span class="number">8</span>: istore_1</span><br><span class="line">         <span class="number">9</span>: goto          <span class="number">17</span></span><br><span class="line">        <span class="number">12</span>: astore_2</span><br><span class="line">        <span class="number">13</span>: aload_2</span><br><span class="line">        14: invokevirtual #12                 // Method java/lang/Exception.printStackTrace:()V</span><br><span class="line">        <span class="number">17</span>: iload_1</span><br><span class="line">        <span class="number">18</span>: ireturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">2</span>     <span class="number">9</span>    <span class="number">12</span>   Class java/lang/Exception</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">21</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">5</span></span><br><span class="line">        line <span class="number">27</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">25</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">26</span>: <span class="number">13</span></span><br><span class="line">        line <span class="number">28</span>: <span class="number">17</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">5</span>       <span class="number">4</span>     <span class="number">2</span> value   I</span><br><span class="line">           <span class="number">13</span>       <span class="number">4</span>     <span class="number">2</span>     e   Ljava/lang/Exception;</span><br><span class="line">            <span class="number">0</span>      <span class="number">19</span>     <span class="number">0</span>   cal   I</span><br><span class="line">            <span class="number">2</span>      <span class="number">17</span>     <span class="number">1</span> result   I</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">12</span></span><br><span class="line">          locals = [ <span class="keyword">int</span>, <span class="keyword">int</span> ]</span><br><span class="line">          stack = [ class java/lang/Exception ]</span><br><span class="line">        frame_type = <span class="number">4</span> <span class="comment">/* same */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    descriptor: (Ljava/lang/String;)I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">33</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">2</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">2</span>     <span class="number">1</span>     o   Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">    descriptor: (Ljava/lang/Object;)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: aload_1</span><br><span class="line">         2: checkcast     #13                 // class java/lang/String</span><br><span class="line">         5: invokevirtual #14                 // Method compareTo:(Ljava/lang/String;)I</span><br><span class="line">         <span class="number">8</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: ldc           #15                 // String 测试方法的内部结构</span><br><span class="line">         2: putstatic     #16                 // Field str:Ljava/lang/String;</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">Signature: #49                          // Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span><br><span class="line">SourceFile: <span class="string">&quot;MethodInnerStrucTest.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>类型信息</strong></p><p>在运行时方法区中，类信息中记录了哪个加载器加载了该类，同时类加载器也记录了它加载了哪些类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型信息      </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java</span>.<span class="title">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><strong>域信息</strong></p><ol><li> descriptor: I 表示字段类型为 Integer</li><li> flags: ACC_PUBLIC 表示字段权限修饰符为 public</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//域信息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.lang.String str;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC</span><br></pre></td></tr></table></figure><p><strong>方法信息</strong></p><ol><li> descriptor: ()V 表示方法返回值类型为 void</li><li> flags: ACC_PUBLIC 表示方法权限修饰符为 public</li><li> stack=3 表示操作数栈深度为 3</li><li> locals=2 表示局部变量个数为 2 个（实力方法包含 this）</li><li> test1() 方法虽然没有参数，但是其 args_size=1 ，这时因为将 this 作为了参数</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         6: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        10: invokespecial #5                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        13: ldc           #6                  // String count =</span><br><span class="line">        15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="non-final-类型的类变量"><a href="#non-final-类型的类变量" class="headerlink" title="non-final 类型的类变量"></a>non-final 类型的类变量</h3><ol><li><p> 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p></li><li><p> 类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p></li></ol><p><strong>举例</strong></p><ol><li> 如下代码所示，即使我们把order设置为null，也不会出现空指针异常</li><li> 这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例(hello定义为了static)</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello!</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="补充说明：全局常量：static-final"><a href="#补充说明：全局常量：static-final" class="headerlink" title="补充说明：全局常量：static final"></a>补充说明：全局常量：static final</h4><ol><li><p> ==全局常量就是使用 static final 进行修饰==</p></li><li><p> 被声明为final的类变量的处理方法则不同，<strong>每个全局常量在编译的时候就会被分配了</strong>。</p></li></ol><p>查看上面代码，这部分的字节码指令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="keyword">int</span> <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了，constantValue已写入。而静态属性只是在prepare阶段做默认初始化，在initialization阶段才写入。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><h4 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h4><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><p>后面会细讲常量池，这里为了讲清楚方法区，简单带一下。</p></blockquote><p><img src="/2021/02/23/JVM-3-5/image-20210219234137887.png" alt="image-20210219234137887"></p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池。（之前的字节码文件中已经看到了很多<strong>Constant pool</strong>的东西，这个就是常量池）</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li></ul><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外。还包含一项信息就是<strong>常量池表</strong>（<strong>Constant Pool Table</strong>），包括各种<strong>字面量和对类型、域和方法的符号引用</strong>。</p><blockquote><p>字面量： 10 ， “我是某某”这种数字和字符串都是字面量</p></blockquote><p><img src="/2021/02/23/JVM-3-5/image-20210219234919606.png" alt="image-20210219234919606"></p><h6 id="为什么需要常量池？"><a href="#为什么需要常量池？" class="headerlink" title="为什么需要常量池？"></a><strong>为什么需要常量池？</strong></h6><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而<strong>Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池。这个字节码包含了指向常量池的引用</strong>。在动态链接的时候会用到运行时常量池，之前有介绍</p><p>比如：如下的代码：</p><pre><code>public class SimpleClass &#123;    public void sayHello() &#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;</code></pre><ul><li>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。</li><li>比如说我们这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。我们可以将”hello”等所需用到的结构信息记录在常量池中，并通过<strong>引用的方式</strong>，来加载、调用所需的结构</li><li>这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</li></ul><p><img src="/2021/02/23/JVM-3-5/image-20210219235206901.png" alt="image-20210219235206901"></p><h6 id="常量池中有啥？"><a href="#常量池中有啥？" class="headerlink" title="常量池中有啥？"></a><strong>常量池中有啥？</strong></h6><ol><li> 数量值</li><li> 字符串值</li><li> 类引用</li><li> 字段引用</li><li> 方法引用</li></ol><p>MethodInnerStrucTest 的 test1方法的字节码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">20</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> 3 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"> 6 new #4 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"> <span class="number">9</span> dup</span><br><span class="line">10 invokespecial #5 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">13 ldc #6 &lt;count = &gt;</span><br><span class="line">15 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">18</span> iload_1</span><br><span class="line">19 invokevirtual #8 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">22 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line">25 invokevirtual #10 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">28</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1、#3，#5等等这些带# 的，都是引用了常量池。</p><h6 id="常量池总结"><a href="#常量池总结" class="headerlink" title="常量池总结"></a><strong>常量池总结</strong></h6><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h5 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="==运行时常量池=="></a>==运行时常量池==</h5><ol><li><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p></li><li><p>常量池表（Constant Pool Table）是Class字节码文件的一部分，<em>用于存放编译期生成的各种字面量与符号引用</em>，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。</p><blockquote><p>运行时常量池就是常量池在程序运行时的称呼</p><p>即字节码文件中，每个类和接口对应常量池表在运行时的表现形式</p></blockquote></li><li><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p></li><li><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过<strong>索引访问</strong>的。</p></li><li><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址</strong>。</p><blockquote><p>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性</p></blockquote></li><li><p>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</p></li><li><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。</p></li></ol><p>运行时常量池中有两种类型，分别是symbolic references符号引用和static constants静态常量。</p><p>其中静态常量不需要后续解析，而符号引用需要进一步进行解析处理。</p><blockquote><p>什么是静态常量，什么是符号引用呢？ 举个直观的例子 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String site=<span class="string">&quot;www.flydean.com&quot;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>字符串”<a href="http://www.flydean.com&quot;可以看做是一个静态常量,因为它是不会变化的/">www.flydean.com&quot;可以看做是一个静态常量，因为它是不会变化的</a> </p><p>site的值是可以变化的，我们不能在第一时间确定其真正的值，需要在动态运行中进行解析 </p></blockquote><h2 id="方法区的使用举例"><a href="#方法区的使用举例" class="headerlink" title="方法区的使用举例"></a>方法区的使用举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x / y;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>字节码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">MethodAreaDemo</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">51</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#24         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = Methodref          #27.#28        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #4 = Class              #29            // com/atguigu/java1/MethodAreaDemo</span><br><span class="line">   #5 = Class              #30            // java/lang/Object</span><br><span class="line">   #6 = Utf8               &lt;init&gt;</span><br><span class="line">   #7 = Utf8               ()V</span><br><span class="line">   #8 = Utf8               Code</span><br><span class="line">   #9 = Utf8               LineNumberTable</span><br><span class="line">  #10 = Utf8               LocalVariableTable</span><br><span class="line">  #11 = Utf8               this</span><br><span class="line">  #12 = Utf8               Lcom/atguigu/java1/MethodAreaDemo;</span><br><span class="line">  #13 = Utf8               main</span><br><span class="line">  #14 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #15 = Utf8               args</span><br><span class="line">  #16 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #17 = Utf8               x</span><br><span class="line">  #18 = Utf8               I</span><br><span class="line">  #19 = Utf8               y</span><br><span class="line">  #20 = Utf8               a</span><br><span class="line">  #21 = Utf8               b</span><br><span class="line">  #22 = Utf8               SourceFile</span><br><span class="line">  #23 = Utf8               MethodAreaDemo.java</span><br><span class="line">  #24 = NameAndType        #6:#7          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #25 = Class              #31            // java/lang/System</span><br><span class="line">  #26 = NameAndType        #32:#33        // out:Ljava/io/PrintStream;</span><br><span class="line">  #27 = Class              #34            // java/io/PrintStream</span><br><span class="line">  #28 = NameAndType        #35:#36        // println:(I)V</span><br><span class="line">  #29 = Utf8               com/atguigu/java1/MethodAreaDemo</span><br><span class="line">  #30 = Utf8               java/lang/Object</span><br><span class="line">  #31 = Utf8               java/lang/System</span><br><span class="line">  #32 = Utf8               out</span><br><span class="line">  #33 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #34 = Utf8               java/io/PrintStream</span><br><span class="line">  #35 = Utf8               println</span><br><span class="line">  #36 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.MethodAreaDemo();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/MethodAreaDemo;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: sipush        <span class="number">500</span></span><br><span class="line">         <span class="number">3</span>: istore_1</span><br><span class="line">         <span class="number">4</span>: bipush        <span class="number">100</span></span><br><span class="line">         <span class="number">6</span>: istore_2</span><br><span class="line">         <span class="number">7</span>: iload_1</span><br><span class="line">         <span class="number">8</span>: iload_2</span><br><span class="line">         <span class="number">9</span>: idiv</span><br><span class="line">        <span class="number">10</span>: istore_3</span><br><span class="line">        <span class="number">11</span>: bipush        <span class="number">50</span></span><br><span class="line">        <span class="number">13</span>: istore        <span class="number">4</span></span><br><span class="line">        15: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">18</span>: iload_3</span><br><span class="line">        <span class="number">19</span>: iload         <span class="number">4</span></span><br><span class="line">        <span class="number">21</span>: iadd</span><br><span class="line">        22: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">7</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">15</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">25</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">26</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">4</span>      <span class="number">22</span>     <span class="number">1</span>     x   I</span><br><span class="line">            <span class="number">7</span>      <span class="number">19</span>     <span class="number">2</span>     y   I</span><br><span class="line">           <span class="number">11</span>      <span class="number">15</span>     <span class="number">3</span>     a   I</span><br><span class="line">           <span class="number">15</span>      <span class="number">11</span>     <span class="number">4</span>     b   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;MethodAreaDemo.java&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="图解字节码指令执行流程"><a href="#图解字节码指令执行流程" class="headerlink" title="图解字节码指令执行流程"></a>图解字节码指令执行流程</h4><p>1、初始状态</p><p><img src="/2021/02/23/JVM-3-5/image-20210220153544099.png" alt="image-20210220153544099"></p><p>2、首先将操作数500压入操作数栈中</p><p><img src="/2021/02/23/JVM-3-5/image-20210220153558182.png" alt="image-20210220153558182"></p><p>3、然后操作数 500 从操作数栈中取出，存储到局部变量表中索引为 1 的位置</p><p><img src="/2021/02/23/JVM-3-5/image-20210220153619025.png" alt="image-20210220153619025"></p><p>4、</p><p><img src="/2021/02/23/JVM-3-5/image-20210220153714684.png" alt="image-20210220153714684"></p><p>5、</p><p><img src="/2021/02/23/JVM-3-5/image-20210220153727170.png" alt="image-20210220153727170"></p><p>6、</p><p><img src="/2021/02/23/JVM-3-5/image-20210220153745556.png" alt="image-20210220153745556"></p><p>7、</p><p><img src="/2021/02/23/JVM-3-5/image-20210220153753401.png" alt="image-20210220153753401"></p><p>8、</p><p><img src="/2021/02/23/JVM-3-5/image-20210220153911426.png" alt="image-20210220153911426"></p><p>9、</p><p><img src="/2021/02/23/JVM-3-5/image-20210220153927341.png" alt="image-20210220153927341"></p><p>10、</p><p><img src="/2021/02/23/JVM-3-5/image-20210220153946343.png" alt="image-20210220153946343"></p><p>11、图片写错了是#25和#26（获得System类）</p><p><img src="/2021/02/23/JVM-3-5/image-20210220154019657.png" alt="image-20210220154019657"></p><img src="/2021/02/23/JVM-3-5/../../../../../jvm/JVM/JVM系列-第6章-方法区.assets/image-20210220154130591.png" alt="image-20210220154130591" style="zoom:50%;"><p>12、</p><p><img src="/2021/02/23/JVM-3-5/image-20210220154303197.png" alt="image-20210220154303197"></p><p>13、</p><p><img src="/2021/02/23/JVM-3-5/image-20210220154324932.png" alt="image-20210220154324932"></p><p>15、执行加法运算后，将计算结果放在操作数栈顶</p><p><img src="/2021/02/23/JVM-3-5/image-20210220154332655.png" alt="image-20210220154332655"></p><p>16、就是真正的打印</p><p><img src="/2021/02/23/JVM-3-5/../../../../../jvm/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC6%E7%AB%A0-%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20210220154340360.png" alt="image-20210220154340360"></p><p><img src="/2021/02/23/JVM-3-5/image-20210220154353990.png" alt="image-20210220154353990"></p><p>17、</p><p><img src="/2021/02/23/JVM-3-5/image-20210220154541936.png" alt="image-20210220154541936"></p><p><strong>符号引用 –&gt; 直接引用</strong></p><ol><li> 上面代码调用 System.out.println() 方法时，首先需要看看 System 类有没有加载，再看看 PrintStream 类有没有加载</li><li> 如果没有加载，则执行加载，执行时，将常量池中的符号引用（字面量）转换为运行时常量池的直接引用（真正的地址值）</li></ol><h2 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a>方法区演进细节</h2><h3 id="永久代演进过程"><a href="#永久代演进过程" class="headerlink" title="永久代演进过程"></a>永久代演进过程</h3><ol><li><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p></li><li><p>Hotspot中方法区的变化：</p></li></ol><table><thead><tr><th>JDK1.6及以前</th><th>有永久代（permanent generation），静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，<strong>字符串常量池，静态变量移除，保存在堆中</strong></td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p><strong>JDK6</strong></p><p>方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）</p><p><img src="/2021/02/23/JVM-3-5/image-20210220155340612.png" alt="image-20210220155340612"></p><p><strong>JDK7</strong></p><p>方法区由永久代实现，使用 JVM 虚拟机内存</p><p><img src="/2021/02/23/JVM-3-5/image-20210220155410915.png" alt="image-20210220155410915"></p><p><strong>JDK8</strong></p><p>方法区由元空间实现，使用物理机本地内存</p><img src="/2021/02/23/JVM-3-5/../../../../../jvm/JVM/JVM系列-第6章-方法区.assets/0030.png"><h3 id="永久代为什么要被元空间替代？"><a href="#永久代为什么要被元空间替代？" class="headerlink" title="永久代为什么要被元空间替代？"></a>永久代为什么要被元空间替代？</h3><blockquote><p><strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p></blockquote><ul><li><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着<strong>类的元数据信息</strong>也消失了。<strong>这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间</strong>（Metaspace）。</p></li><li><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p></li><li><p>这项改动是很有必要的，原因有：</p><ol><li><p><strong>为永久代设置空间大小是很难确定的</strong>。</p><p>在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &#39;dubbo client x.x connector&#39; java.lang.OutOfMemoryError:PermGen space</span><br></pre></td></tr></table></figure><p>而元空间和永久代之间<strong>最大的区别</strong>在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，<em>元空间的大小仅受本地内存限制</em>。</p></li><li><p>对永久代进行调优是很困难的。（Full GC）</p><p>==方法区的垃圾收集==主要回收两部分内容：<strong>常量池中废弃的常量和不再用的类型</strong>，方法区的调优主要是为了降低<strong>Full GC</strong></p><ol><li> 有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</li><li> 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</li></ol></li></ol></li></ul><h3 id="字符串常量池-StringTable-为什么要调整位置"><a href="#字符串常量池-StringTable-为什么要调整位置" class="headerlink" title="字符串常量池 StringTable 为什么要调整位置?"></a>字符串常量池 StringTable 为什么要调整位置?</h3><p>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，<strong>回收效率低，导致永久代内存不足。放到堆里，能及时回收内存</strong>。</p><h3 id="静态变量放在哪里"><a href="#静态变量放在哪里" class="headerlink" title="静态变量放在哪里"></a>静态变量放在哪里</h3><h4 id="对象实体在哪里放着？"><a href="#对象实体在哪里放着？" class="headerlink" title="对象实体在哪里放着？"></a>对象实体在哪里放着？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> * 1、静态引用对应的对象实体(也就是这个new byte[1024 * 1024 * 100])始终都存在堆空间，</span></span><br><span class="line"><span class="comment"> * 2、只是那个变量(相当于下面的arr变量名)在JDK6,JDK7,JDK8存放位置中有所变化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk7：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * jdk 8：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFieldTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];<span class="comment">//100MB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK6环境下</p><img src="/2021/02/23/JVM-3-5/../../../../../jvm/JVM/JVM系列-第6章-方法区.assets/0031.png" alt="image-20201113224231761"><p>JDK7环境下</p><img src="/2021/02/23/JVM-3-5/../../../../../jvm/JVM/JVM系列-第6章-方法区.assets/0032.png"><p>JDK8环境</p><img src="/2021/02/23/JVM-3-5/../../../../../jvm/JVM/JVM系列-第6章-方法区.assets/0033.png"><h4 id="变量-名-存放在哪里？"><a href="#变量-名-存放在哪里？" class="headerlink" title="变量(名)存放在哪里？"></a>变量(名)存放在哪里？</h4><p>这个问题需要用JHSDB工具来进行分析，这个工具是JDK9开始自带的(JDK9以前没有)，在bin目录下可以找到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 《深入理解Java虚拟机》中的案例：</span></span><br><span class="line"><span class="comment"> * staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticObjTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ObjectHolder staticObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">        ObjectHolder instanceObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectHolder localObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> StaticObjTest.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>JDK6环境下</strong></p><p>1、staticObj随着Test的类型信息存放在方法区</p><p>2、instanceObj随着Test的对象实例存放在Java堆</p><p>3、localObject则是存放在foo()方法栈帧的局部变量表中。</p><p>4、测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：<strong>只要是对象实例必然会在Java堆中分配</strong>。</p><p><img src="/2021/02/23/JVM-3-5/image-20210220210338049.png" alt="image-20210220210338049"></p><blockquote><p>0x00007f32c7800000(Eden区的起始地址)    —-   0x00007f32c7b50000(Eden区的终止地址)  ，可以发现三个变量都在这个范围内</p></blockquote><p>5、接着，找到了一个引用该staticObj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p><p><img src="/2021/02/23/JVM-3-5/image-20210220210938367.png" alt="image-20210220210938367"></p><p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，<strong>存储于Java堆之中</strong>，从我们的实验中也明确验证了这一点</p><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><ul><li><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区<strong>类型卸载</strong>的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</p></li><li><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p></li><li><p>方法区的垃圾收集主要回收两部分内容</p><blockquote><p><strong>常量池中废弃的常量</strong></p><p><strong>不再使用的类型</strong>。</p></blockquote></li></ul><ol><li><p><strong>方法区内常量池之中主要存放的两大类常量</strong>：字面量和符号引用。</p><p>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。</p><p>而符号引用则属于编译原理方面的概念。</p><p>包括下面三类常量：</p><ul><li>  类和接口的全限定名</li><li>  字段的名称和描述符</li><li>  方法的名称和描述符</li></ul></li><li><p>HotSpot虚拟机对常量池的回收策略是很明确的，<strong>只要常量池中的常量没有被任何地方引用，就可以被回收</strong>。</p></li><li><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是<strong>类的回收</strong>）</p><blockquote><p><strong>类卸载</strong></p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></blockquote></li><li><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX：+TraceClass-Loading</code>、<code>-XX：+TraceClassUnLoading</code>查看类加载和卸载信息</p></li><li><p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p></li></ol><h2 id="运行时数据区总结"><a href="#运行时数据区总结" class="headerlink" title="运行时数据区总结"></a>运行时数据区总结</h2><p><img src="/2021/02/23/JVM-3-5/image-20210220214850233.png" alt="image-20210220214850233"></p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h3 id="直接内存概述"><a href="#直接内存概述" class="headerlink" title="直接内存概述"></a>直接内存概述</h3><ul><li><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p></li><li><p>直接内存是在Java堆外的、直接向系统申请的内存区间。</p></li><li><p>来源于<strong>NIO</strong>，<strong>通过存在堆中的DirectByteBuffer操作Native内存</strong></p></li><li><p>通常，<strong>访问直接内存的速度会优于Java堆</strong>。即读写性能高。</p><p>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</p><p>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  IO                  NIO (New IO / Non-Blocking IO) 非阻塞</span></span><br><span class="line"><span class="comment"> *  byte[] / char[]     Buffer 基础传输工具</span></span><br><span class="line"><span class="comment"> *  Stream              Channel 基于流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 查看直接内存的占用与释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//1GB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//直接分配本地内存空间</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存分配完毕，请求指示！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        scanner.next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存开始释放！&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接占用了 1G 的本地内存</p><img src="/2021/02/23/JVM-3-5/../../../../../jvm/JVM/JVM系列-第6章-方法区.assets/0037.jpg"><h3 id="BIO-与-NIO"><a href="#BIO-与-NIO" class="headerlink" title="BIO 与 NIO"></a>BIO 与 NIO</h3><p><strong>非直接缓存区（BIO）</strong></p><p>原来采用BIO的架构，在<strong>读写本地文件时，需要从用户态切换成内核态</strong>，即数据从应用程序的虚拟机内存中读取，而该地址数据还要从内核地址获取，最后对应物理磁盘。<strong>效率低</strong></p><p><img src="/2021/02/23/JVM-3-5/image-20210223144925157.png" alt="image-20210223144925157"></p><p><strong>直接缓冲区（NIO）</strong></p><p>NIO 直接操作物理磁盘，省去了中间过程，直接存在<strong>物理映射文件</strong>。</p><p><img src="/2021/02/23/JVM-3-5/image-20210223145236317.png" alt="image-20210223145236317"></p><h3 id="直接内存与-OOM"><a href="#直接内存与-OOM" class="headerlink" title="直接内存与 OOM"></a>直接内存与 OOM</h3><ul><li><p>直接内存也可能导致OutofMemoryError异常</p></li><li><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，<strong>Java堆和直接内存的总和依然受限于操作系统能给出的最大内存</strong>。</p></li><li><p>直接内存的<strong>缺点</strong>为：</p><ul><li>  分配回收成本较高</li><li>  不受JVM内存回收管理</li></ul></li><li><p>直接内存大小可以通过<strong>MaxDirectMemorySize</strong>设置</p></li><li><p>如果不指定，默认与堆的最大值-Xmx参数值一致</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 本地内存的OOM:  OutOfMemoryError: Direct buffer memory</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BufferTest2 &#123;</span><br><span class="line">    private static final int BUFFER &#x3D; 1024 * 1024 * 20;&#x2F;&#x2F;20MB</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;ByteBuffer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                ByteBuffer byteBuffer &#x3D; ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">                list.add(byteBuffer);</span><br><span class="line">                count++;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">at java.nio.Bits.reserveMemory(Bits.java:<span class="number">694</span>)</span><br><span class="line">at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="number">123</span>)</span><br><span class="line">at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="number">311</span>)</span><br><span class="line">at com.atguigu.java.BufferTest2.main(BufferTest2.java:<span class="number">21</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/02/23/JVM-3-5/image-20210223152824815.png" alt="image-20210223152824815"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;方法区&quot;&gt;&lt;a href=&quot;#方法区&quot; class=&quot;headerlink&quot; title=&quot;方法区&quot;&gt;&lt;/a&gt;方法区&lt;/h1&gt;&lt;h2 id=&quot;栈、堆、方法区的交互关系&quot;&gt;&lt;a href=&quot;#栈、堆、方法区的交互关系&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="运行时数据区" scheme="https://www.gtxhjh.cn/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    <category term="方法区" scheme="https://www.gtxhjh.cn/tags/%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>第三章_4-堆</title>
    <link href="https://www.gtxhjh.cn/2021/02/23/JVM-3-4/"/>
    <id>https://www.gtxhjh.cn/2021/02/23/JVM-3-4/</id>
    <published>2021-02-23T08:05:32.000Z</published>
    <updated>2021-02-23T08:08:57.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h1><h2 id="堆与进程"><a href="#堆与进程" class="headerlink" title="堆与进程"></a>堆与进程</h2><ol><li> 堆针对一个JVM进程来说是唯一的。也就是<strong>一个进程只有一个JVM实例</strong>，一个JVM实例中就有一个运行时数据区，一个运行时数据区只有一个堆和一个方法区。</li><li> 但是<strong>进程包含多个线程，他们是共享同一堆空间的</strong>。</li></ol><p><img src="/2021/02/23/JVM-3-4/image-20210214191017299.png" alt="image-20210214191017299"></p><ol><li><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。<strong>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了</strong>，<strong>堆是JVM管理的最大一块内存空间</strong></p><blockquote><p>堆内存的大小是可以调节的。</p></blockquote></li><li><p>《Java虚拟机规范》规定，堆可以处于<strong>物理上不连续</strong>的内存空间中，但在<strong>逻辑上</strong>它应该被视为<strong>连续</strong>的。</p></li><li><p><em>所有的线程共享Java堆</em>，在这里**==还可以划分线程私有的缓冲区==<strong>（Thread Local Allocation Buffer，</strong>==TLAB==**）（如果都共享堆，那么共享数据会存在线程安全问题，因此同步来处理并发性差，分小空间可以让线程独有）</p></li><li><p>《Java虚拟机规范》中对Java堆的描述是：<strong>所有的对象实例以及数组都应当在运行时分配在堆上</strong>。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p><blockquote><p>从实际使用角度看，是“几乎”所有的对象实例都在堆分配内存，但并非全部。</p><p>因为<strong>还有一些对象是在栈上分配</strong>的（逃逸分析，标量替换）</p></blockquote></li><li><p>数组和对象可能永远不会存储在栈上（<strong>不一定</strong>），因为<strong>栈帧中（局部变量表）保存引用，这个引用指向对象或者数组在堆中的位置</strong>。</p></li><li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p><blockquote><p>出栈后引用指针没了，没有引用后堆中对象认为是垃圾，但是由GC来处理，一般当堆空间不足时，触发GC进行回收。也就是触发了GC的时候，才会进行回收</p><p>如果堆中对象马上被回收，那么用户线程就会受到影响，因为有stop the word（涉及到用户线程和垃圾回收线程能否并发执行）</p><p>GC的频率影响到用户线程</p></blockquote></li><li><p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p></li></ol><blockquote><p>随着JVM的迭代升级，原来一些绝对的事情，在后续版本中也开始有了特例，变的不再那么绝对。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//属性、成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleHeap</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My ID is &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHeap sl = <span class="keyword">new</span> SimpleHeap(<span class="number">1</span>);</span><br><span class="line">        SimpleHeap s2 = <span class="keyword">new</span> SimpleHeap(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        Object[] arr1 = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/23/JVM-3-4/image-20210214192440500.png" alt="image-20210214192440500"></p><h2 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h2><p>现代垃圾收集器（分代垃圾收集算法）大部分都基于分代收集理论设计，<strong>堆空间细分</strong>为：</p><ol><li><p>Java7 及之前堆内存<strong>逻辑上</strong>分为三部分：新生区+养老区+永久区</p><blockquote><p>Young Generation Space    新生区      Young/New</p><ul><li>又被划分为Eden区和Survivor区</li></ul><p>Old generation space    养老区           Old/Tenure</p><p>Permanent Space   永久区                   Perm</p></blockquote></li><li><p>Java 8及之后堆内存<strong>逻辑上</strong>分为三部分：新生区+养老区+<strong>元空间</strong></p><blockquote><p>Young Generation Space 新生区，又被划分为Eden区和Survivor区</p><p>Old generation space 养老区</p><p>Meta Space 元空间 Meta</p></blockquote></li></ol><p>约定：新生区 &lt;–&gt; 新生代 &lt;–&gt; 年轻代 、 养老区 &lt;–&gt; 老年区 &lt;–&gt; 老年代、 永久区 &lt;–&gt; 永久代</p><p><img src="/2021/02/23/JVM-3-4/image-20210214203830676.png" alt="image-20210214203830676"></p><ol start="2"><li> 堆空间内部结构，JDK1.8之前从永久代 替换成 元空间</li></ol><p><img src="/2021/02/23/JVM-3-4/image-20210214204939240.png" alt="image-20210214204939240"></p><h3 id="JVisualVM可视化查看堆内存"><a href="#JVisualVM可视化查看堆内存" class="headerlink" title="JVisualVM可视化查看堆内存"></a>JVisualVM可视化查看堆内存</h3><p>运行下面代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MINUTES.sleep(<span class="number">30</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、双击jdk目录下的这个文件</p><img src="/2021/02/23/JVM-3-4/../../../../../jvm/JVM/JVM系列-第5章-堆.assets/0005.png"><p>2、工具 -&gt; 插件 -&gt; 安装Visual GC插件</p><img src="/2021/02/23/JVM-3-4/../../../../../jvm/JVM/JVM系列-第5章-堆.assets/0006.png"><p>3、运行上面的代码</p><img src="/2021/02/23/JVM-3-4/../../../../../jvm/JVM/JVM系列-第5章-堆.assets/0007.png"><h1 id="设置堆内存大小与-OOM"><a href="#设置堆内存大小与-OOM" class="headerlink" title="设置堆内存大小与 OOM"></a>设置堆内存大小与 OOM</h1><h2 id="设置堆内存和查看"><a href="#设置堆内存和查看" class="headerlink" title="设置堆内存和查看"></a>设置堆内存和查看</h2><ol><li><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家<strong>可以通过选项”-Xms”和”-Xmx”来进行设置</strong>。</p><blockquote><p><strong>-Xms</strong>用于表示堆区（年轻代+老年代）的起始内存，等价于**-XX:InitialHeapSize**</p><ul><li><p>-X是jvm运行参数</p></li><li><p>ms是memory start</p></li></ul><p><strong>-Xmx</strong>则用于表示堆区的最大内存，等价于**-XX:MaxHeapSize**</p><p><strong>开发中建议将初始堆内存和最大的堆内存设置成相同的值</strong>,目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</p><ul><li>原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。<strong>频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力</strong>。如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM</li></ul></blockquote></li><li><p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。</p></li><li><p>默认情况下:</p><blockquote><p>初始内存大小：物理电脑内存大小/64</p><p>最大内存大小：物理电脑内存大小/4</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 设置堆空间大小的参数</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *      -X 是jvm的运行参数</span></span><br><span class="line"><span class="comment"> *      ms 是memory start</span></span><br><span class="line"><span class="comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 默认堆空间的大小</span></span><br><span class="line"><span class="comment"> *    初始内存大小：物理电脑内存大小 / 64</span></span><br><span class="line"><span class="comment"> *             最大内存大小：物理电脑内存大小 / 4</span></span><br><span class="line"><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> *                  方式二：-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms : 245M</span><br><span class="line">-Xmx : 3616M</span><br><span class="line">系统内存大小为：<span class="number">15.</span>3125G</span><br><span class="line">系统内存大小为：<span class="number">14.</span>125G</span><br></pre></td></tr></table></figure><blockquote><p>笔者电脑内存大小是16G，不足16G的原因是操作系统自身还占据了一些。两个不一样的原因待会再说</p></blockquote><p>设置下参数再看</p><img src="/2021/02/23/JVM-3-4/../../../../../jvm/JVM/JVM系列-第5章-堆.assets/0008.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms : 575M</span><br><span class="line">-Xmx : 575M</span><br></pre></td></tr></table></figure><blockquote><p>为什么会少25M</p></blockquote><p><strong>方式一： jps   /  jstat -gc 进程id</strong></p><img src="/2021/02/23/JVM-3-4/../../../../../jvm/JVM/JVM系列-第5章-堆.assets/0009.png"><blockquote><p>jps：查看java进程</p><p>jstat：查看某进程内存使用情况</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SOC: S0区总共容量</span><br><span class="line">S1C: S1区总共容量</span><br><span class="line">S0U: S0区使用的量</span><br><span class="line">S1U: S1区使用的量</span><br><span class="line">EC: 伊甸园区总共容量</span><br><span class="line">EU: 伊甸园区使用的量</span><br><span class="line">OC: 老年代总共容量</span><br><span class="line">OU: 老年代使用的量</span><br></pre></td></tr></table></figure><ol><li><p>25600+25600+153600+409600 = 614400K</p><p>614400 /1024 = 600M</p></li><li><p>25600+153600+409600 = 588800K</p><p>588800 /1024 = 575M</p><blockquote><p>并非巧合，<strong>S0区和S1区两个只有一个能使用</strong>，另一个用不了（涉及到垃圾回收复制算法，后面会详解）</p></blockquote></li></ol><p> <strong>方式二：-XX:+PrintGCDetails</strong></p><p><img src="/2021/02/23/JVM-3-4/image-20210214214116059.png" alt="image-20210214214116059"></p><blockquote><p>17920K = 153600K + 25600K</p></blockquote><h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> Picture(<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Picture</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] pixels;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Picture</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pixels = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、设置虚拟机参数</p><p><code>-Xms600m -Xmx600m</code></p><p>最终输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at JVM.Picture.&lt;init&gt;(OOMTest.java:<span class="number">28</span>)</span><br><span class="line">at JVM.OOMTest.main(OOMTest.java:<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>2、堆内存变化图</p><img src="/2021/02/23/JVM-3-4/../../../../../jvm/JVM/JVM系列-第5章-堆.assets/0011.png"><p>3、原因：大对象导致堆内存溢出</p><img src="/2021/02/23/JVM-3-4/../../../../../jvm/JVM/JVM系列-第5章-堆.assets/0012.png"><h1 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h1><blockquote><p>堆空间由年轻代和老年代构成</p></blockquote><ul><li><p>存储在JVM中的Java对象可以被划分为两类：</p><blockquote><p>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速(及时回收)</p><p>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致(放指定区域不用总是去回收)</p></blockquote></li><li><p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p></li></ul><ul><li>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</li></ul><p><img src="/2021/02/23/JVM-3-4/image-20210214215659406.png" alt="image-20210214215659406"></p><p><img src="/2021/02/23/JVM-3-4/image-20210214215937543.png" alt="image-20210214215937543"></p><ul><li><p>配置新生代与老年代在堆结构的占比</p><blockquote><p>默认**-XX:NewRatio**=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p></blockquote></li></ul><blockquote><p>可以修改**-XX:NewRatio**=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</p></blockquote><ol><li><p>在HotSpot中，<strong>Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1</strong>，开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如-XX:SurvivorRatio=8(默认)</p></li><li><p><strong>几乎所有的Java对象都是在Eden区被new出来的</strong></p></li><li><p>绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p><blockquote><p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p></blockquote></li><li><p>可以使用选项”-Xmn”设置新生代最大内存大小，但这个参数一般使用默认值就可以了。</p></li></ol><img src="/2021/02/23/JVM-3-4/../../../../../jvm/JVM/JVM系列-第5章-堆.assets/0015.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2.</span></span><br><span class="line"><span class="comment"> * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8</span></span><br><span class="line"><span class="comment"> * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）</span></span><br><span class="line"><span class="comment"> * -Xmn:设置新生代的空间的大小。 （一般不设置）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdenSurvivorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我只是来打个酱油~&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h1><h2 id="对象分配过程说明"><a href="#对象分配过程说明" class="headerlink" title="对象分配过程说明"></a>对象分配过程说明</h2><blockquote><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p></blockquote><p><strong>具体过程</strong></p><ol><li> new的对象先放伊甸园区，<strong>此区有大小限制</strong>。</li><li> 当伊甸园的空间填满时，程序又需要创建对象，<strong>JVM的垃圾回收器将对伊甸园区进行垃圾回收</strong>（==YGC/MinorGC==），<strong>将伊甸园区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到伊甸园区</strong>。</li><li> 然后将伊甸园中的剩余对象移动到幸存者0区。</li><li> 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li><li> 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li> 啥时候能去养老区呢？可以设置次数。默认是15次。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：**-XX:MaxTenuringThreshold**=N 进行设置</li><li> 在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li> 若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ol><h2 id="图解对象分配（一般情况）"><a href="#图解对象分配（一般情况）" class="headerlink" title="图解对象分配（一般情况）"></a>图解对象分配（一般情况）</h2><ol><li><p>创建的对象，一般都是存放在<strong>Eden区</strong>的，<strong>当Eden区满了后，就会<em>触发</em>GC操作</strong>，一般被称为 YGC / Minor GC操作（其中有个stop the word的过程）</p><p><img src="/2021/02/23/JVM-3-4/image-20210214222434915.png" alt="image-20210214222434915"></p></li><li><p>当我们进行一次垃圾收集后，红色的对象将会被回收，而<strong>绿色的独享还被占用着(幸存下来)，存放在S0(Survivor From)区</strong></p><blockquote><p>同时给每个对象设置了一个年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。</p></blockquote></li><li><p>同时Eden区继续存放对象，<strong>当Eden区再次存满</strong>的时候，又会触发一个MinorGC操作，此时GC将会<strong>把 Eden和Survivor From中的对象进行一次垃圾收集</strong>，把存活的对象放到 Survivor To（S1）区，同时让存活的对象年龄 + 1(from-&gt;to)</p><blockquote><p>下一次再进行GC的时候，</p><ul><li>这一次的s0区为空，所以成为下一次GC的S1区</li><li>这一次的s1区则成为下一次GC的S0区</li></ul><p>也就是说s0区和s1区在互相转换（谁空谁是to）</p></blockquote><p><strong>注意</strong>：YGC触发只有Eden区存满才会发生，而幸存区满属于特殊情况后谈，幸存区的垃圾回收属于被动回收不会主动触发</p><p><img src="/2021/02/23/JVM-3-4/image-20210214223732834.png" alt="image-20210214223732834"></p></li><li><p>继续不断的进行对象生成和垃圾回收，<strong>当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion 晋升的操作</strong>，也就是将年轻代中的对象晋升到<strong>老年代</strong>中</p><p><img src="/2021/02/23/JVM-3-4/image-20210214222448963.png" alt="image-20210214222448963"></p></li></ol><p><strong>关于垃圾回收</strong>：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。</p><h2 id="特殊情况说明"><a href="#特殊情况说明" class="headerlink" title="特殊情况说明"></a>特殊情况说明</h2><p><strong>对象分配的特殊情况</strong></p><ol><li>如果来了一个新对象，先看看 Eden 是否放的下？<ul><li>  如果 Eden 放得下，则直接放到 Eden 区</li><li>  如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？</li></ul></li><li>将对象放到老年区又有两种情况：<ul><li>  如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是<strong>超大对象，只能直接放到老年代</strong></li><li>  那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM </li></ul></li><li> 如果 Eden 区满了，将对象往幸存区拷贝时，发现<strong>幸存区放不下，那只能便宜了某些新对象，让他们直接晋升至老年区</strong></li></ol><p><img src="/2021/02/23/JVM-3-4/image-20210214225152356.png" alt="image-20210214225152356"></p><h2 id="常用调优工具"><a href="#常用调优工具" class="headerlink" title="常用调优工具"></a>常用调优工具</h2><ol><li> JDK命令行(jmap、jinfo、jstate、javap)</li><li> Eclipse：Memory Analyzer Tool</li><li> Jconsole</li><li> Visual VM（实时监控，推荐）</li><li> Jprofiler（IDEA插件）</li><li> Java Flight Recorder（实时监控）</li><li> GCViewer</li><li> GCEasy</li></ol><h1 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h1><blockquote><p>JVM的调优的一个环节，也就是垃圾收集，我们需要<strong>尽量的避免垃圾回收</strong>，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题（GC也是垃圾回收线程来做的，而另一部分线程就是用户线程，用户线程是执行代码所需的线程，STW会让用户线程暂停，因此会降低程序吞吐量）</p><p><strong>而 ==Major GC 和 Full GC==出现STW的时间，是Minor GC的10倍以上</strong></p></blockquote><ol><li><p>JVM在进行GC时，并非每次都对上面三个内存区域（新生、老年；方法区）一起回收的，大部分时候回收的都是指新生代。</p><blockquote><p>针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是<strong>部分收集（Partial GC）</strong>，一种是<strong>整堆收集（FullGC）</strong></p></blockquote></li></ol><ul><li><p><strong>部分收集</strong>（Partial GC）：<strong>不是完整收集整个Java堆的垃圾收集</strong>。其中又分为：</p><ul><li><p><strong>新生代收集</strong>（Minor GC/Young GC）：只是新生代（Eden，s0，s1）的垃圾收集</p></li><li><p><strong>老年代收集</strong>（Major GC/Old GC）：只是老年代的圾收集。</p></li></ul><blockquote><p>目前，只有CMS GC会有单独收集老年代的行为。</p></blockquote><p>  <strong>注意</strong>，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</p><ul><li><p><strong>混合收集</strong>（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集</p><blockquote><p>目前，只有G1 GC会有这种行为(G1是按照region进行堆空间划分，可能是新生代数据也可能是老年代数据)</p></blockquote></li></ul></li><li><p><strong>整堆收集</strong>（Full GC）：收集整个java堆和方法区的垃圾收集。</p></li></ul><blockquote><p>由于历史原因，外界各种解读，majorGC和Full GC有些混淆。</p></blockquote><h2 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h2><h3 id="年轻代-GC（Minor-GC）触发机制"><a href="#年轻代-GC（Minor-GC）触发机制" class="headerlink" title="年轻代 GC（Minor GC）触发机制"></a>年轻代 GC（Minor GC）触发机制</h3><ol><li><p> 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满。<strong>Survivor满不会主动引发GC</strong>，在Eden区满的时候，会<em>顺带触发</em>s0区的GC，也就是被动触发GC（<em>每次Minor GC会清理年轻代的内存</em>）</p></li><li><p> 因为Java对象<strong>大多都具备朝生夕灭</strong>的特性，所以Minor GC非常频繁，一般<strong>回收速度也比较快</strong>。这一定义既清晰又易于理解。</p></li><li><p> Minor GC会引发STW（Stop The World），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p></li></ol><p><img src="/2021/02/23/JVM-3-4/image-20210216211436624.png" alt="image-20210216211436624"></p><h2 id="Major-Full-GC"><a href="#Major-Full-GC" class="headerlink" title="Major/Full GC"></a>Major/Full GC</h2><blockquote><p>Full GC有争议，后续详解两者区别，暂时先看着</p></blockquote><h3 id="老年代GC（MajorGC）触发机制"><a href="#老年代GC（MajorGC）触发机制" class="headerlink" title="老年代GC（MajorGC）触发机制"></a>老年代GC（MajorGC）触发机制</h3><ul><li><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p></li><li><p>出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><blockquote><p>也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC</p></blockquote></li><li><p>Major GC的速度一般会比Minor GC慢10倍以上，<strong>STW的时间更长</strong>（老年代空间更大，所以要减少次数）</p></li><li><p>如果Major GC后，内存还不足，就报OOM了</p></li></ul><h3 id="Full-GC-触发机制（后面细讲）"><a href="#Full-GC-触发机制（后面细讲）" class="headerlink" title="Full GC 触发机制（后面细讲）"></a>Full GC 触发机制（后面细讲）</h3><p><strong>触发Full GC执行的情况有如下五种：</strong></p><ol><li> 调用System.gc()时，系统建议执行FullGC，但是不必然执行</li><li> 老年代空间不足</li><li> 方法区空间不足</li><li> 通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li> 由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol><p>说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些</p><h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String a = <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历次数为：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="number">0.0455865</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.06</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2246K-&gt;496K(2560K)] 2470K-&gt;1506K(9728K), <span class="number">0.0009094</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2294K-&gt;488K(2560K)] 3305K-&gt;2210K(9728K), <span class="number">0.0009568</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1231K-&gt;488K(2560K)] 7177K-&gt;6434K(9728K), <span class="number">0.0005594</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 488K-&gt;472K(2560K)] 6434K-&gt;6418K(9728K), <span class="number">0.0005890</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 472K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 5946K-&gt;4944<span class="title">K</span><span class="params">(7168K)</span>] 6418K-&gt;4944<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3492K-&gt;3492<span class="title">K</span><span class="params">(1056768K)</span>], 0.0045270 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 4944K-&gt;4944K(8704K), <span class="number">0.0004954</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="function">at java.util.Arrays.<span class="title">copyOf</span><span class="params">(Arrays.java:<span class="number">3332</span>)</span></span></span><br><span class="line"><span class="function">at java.lang.AbstractStringBuilder.<span class="title">ensureCapacityInternal</span><span class="params">(AbstractStringBuilder.java:<span class="number">124</span>)</span></span></span><br><span class="line"><span class="function">at java.lang.AbstractStringBuilder.<span class="title">append</span><span class="params">(AbstractStringBuilder.java:<span class="number">448</span>)</span></span></span><br><span class="line"><span class="function">at java.lang.StringBuilder.<span class="title">append</span><span class="params">(StringBuilder.java:<span class="number">136</span>)</span></span></span><br><span class="line"><span class="function">at com.atguigu.java1.GCTest.<span class="title">main</span><span class="params">(GCTest.java:<span class="number">20</span>)</span></span></span><br><span class="line"><span class="function">[PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(1536K)</span>] [ParOldGen: 4944K-&gt;4877<span class="title">K</span><span class="params">(7168K)</span>] 4944K-&gt;4877<span class="title">K</span><span class="params">(8704K)</span>, [Metaspace: 3492K-&gt;3492<span class="title">K</span><span class="params">(1056768K)</span>], 0.0076061 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.02</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">遍历次数为：<span class="number">16</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 1536K, used 60K [<span class="number">0x00000000ffd00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 1024K, <span class="number">5</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffd0f058</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line"> ParOldGen       total 7168K, used 4877K [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd00000</span>, <span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  object space 7168K, <span class="number">68</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffac3408</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line"> Metaspace       used 3525K, capacity 4502K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 391<span class="title">K</span>, <span class="title">capacity</span> 394<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="number">0.0455865</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.06</span> secs] </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>[PSYoungGen: 2037K-&gt;504K(2560K)]：年轻代总空间为 2560K ，当前占用 2037K ，经过垃圾回收后剩余504K</p></li><li><p>2037K-&gt;728K(9728K)：堆内存总空间为 9728K ，当前占用2037K ，经过垃圾回收后剩余728K</p></li></ul><h1 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h1><p>为什么要把Java堆分代？不分代就不能正常工作了吗？</p><blockquote><p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p></blockquote><ul><li>  <strong>新生代</strong>：有Eden、两块大小相同的survivor（又称为from/to或s0/s1）构成，to总为空。</li><li>  <strong>老年代</strong>：存放新生代中经历多次GC仍然存活的对象。</li></ul><p><img src="/2021/02/23/JVM-3-4/image-20210216220001870.png" alt="image-20210216220001870"></p><ul><li>其实不分代完全可以，<strong>分代的唯一理由就是优化GC性能</strong>，如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会<em>对堆的所有区域进行扫描</em>（性能低）</li></ul><ul><li>  而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。（多回收新生代，少回收老年代，性能会提高很多）</li></ul><p><img src="/2021/02/23/JVM-3-4/image-20210216215819685.png" alt="image-20210216215819685"></p><h1 id="对象内存分配策略"><a href="#对象内存分配策略" class="headerlink" title="对象内存分配策略"></a>对象内存分配策略</h1><ul><li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。</li><li>对象在Survivor区中每熬过一次MinorGC（一年），年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</li><li>对象晋升老年代的年龄阀值，可以通过选项**-XX:MaxTenuringThreshold**来设置</li></ul><p><strong>针对不同年龄段的对象分配原则如下所示：</strong>（对象提升(promotion规则）</p><ul><li><strong>优先分配到Eden</strong>：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li><li><strong>大对象直接分配到老年代</strong>：尽量避免程序中出现过多的大对象</li><li><strong>长期存活的对象分配到老年代</strong></li><li><strong>动态对象年龄判断</strong>：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，<strong>年龄大于或等于该年龄的对象可以直接进入老年代</strong>，无须等到MaxTenuringThreshold中要求的年龄</li><li><strong>空间分配担保</strong>： -XX:HandlePromotionFailure </li></ul><h1 id="为对象分配内存-TLAB（保证线程安全）"><a href="#为对象分配内存-TLAB（保证线程安全）" class="headerlink" title="为对象分配内存:TLAB（保证线程安全）"></a>为对象分配内存:TLAB（保证线程安全）</h1><p><img src="/2021/02/23/JVM-3-4/image-20210216221724797.png" alt="image-20210216221724797"></p><h2 id="为什么有-TLAB"><a href="#为什么有-TLAB" class="headerlink" title="为什么有 TLAB"></a>为什么有 TLAB</h2><ul><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用<strong>加锁等机制</strong>，进而影响分配速度。</li></ul><h2 id="什么是-TLAB"><a href="#什么是-TLAB" class="headerlink" title="什么是 TLAB"></a>什么是 TLAB</h2><p>TLAB（Thread Local Allocation Buffer）</p><ul><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，**JVM为每个线程分配了一个==私有缓存区域，它包含在Eden空间内==**。</li><li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li><li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li></ul><p><img src="/2021/02/23/JVM-3-4/image-20210216223801728.png" alt="image-20210216223801728"></p><blockquote><ol><li>每个线程都有一个TLAB空间</li><li>当一个线程的TLAB存满时，可以使用公共区域（蓝色）的</li></ol></blockquote><h2 id="TLAB再说明"><a href="#TLAB再说明" class="headerlink" title="TLAB再说明"></a>TLAB再说明</h2><ul><li><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存(小)，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。</p></li><li><p>在程序中，开发人员可以通过选项“**-XX:UseTLAB**”设置是否开启TLAB空间。</p></li><li><p>默认情况下，TLAB空间的内存非常小，<strong>仅占有整个Eden空间的1%**，当然我们可以通过选项“</strong>-XX:TLABWasteTargetPercent**”设置TLAB空间所占用Eden空间的百分比大小。</p></li><li><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在Eden空间中分配内存。</p></li></ul><blockquote><p>1、哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，<strong>分配新的缓存区时才需要同步锁定</strong>                   —-这是《深入理解JVM》–第三版里说的</p><p>2、和这里讲的有点不同。我猜测说的意思是某一次分配，如果TLAB用完了，那么<strong>这一次</strong>先在Eden区直接分配。空闲下来后再加锁分配新的TLAB（TLAB内存较大，分配时间应该较长）</p><blockquote></blockquote></blockquote><p><strong>TLAB 分配过程</strong></p><p><img src="/2021/02/23/JVM-3-4/image-20210216224239564.png" alt="image-20210216224239564"></p><h1 id="堆空间参数设置"><a href="#堆空间参数设置" class="headerlink" title="堆空间参数设置"></a>堆空间参数设置</h1><h2 id="常用参数设置"><a href="#常用参数设置" class="headerlink" title="常用参数设置"></a>常用参数设置</h2><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><p>我们只说常用的</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试堆空间常用的jvm参数：</span></span><br><span class="line"><span class="comment"> * -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值</span></span><br><span class="line"><span class="comment"> * -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）</span></span><br><span class="line"><span class="comment"> *      具体查看某个参数的指令： jps：查看当前运行中的进程</span></span><br><span class="line"><span class="comment"> *                             jinfo -flag SurvivorRatio 进程id</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -Xms：初始堆空间内存 （默认为物理内存的1/64）</span></span><br><span class="line"><span class="comment"> * -Xmx：最大堆空间内存（默认为物理内存的1/4）</span></span><br><span class="line"><span class="comment"> * -Xmn：设置新生代的大小。(初始值及最大值)</span></span><br><span class="line"><span class="comment"> * -XX:NewRatio：配置新生代与老年代在堆结构的占比</span></span><br><span class="line"><span class="comment"> * -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</span></span><br><span class="line"><span class="comment"> * -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails：输出详细的GC处理日志</span></span><br><span class="line"><span class="comment"> * 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc</span></span><br><span class="line"><span class="comment"> * -XX:HandlePromotionFailure：是否设置空间分配担保</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p><strong>在发生Minor GC之前</strong>，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p><ul><li>  如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。<ul><li>如果HandlePromotionFailure=true，那么会继续检查<strong>老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong>。<ul><li>  如果大于，则尝试进行一次<strong>Minor GC</strong>，但这次Minor GC依然是有风险的；</li><li>  如果小于，则进行一次<strong>Full GC</strong>。</li></ul></li><li>  如果HandlePromotionFailure=false，则进行一次<strong>Full GC</strong>。</li></ul></li></ul><p><strong>历史版本</strong></p><ol><li> 在JDK6 Update 24之后(jdk7)，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC</strong>，否则将进行Full GC。即 HandlePromotionFailure=true</li></ol><h1 id="堆是分配对象的唯一选择吗？（栈上分配）"><a href="#堆是分配对象的唯一选择吗？（栈上分配）" class="headerlink" title="堆是分配对象的唯一选择吗？（栈上分配）"></a>堆是分配对象的唯一选择吗？（栈上分配）</h1><blockquote><p>GC重点区域，因此要尽量减少，考虑减少老年代GC，同时避开OOM出现</p></blockquote><p><strong>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</strong></p><blockquote><p>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换</strong>优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了</p><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的<strong>堆外存储技术</strong></p><p>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p></blockquote><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><blockquote><p>如何<strong>将堆上的对象分配到栈</strong>，需要使用逃逸分析手段。</p><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p></blockquote><ul><li>通过逃逸分析，Java Hotspot编译器能够<strong>分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上</strong></li><li>逃逸分析的基本行为就是**==分析对象动态作用域==**：<ul><li>  <em>当一个对象在方法中被定义后，对象<strong>只在方法内部使用</strong>，则认为没有发生逃逸(栈上分配)</em></li><li>  当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul></li></ul><h3 id="逃逸分析举例"><a href="#逃逸分析举例" class="headerlink" title="逃逸分析举例"></a>逃逸分析举例</h3><ul><li>没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，<strong>栈空间就被移除（也就无需GC）</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">my_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();<span class="comment">// 没有逃逸</span></span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();<span class="comment">// 发生逃逸</span></span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>如果想要StringBuffer sb不发生逃逸，可以这样写</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer(); <span class="comment">//没有逃逸</span></span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span>? <span class="keyword">new</span> EscapeAnalysis() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="逃逸分析参数设置"><a href="#逃逸分析参数设置" class="headerlink" title="逃逸分析参数设置"></a>逃逸分析参数设置</h3><ul><li><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p></li><li><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>  选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析</li><li>  通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>开发中能使用局部变量的，就不要使用在方法外定义</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li><strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><ul><li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被<strong>优化成栈上分配</strong>。分配完成后，继续在调用栈内执行，最后<strong>线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了</strong></li><li>常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。</li></ul><h4 id="栈上分配举例"><a href="#栈上分配举例" class="headerlink" title="栈上分配举例"></a>栈上分配举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配测试</span></span><br><span class="line"><span class="comment"> * -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 33280K-&gt;808K(38400K)] 33280K-&gt;816K(125952K), 0.0483350 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.06 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;808K(38400K)] 34096K-&gt;816K(125952K), 0.0008411 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;792K(38400K)] 34096K-&gt;800K(125952K), 0.0008427 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34072K-&gt;808K(38400K)] 34080K-&gt;816K(125952K), 0.0012223 secs] [Times: user&#x3D;0.08 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">花费的时间为： 114 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>JVM 参数设置</li></ul><p>-Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</p><ul><li>日志打印：发生了 GC ，耗时 114ms</li></ul><p><strong>开启逃逸分析的情况</strong></p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">花费的时间为： 5 ms</span><br></pre></td></tr></table></figure><ul><li>1、参数设置</li></ul><p>-Xmx128m -Xms128m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</p><ul><li>日志打印：并没有发生 GC ，耗时5ms 。</li></ul><h3 id="同步省略（同步消除）"><a href="#同步省略（同步消除）" class="headerlink" title="同步省略（同步消除）"></a>同步省略（同步消除）</h3><ul><li><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p></li><li><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>，如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个**取消同步的过程就叫同步省略，也叫==锁消除==**。</p></li></ul><p>例如下面的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中对hollis这个对象加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(hellis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><em>字节码分析</em></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">            System.out.println(hollis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 0 new #2 &lt;java/lang/Object&gt;</span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line"> 4 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">7</span> astore_1</span><br><span class="line"> <span class="number">8</span> aload_1</span><br><span class="line"> <span class="number">9</span> dup</span><br><span class="line"><span class="number">10</span> astore_2</span><br><span class="line"><span class="number">11</span> monitorenter</span><br><span class="line">12 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">15</span> aload_1</span><br><span class="line">16 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">19</span> aload_2</span><br><span class="line"><span class="number">20</span> monitorexit</span><br><span class="line"><span class="number">21</span> goto <span class="number">29</span> (+<span class="number">8</span>)</span><br><span class="line"><span class="number">24</span> astore_3</span><br><span class="line"><span class="number">25</span> aload_2</span><br><span class="line"><span class="number">26</span> monitorexit</span><br><span class="line"><span class="number">27</span> aload_3</span><br><span class="line"><span class="number">28</span> athrow</span><br><span class="line"><span class="number">29</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，**==同步省略操作是在解释运行时发生的==**</p><blockquote><p>同步省略栈上分配是字节码文件加载到内存后才进行的执行判断</p></blockquote><h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p><strong>分离对象或标量替换</strong></p><ul><li><p><strong>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量</strong>。</p></li><li><p>相对的，那些还可以分解的数据叫做<strong>聚合量</strong>（Aggregate），Java中的对象就是聚合量，因为他<em>可以分解</em>成其他聚合量和标量。</p></li><li><p>在JIT阶段，如果经过逃逸分析，<strong>发现一个对象不会被外界访问的话</strong>，那么经过JIT优化，就会**把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是==标量替换==**。</p></li></ul><h4 id="标量替换举例"><a href="#标量替换举例" class="headerlink" title="标量替换举例"></a>标量替换举例</h4><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Point为聚合量</p></blockquote><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>分析</strong>：可以看到，Point这个聚合量<strong>经过逃逸分析</strong>后，发现他并没有逃逸，就被替换成两个聚合量了。</li><li><strong>标量替换的好处</strong>：就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</li><li><strong>标量替换为栈上分配提供了很好的基础</strong>。</li></ul><h4 id="标量替换参数设置"><a href="#标量替换参数设置" class="headerlink" title="标量替换参数设置"></a>标量替换参数设置</h4><p>参数 -XX:+ElimilnateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标量替换测试</span></span><br><span class="line"><span class="comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  12:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScalarReplace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">        u.id = <span class="number">5</span>;</span><br><span class="line">        u.name = <span class="string">&quot;www.atguigu.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>未开启标量替换</strong></p><ul><li>JVM 参数</li></ul><p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</p><ul><li>日志</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure)  25600K-&gt;880K(98304K), <span class="number">0.0012658</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26480K-&gt;832K(98304K), <span class="number">0.0012124</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26432K-&gt;784K(98304K), <span class="number">0.0009719</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26384K-&gt;832K(98304K), <span class="number">0.0009071</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26432K-&gt;768K(98304K), <span class="number">0.0010643</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26368K-&gt;824K(101376K), <span class="number">0.0012354</span> secs]</span><br><span class="line">[GC (Allocation Failure)  32568K-&gt;712K(100864K), <span class="number">0.0011291</span> secs]</span><br><span class="line">[GC (Allocation Failure)  32456K-&gt;712K(100864K), <span class="number">0.0006368</span> secs]</span><br><span class="line">花费的时间为： <span class="number">99</span> ms</span><br></pre></td></tr></table></figure><p><strong>开启标量替换</strong></p><ul><li>JVM 参数</li></ul><p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</p><ul><li>日志：时间减少很多，且无GC</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">花费的时间为： 6 ms</span><br></pre></td></tr></table></figure><p>可见栈上分配需要配合逃逸分析和标量替换，否则new的对象还在堆空间</p><p>上述代码在主函数中调用了1亿次alloc()方法，进行对象创建由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><p><code>-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</code></p><p>这里设置参数如下：</p><ol><li> 参数 -server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li><li> 参数 -XX:+DoEscapeAnalysis：启用逃逸分析</li><li> 参数 -Xmx10m：指定了堆空间最大为10MB</li><li> 参数 -XX:+PrintGC：将打印GC日志。</li><li> 参数 -XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ol><h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><ol><li> 关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li><li> 其根本原因就是<strong>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程</strong>。</li><li> 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li><li> 虽然这项技术并不十分成熟，但是它也是<strong>即时编译器优化技术中一个十分重要的手段</strong>。</li><li> 注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，<strong>Oracle Hotspot JVM中并未这么做</strong>（刚刚演示的效果，是因为HotSpot实现了标量替换（猜：替换后不是一个对象实例？）），这一点在逃逸分析相关的文档里已经说明，<strong>所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上</strong>。</li><li> 目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是<strong>intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配</strong>，<strong>所以这一点同样符合前面一点的结论：对象实例都是分配在堆上</strong>。</li></ol><blockquote><p><strong>堆是分配对象的唯一选择么？</strong></p></blockquote><p>综上：<strong>对象实例都是分配在堆上</strong>。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p></li><li><p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</p></li><li><p>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。当GC发生在老年代时则被称为Major GC或者Full GC。一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;堆的核心概述&quot;&gt;&lt;a href=&quot;#堆的核心概述&quot; class=&quot;headerlink&quot; title=&quot;堆的核心概述&quot;&gt;&lt;/a&gt;堆的核心概述&lt;/h1&gt;&lt;h2 id=&quot;堆与进程&quot;&gt;&lt;a href=&quot;#堆与进程&quot; class=&quot;headerlink&quot; title=&quot;堆</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="运行时数据区" scheme="https://www.gtxhjh.cn/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    <category term="堆" scheme="https://www.gtxhjh.cn/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>volatile与伪共享的理解</title>
    <link href="https://www.gtxhjh.cn/2021/02/19/volatile%E4%B8%8E%E4%BC%AA%E5%85%B1%E4%BA%AB%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://www.gtxhjh.cn/2021/02/19/volatile%E4%B8%8E%E4%BC%AA%E5%85%B1%E4%BA%AB%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2021-02-19T05:47:46.000Z</published>
    <updated>2021-02-19T12:29:12.486Z</updated>
    
    <content type="html"><![CDATA[<p>学习java并发时，了解LongAdder的伪共享时思考，value已经定义为volatile，也就表示直接在主内存中进行操作，那么为什么还存在伪共享呢</p><blockquote><p>首先已知volatile不能保证原子性。比如多个线程读取到最新的值后，在这个值上进行++操作，无法保证原子性，因为++操作在字节码文件中，也分多步</p></blockquote><blockquote><p>普通变量与volatile变量的差别是volatile的特殊规则保证了新值能马上同步到主内存，以及每次使用前能够马上从内存刷新，即一个线程改动了某个变量的值之后，其他线程读取的话肯定能看到新的值 </p></blockquote><h2 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h2><p>那么Volatile是怎样来保证可见性的呢？在x86处理器下通过工具获取JIT编译器生成的汇编指令看看对Volatile进行写操作CPU会做什么事情。 </p><p><img src="/2021/02/19/volatile%E4%B8%8E%E4%BC%AA%E5%85%B1%E4%BA%AB%E7%9A%84%E7%90%86%E8%A7%A3/image-20210219131156934.png" alt="image-20210219131156934"></p><p>volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发人员手冊可知。lock前缀的指令在多核处理器下会引发两件事情 </p><ul><li><strong>将当前处理器缓存行的数据会写回到系统内存。</strong></li><li><strong>这个写回内存的操作会引起在其它CPU里缓存了该内存地址的数据无效。</strong></li></ul><blockquote><p><strong>深度解析：</strong></p><p>处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其它）后再进行操作。但操作完之后不知道何时会写到内存；假设对声明了Volatile变量进行写操作。JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。可是就算写回到内存。假设其它处理器缓存的值还是旧的。再运行计算操作就会有问题，所以<strong>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议</strong>。每一个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行相应的内存地址被改动，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行改动操作的时候，会强制又一次从系统内存里把数据读到处理器缓存里。</p><p>所以说不能说volatile是表示直接在主内存中进行操作，他还是会到缓存行中，只是对应的修改会立刻写回到系统内存，来保证最新，同时让其他CPU缓存了该内存地址的数据缓存行失效</p><p><strong>Lock前缀指令会引起处理器缓存回写到内存</strong>。Lock前缀指令导致在运行指令期间。声言处理器的 LOCK# 信号。在多处理器环境中，LOCK# 信号确保在声言该信号期间。处理器能够独占使用不论什么共享内存。</p><p>（由于它会锁住总线。导致其它CPU不能訪问总线，不能訪问总线就意味着不能訪问系统内存），可是在近期的处理器里，LOCK＃信号一般不锁总线，而是锁缓存。毕竟锁总线开销比較大。在8.1.4章节有具体说明锁定操作对处理器缓存的影响。对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和近期的处理器中，假设訪问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反地，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保改动的原子性，此操作被称为“缓存锁定”，<strong>缓存一致性机制会阻止同一时候改动被两个以上处理器缓存的内存区域数据</strong>。</p><p><strong>一个处理器的缓存回写到内存会导致其它处理器的缓存无效</strong>。</p><p>IA-32处理器和Intel 64处理器使用MESI（改动，独占，共享，无效）控制协议去维护内部缓存和其它处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32 和Intel 64处理器能嗅探其它处理器訪问系统内存和它们的内部缓存。它们使用嗅探技术保证它的内部缓存，系统内存和其它处理器的缓存的数据在总线上保持一致。</p><p>比如在Pentium和P6 family处理器中。假设通过嗅探一个处理器来检測其它处理器打算写内存地址。而这个地址当前处理共享状态，<strong>那么正在嗅探的处理器将无效它的缓存行，在下次訪问同样内存地址时，强制运行缓存行填充。</strong></p></blockquote><p>考虑到volatile的读写会让缓存行失效，那么如果在一个缓存行中存储了多个数据，一旦有已经修改的volatile数据存在，那么这个缓存行就会失效，影响到实际需要读写的另一个数据，导致性能下降，而想到的解决办法就是让一个缓存行只存有一个数据，剩余空间使用字节填充。 </p><p><strong>注意：</strong> 由于使用追加字节的方式须要处理器读取很多其它的字节到快速缓冲区，这<em>本身就会带来一定的性能消耗</em>，共享变量假设不被频繁写的话。锁的几率也很小，就不是必需通过追加字节的方式来避免相互锁定。 </p><h2 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h2><p>讲述volatile原理时也提到了伪共享的问题，其实此处只是伪共享问题的一个方面</p><p><strong>伪共享：</strong>当多个线程同时修改一个缓存行里面的多个变量时，<strong>由于同时只能有一个线程操作缓存行</strong>，所以相比于将每个变量放到一个缓存行，性能会有所下降，这就是伪共享</p><blockquote><p>class {int x ,int y}  x和y被放在同一个快速<strong>缓存</strong>区，假设一个线程改动x；那么另外一个线程改动y，必须等待x改动完毕后才干实施</p><p>CPU缓存系统中是以缓存行（cache line）为单位存储的。目前主流的CPU Cache 的 Cache Line 大小都是64Bytes。在多线程情况下，如果需要修改“<strong>共享同一个缓存行的变量</strong>”，就会无意中影响彼此的性能，这就是伪共享（False Sharing）</p></blockquote><p><strong>每一个cpu核心或者线程都会可能往同一个缓存行写数据；而且对共享变量，同一时候cpu核心会有各自的缓存行 ，当多核CPU线程同一时候改动在同一个快速缓存行各自独立的变量时，会不自不觉地影响性能。这就发生了伪共享False sharing。伪共享是性能的无声杀手。</strong></p><p>解决方案便是将快速缓存剩余的字节填充填满(pad)，确保不发生多个字段被挤入一个快速缓存区 </p><p><strong>总结：</strong>在单个线程下顺序修改一个缓存行中的多个变量，会充分利用程序运行的局部性原则，从而加速了程序的运行。而在多线程下并发修改一个缓存行中的多个变量时就会竞争缓存行，从而降低程序运行性能</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>作者写的很好，其中一些细节本文并未提到，建议参阅</p><footer><strong>https://www.cnblogs.com/mthoutai/p/6766874.html</strong></footer></blockquote><blockquote><footer><strong>https://zhuanlan.zhihu.com/p/286023308</strong></footer></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习java并发时，了解LongAdder的伪共享时思考，value已经定义为volatile，也就表示直接在主内存中进行操作，那么为什么还存在伪共享呢&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先已知volatile不能保证原子性。比如多个线程读取到最新的值后，在这个值上</summary>
      
    
    
    
    <category term="Java并发" scheme="https://www.gtxhjh.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://www.gtxhjh.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="多线程" scheme="https://www.gtxhjh.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="伪共享" scheme="https://www.gtxhjh.cn/tags/%E4%BC%AA%E5%85%B1%E4%BA%AB/"/>
    
    <category term="volatile" scheme="https://www.gtxhjh.cn/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>第三章_3-本地方法栈、本地方法接口</title>
    <link href="https://www.gtxhjh.cn/2021/02/10/JVM-3-3/"/>
    <id>https://www.gtxhjh.cn/2021/02/10/JVM-3-3/</id>
    <published>2021-02-10T14:16:37.000Z</published>
    <updated>2021-02-10T14:20:24.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h2><p><img src="/2021/02/10/JVM-3-3/image-20210210211122300.png" alt="image-20210210211122300"></p><ol><li>简单地讲，<strong>一个==Native Method==是一个Java调用非Java代码的接囗</strong>一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。</li><li>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</li><li>在定义一个native method时，并<strong>不提供实现体</strong>（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</li><li><strong>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序</strong></li></ol><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外，不代表抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IHaveNatives</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native4</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="为什么要使用-Native-Method？"><a href="#为什么要使用-Native-Method？" class="headerlink" title="为什么要使用 Native Method？"></a>为什么要使用 Native Method？</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意（操作系统底层用c和c++实现）时，问题就来了。</p><h3 id="与Java环境外交互"><a href="#与Java环境外交互" class="headerlink" title="与Java环境外交互"></a>与Java环境外交互</h3><p><strong>有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因</strong>。你可以想想Java需要与一些<strong>底层系统</strong>，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它<strong>为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节</strong>。</p><h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><ol><li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。</li><li>然而不管怎样，它毕竟不是一个完整的系统，它经常<em>依赖于一底层系统的支持</em>。这些底层系统常常是强大的操作系统。</li><li><strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</strong>。</li><li>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li></ol><h3 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s Java"></a>Sun’s Java</h3><ol><li><strong>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互</strong>。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</li><li>例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它<em>实现调用的是该类里的本地方法setPriority0()<em>。</em></em>这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API<strong>。这是</strong>一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用**。</li></ol><h3 id="本地方法的现状"><a href="#本地方法的现状" class="headerlink" title="本地方法的现状"></a>本地方法的现状</h3><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ol><li><strong>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li><li><strong>本地方法栈，也是线程私有的</strong></li><li>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul></li><li>本地方法一般是使用C语言或C++语言实现的。</li><li>它的具体做法是<strong>Native Method Stack中登记native方法（管理本地方法的调用）</strong>，在Execution Engine 执行时加载本地方法库。</li></ol><p><img src="/2021/02/10/JVM-3-3/image-20210210215204019.png" alt="image-20210210215204019"></p><p><strong>注意事项</strong></p><ol><li>==当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限==<ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的<strong>运行时数据区</strong></li><li>它甚至可以直接使用本地处理器中的<strong>寄存器</strong></li><li>直接从本地内存的堆中分配任意数量的<strong>内存</strong></li></ul></li><li>并<strong>不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等</strong>。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈</li><li>在Hotspot JVM中，直接将<strong>本地方法栈和虚拟机栈合二为一</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;本地方法接口&quot;&gt;&lt;a href=&quot;#本地方法接口&quot; class=&quot;headerlink&quot; title=&quot;本地方法接口&quot;&gt;&lt;/a&gt;本地方法接口&lt;/h1&gt;&lt;h2 id=&quot;本地方法&quot;&gt;&lt;a href=&quot;#本地方法&quot; class=&quot;headerlink&quot; title=&quot;本</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="运行时数据区" scheme="https://www.gtxhjh.cn/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    <category term="本地方法栈" scheme="https://www.gtxhjh.cn/tags/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>第三章_2-虚拟机栈</title>
    <link href="https://www.gtxhjh.cn/2021/02/08/JVM-3-2/"/>
    <id>https://www.gtxhjh.cn/2021/02/08/JVM-3-2/</id>
    <published>2021-02-08T15:54:42.000Z</published>
    <updated>2021-02-08T15:59:18.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-2：虚拟机栈"><a href="#第三章-2：虚拟机栈" class="headerlink" title="第三章-2：虚拟机栈"></a>第三章-2：虚拟机栈</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="虚拟机栈的出现背景"><a href="#虚拟机栈的出现背景" class="headerlink" title="虚拟机栈的出现背景"></a>虚拟机栈的出现背景</h3><ol><li> 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li><li> 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li></ol><h3 id="内存中的栈与堆"><a href="#内存中的栈与堆" class="headerlink" title="内存中的栈与堆"></a>内存中的栈与堆</h3><ol><li>首先栈是运行时的单位，而堆是存储的单位。</li><li>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ol><p><img src="/2021/02/08/JVM-3-2/image-20210205215401398.png" alt="image-20210205215401398"></p><h3 id="虚拟机栈基本内容"><a href="#虚拟机栈基本内容" class="headerlink" title="虚拟机栈基本内容"></a>虚拟机栈基本内容</h3><ul><li><p>Java虚拟机栈是什么？</p><ul><li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其<strong>内部保存一个个的栈帧（线程相关）</strong>（Stack Frame），**==对应着一次次的Java方法调用==**，栈是线程私有的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackTest test = <span class="keyword">new</span> StackTest();</span><br><span class="line">        test.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/02/08/JVM-3-2/image-20210205221839925.png" alt="image-20210205221839925"></p><ul><li><p>虚拟机栈的生命周期</p><ul><li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li></ul></li><li><p>虚拟机栈的作用</p><ul><li>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</li><li>局部变量，它是相比于成员变量来说的（或属性）</li><li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li></ul></li></ul><h3 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a>虚拟机栈的特点</h3><ul><li><p>栈是一种快速有效的分配存储方式，<strong>访问速度仅次于程序计数器</strong>。</p></li><li><p>JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li><p>对于栈来说不存在垃圾回收问题</p><ul><li>栈不需要GC，但是可能存在OOM</li></ul></li></ul><p><img src="/2021/02/08/JVM-3-2/image-20210205222539991.png" alt="image-20210205222539991"></p><h3 id="虚拟机栈的异常"><a href="#虚拟机栈的异常" class="headerlink" title="虚拟机栈的异常"></a>虚拟机栈的异常</h3><p><strong>面试题：栈中可能出现的异常？</strong></p><ul><li><p>Java 虚拟机规范允许Java<strong>栈的大小是动态的或者是固定不变的</strong></p><ul><li><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</p></li><li><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候<em>无法申请到足够的内存</em>，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</p></li></ul></li></ul><h3 id="参数调优-设置栈内存大小"><a href="#参数调优-设置栈内存大小" class="headerlink" title="参数调优-设置栈内存大小"></a>参数调优-设置栈内存大小</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><p>官方文档</p></blockquote><p>可以==使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间==，栈的大小直接决定了函数调用的最大可达深度。</p><blockquote><p>Sets the thread stack size (in bytes). Append the letter <code>k</code> or <code>K</code> to indicate KB, <code>m</code> or <code>M</code> to indicate MB, and <code>g</code> or <code>G</code> to indicate GB. The default value depends on the platform:</p><ul><li>Linux/x64 (64-bit): 1024 KB</li><li>macOS (64-bit): 1024 KB</li><li>Oracle Solaris/x64 (64-bit): 1024 KB</li><li>Windows: The default value depends on virtual memory</li></ul></blockquote><p>The following examples set the thread stack size to 1024 KB in different units:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没设置参数前</strong></p><p>部分输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">11404</span></span><br><span class="line"><span class="number">11405</span></span><br><span class="line"><span class="number">11406</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:<span class="number">691</span>)</span><br></pre></td></tr></table></figure><p>说明栈在11406这个深度溢出了</p><p><strong>设置栈参数之后</strong></p><p><img src="/2021/02/08/JVM-3-2/image-20210205223645371.png" alt="image-20210205223645371"></p><p>部分输出结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2474</span></span><br><span class="line"><span class="number">2475</span></span><br><span class="line"><span class="number">2476</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:<span class="number">77</span>)</span><br></pre></td></tr></table></figure><p>说明参数起作用了</p><h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><ol><li> 每个线程都有自己的栈，==栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在==</li><li> 在这个线程上正在执行的<strong>每个方法都各自对应一个栈帧（Stack Frame）</strong>。</li><li> 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ol><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><ol><li><p> JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</p></li><li><p> 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></p></li><li><p> 执行引擎运行的<strong>所有字节码指令只针对当前栈帧进行操作</strong>（寄存器中存储的也是当前栈帧的字节码指令操作地址）。</p></li><li><p> 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p></li></ol><p><img src="/2021/02/08/JVM-3-2/image-20210207203727137.png" alt="image-20210207203727137"></p><ol><li> <strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li> 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式。<ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束（异常往上抛）。</li><li>但不管使用哪种方式，都会导致栈帧被弹出。</li></ul></li></ol><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li><p><strong>局部变量表（Local Variables）</strong></p></li><li><p><strong>操作数栈（Operand Stack）（或表达式栈、操作栈）</strong></p></li><li><p>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</p></li><li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p></li><li><p>一些附加信息</p></li></ul><p><img src="/2021/02/08/JVM-3-2/image-20210207210022335.png" alt="image-20210207210022335"></p><blockquote><p>并行每个线程下的栈都是私有的，因此**==每个线程都有自己各自的栈==<strong>，并且每个栈里面都有很多栈帧，</strong>==栈帧的大小主要由局部变量表和操作数栈决定==**的</p></blockquote><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0007.png"><h2 id="内部结构-局部变量表"><a href="#内部结构-局部变量表" class="headerlink" title="内部结构-局部变量表"></a>内部结构-局部变量表</h2><blockquote><p>局部变量表也被称之为局部变量数组或本地变量表</p></blockquote><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ol start="2"><li><p><strong>定义为一个==数字数组==，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</p></li><li><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></p></li><li><p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</p></li><li><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。</p><blockquote><p>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</p><p>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p></blockquote></li><li><p>局部变量表中的变量只在当前方法调用中有效。</p><blockquote><p>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</p><p>当方法调用结束后，<strong>随着方法栈帧的销毁，局部变量表也会随之销毁</strong>。</p></blockquote></li></ol><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariablesTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//练习：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关于Slot的使用的理解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LocalVariablesTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String name1 = <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">        test2(date, name1);</span><br><span class="line">        System.out.println(date + name1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(Date dateP, String name2)</span> </span>&#123;</span><br><span class="line">        dateP = <span class="keyword">null</span>;</span><br><span class="line">        name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">        <span class="keyword">char</span> gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> dateP + name2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            b = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">        <span class="keyword">int</span> c = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0008.png"><p>看完字节码后，可得结论：所以局部变量表所需的容量大小是在编译期确定下来的。</p><h4 id="部分详解"><a href="#部分详解" class="headerlink" title="部分详解"></a>部分详解</h4><p>为了更好讲解，我们直接用jclasslib来看字节码，以main方法为例来讲解。一些一目了然的就不讲了</p><ul><li>main</li></ul><p><img src="/2021/02/08/JVM-3-2/image-20210207215011746.png" alt="image-20210207215011746"></p><ul><li>0-15  也就是有16行字节码，字节码指令</li></ul><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0009.png"><ul><li>方法异常信息表</li></ul><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0010.png"><ul><li>Misc（可见编译时已确定且不改变）</li></ul><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0011.png"><ul><li><p>行号表</p><p><strong>Java代码的行号和字节码指令行号的对应关系</strong></p></li></ul><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0012.png"><ul><li><p>局部变量表</p><p>方法中局部变量的刻画</p></li></ul><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0013.png"><p>1、图中圈的东西表示该<strong>局部变量的作用域范围</strong></p><p>2、Start PC==11表示在字节码的11行开始生效，也就是Java代码对应的第15行。即变量<strong>作用域起始位置</strong>。而声明int num在java代码的是第14行，说明是从声明的下一行开始生效</p><p>3、Length== 5表示局部变量<strong>剩余有效行数</strong>，main方法字节码指令总共有16行，从11行开始生效，那么剩下就是16-11 ==5。</p><p>4、描述中<code>Ljava/lang/String</code>   前面的L表示引用类型</p><blockquote><p>注意：生效行数和剩余有效行数都是针对于字节码文件的行数</p></blockquote><h3 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h3><ol><li><p>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</p></li><li><p><strong>局部变量表，最基本的存储单元是Slot（变量槽）</strong></p></li><li><p>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p></li><li><p>在局部变量表里，==<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型），<strong>64位的类型占用两个slot</strong>（1ong和double）==。</p><blockquote><p>byte、short、char在储存前辈转换为int，boolean也被转换为int，0表示false，非0表示true(所以局部变量表定义为<strong>数字</strong>数组)</p><p>long和double则占据两个slot</p></blockquote></li><li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值(使用起始索引)</p></li><li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照声明顺序被复制</strong>到局部变量表中的每一个slot上</p></li><li><p>如果当前<strong>帧</strong>是由构造<strong>方法</strong>或者实例<strong>方法</strong>创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（<strong>this也相当于一个变量</strong>）</p><blockquote><p>所以静态方法不能引用this，因为局部变量表中不存在this</p></blockquote></li></ol><p><img src="/2021/02/08/JVM-3-2/image-20210207220002807.png" alt="image-20210207220002807"></p><h3 id="Slot代码示例"><a href="#Slot代码示例" class="headerlink" title="Slot代码示例"></a>Slot代码示例</h3><p><strong>this 存放在 index = 0 的位置：</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.count++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>局部变量表：this 存放在 index = 0 的位置</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0015.png"><p><strong>64位的类型（1ong和double）占用两个slot</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(Date dateP, String name2)</span> </span>&#123;</span><br><span class="line">      dateP = <span class="keyword">null</span>;</span><br><span class="line">      name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">      <span class="keyword">double</span> weight = <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">      <span class="keyword">char</span> gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> dateP + name2;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>weight 为 double 类型，index 直接从 3 蹦到了 5</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0016.png"><p><strong>static 无法调用 this</strong></p><p>this 不存在与 static 方法的局部变量表中，所以无法调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h3><p>栈帧中的局部变量表中的<strong>槽位是可以重用</strong>的，如果一个<strong>局部变量过了其作用域</strong>，那么在其作用域之后申明<strong>新的局部变量变就很有可能会复用过期局部变量的槽位</strong>，从而达到节省资源的目的。</p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        b = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">    <span class="keyword">int</span> c = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>局部变量 c 重用了局部变量 b 的 slot 位置</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0017.png"><h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><blockquote><p>变量的分类：</p><ol><li><p>按照数据类型分：① 基本数据类型  ② 引用数据类型</p></li><li><p>按照在类中声明的位置分：</p></li></ol><p>成员变量：在使用前，都经历过默认初始化赋值</p><blockquote><p>类变量: 静态修饰的，linking的<strong>prepare阶段：给类变量==默认赋值==</strong> —&gt; <strong>initial阶段：给类变量显式赋值即静态代码块赋值</strong></p><p>实例变量：随着<strong>对象的创建</strong>，会在<strong>堆空间</strong>中分配实例变量空间，并进行**==默认赋值==**</p></blockquote><p>局部变量：在使用前，<strong>必须要进行显式赋值</strong>的！（局部变量表不存在系统初始化的过程）否则，编译不通过。</p></blockquote><ol><li> 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li> 我们知道成员变量有两次初始化的机会<strong>，</strong>第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li><li> 和类变量初始化不同的是，**==局部变量表不存在系统初始化的过程==**，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li></ol><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ol><li><p> 在栈帧中，<em>与性能调优关系最为密切的部分</em>就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p></li><li><p> <strong>==局部变量表中的变量也是重要的垃圾回收<em>根节点</em>，只要被局部变量表中直接或间接引用的对象都不会被回收==</strong></p></li></ol><h2 id="内部结构-操作数栈"><a href="#内部结构-操作数栈" class="headerlink" title="内部结构-操作数栈"></a>内部结构-操作数栈</h2><blockquote><p>栈：使用数组或链表来实现</p></blockquote><h3 id="操作数栈的特点"><a href="#操作数栈的特点" class="headerlink" title="操作数栈的特点"></a>操作数栈的特点</h3><ol><li><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</p></li><li><p>操作数栈，在方法执行过程中，**<em>根据字节码指令</em>，往栈中写入数据或提取数据**，即入栈（push）和 出栈（pop）</p><blockquote><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，</p><p>比如：执行复制、交换、求和等操作</p><p><img src="/2021/02/08/JVM-3-2/image-20210208190046413.png" alt="image-20210208190046413"></p></blockquote></li></ol><p><img src="/2021/02/08/JVM-3-2/image-20210208190138235.png" alt="image-20210208190138235"></p><h3 id="操作数栈的作用"><a href="#操作数栈的作用" class="headerlink" title="操作数栈的作用"></a>操作数栈的作用</h3><ul><li><p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</p></li><li><p><strong>操作数栈就是JVM执行引擎的一个工作区</strong>，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的（但数组的长度确定）</p></li><li><p><strong>每一个操作数栈都会拥有一个明确的栈深度用于存储数值</strong>，其所需的最大深度<strong>在编译期就定义好</strong>了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</p><p><img src="/2021/02/08/JVM-3-2/image-20210208190445589.png" alt="image-20210208190445589"></p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型</p><blockquote><p>32bit的类型占用一个栈单位深度</p><p>64bit的类型占用两个栈单位深度</p></blockquote></li><li><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></p></li><li><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p></li><li><p>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</p></li></ul><h3 id="操作数栈代码追踪"><a href="#操作数栈代码追踪" class="headerlink" title="操作数栈代码追踪"></a>操作数栈代码追踪</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">    <span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> k = i + j;</span><br><span class="line">    <span class="comment">// int m = 800;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/image-20210208191538431.png" alt="image-20210208191538431" style="zoom:50%;"><p>对应字节码指令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">15</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">8</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> iload_2</span><br><span class="line"> <span class="number">8</span> iadd</span><br><span class="line"> <span class="number">9</span> istore_3</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0021.png"><h4 id="一步一步看流程"><a href="#一步一步看流程" class="headerlink" title="一步一步看流程"></a>一步一步看流程</h4><blockquote><p>可以发现栈的深度已经明确</p></blockquote><p>1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0022.png"><p>2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了</p><blockquote><p><strong>解释</strong>为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0023.png"></blockquote><p>3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0024.png"><p>4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作</p><p>iload_1：取出局部变量表中索引为1的数据入操作数栈</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0025.png"><p>5、然后将操作数栈中的两个元素执行相加操作(执行引擎把字节码指令翻译成机器指令，让CPU运算)，并存储在局部变量表3的位置</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_004/0026.png"><h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p><strong>关于类型转换的说明</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_004/0027.png"><ul><li>  因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8</li><li>  但是存储在局部变量的时候，会转成 int 类型的变量：istore_4</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_004/0028.png"><ul><li>m改成800之后，byte存储不了，就成了short型，sipush 800</li></ul><p><strong>如果被调用的方法带有返回值，返回值入操作数栈</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> k = m + n;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span></span><br><span class="line">    <span class="keyword">int</span> i = getSum();</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getSum() 方法字节码指令：最后带着个 ireturn</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_004/0029.png"><p>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_004/0030.png"><h2 id="优化-栈顶缓存技术"><a href="#优化-栈顶缓存技术" class="headerlink" title="优化-栈顶缓存技术"></a>优化-栈顶缓存技术</h2><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p><ul><li><p><strong>问题：</strong>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要<strong>更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高</strong>。</p></li><li><p>由于<em>操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度</em>。为了<strong>解决</strong>这个问题，HotSpot JVM的设计者们提出了栈顶<strong>缓存</strong>（Tos，Top-of-Stack Cashing）技术：</p><blockquote><p><strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></p><blockquote><p>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</p><p><img src="/2021/02/08/JVM-3-2/image-20210208193901222.png" alt="image-20210208193901222"></p></blockquote></blockquote></li></ul><h2 id="内部结构-动态链接"><a href="#内部结构-动态链接" class="headerlink" title="内部结构-动态链接"></a>内部结构-动态链接</h2><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p><blockquote><p>大部分字节码指令执行时，都需要进行常量池的访问</p></blockquote><ol><li><p>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</p></li><li><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将==这些符号引用转换为调用方法的直接引用==</strong></p></li><li><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/image-20210208201706279.png" alt="image-20210208201706279" style="zoom:67%;"><p><img src="/2021/02/08/JVM-3-2/image-20210208201344590.png" alt="image-20210208201344590"></p><blockquote><p>注：如果都有空参，可以用#6</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicLinkingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        methodA();</span><br><span class="line"></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">10</span>; size <span class="number">712</span> bytes</span><br><span class="line">  MD5 checksum e56913c945f897c7ee6c0a608629bca8</span><br><span class="line">  Compiled from <span class="string">&quot;DynamicLinkingTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">DynamicLinkingTest</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #9.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #8.#24         // com/atguigu/java1/DynamicLinkingTest.num:I</span><br><span class="line">   #3 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = String             #27            // methodA()....</span><br><span class="line">   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #6 = String             #30            // methodB()....</span><br><span class="line">   #7 = Methodref          #8.#31         // com/atguigu/java1/DynamicLinkingTest.methodA:()V</span><br><span class="line">   #8 = Class              #32            // com/atguigu/java1/DynamicLinkingTest</span><br><span class="line">   #9 = Class              #33            // java/lang/Object</span><br><span class="line">  #10 = Utf8               num</span><br><span class="line">  #11 = Utf8               I</span><br><span class="line">  #12 = Utf8               &lt;init&gt;</span><br><span class="line">  #13 = Utf8               ()V</span><br><span class="line">  #14 = Utf8               Code</span><br><span class="line">  #15 = Utf8               LineNumberTable</span><br><span class="line">  #16 = Utf8               LocalVariableTable</span><br><span class="line">  #17 = Utf8               this</span><br><span class="line">  #18 = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line">  #19 = Utf8               methodA</span><br><span class="line">  #20 = Utf8               methodB</span><br><span class="line">  #21 = Utf8               SourceFile</span><br><span class="line">  #22 = Utf8               DynamicLinkingTest.java</span><br><span class="line">  #23 = NameAndType        #12:#13        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #24 = NameAndType        #10:#11        // num:I</span><br><span class="line">  #25 = Class              #34            // java/lang/System</span><br><span class="line">  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;</span><br><span class="line">  #27 = Utf8               methodA()....</span><br><span class="line">  #28 = Class              #37            // java/io/PrintStream</span><br><span class="line">  #29 = NameAndType        #38:#39        // println:(Ljava/lang/String;)V</span><br><span class="line">  #30 = Utf8               methodB()....</span><br><span class="line">  #31 = NameAndType        #19:#13        // methodA:()V</span><br><span class="line">  #32 = Utf8               com/atguigu/java1/DynamicLinkingTest</span><br><span class="line">  #33 = Utf8               java/lang/Object</span><br><span class="line">  #34 = Utf8               java/lang/System</span><br><span class="line">  #35 = Utf8               out</span><br><span class="line">  #36 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #37 = Utf8               java/io/PrintStream</span><br><span class="line">  #38 = Utf8               println</span><br><span class="line">  #39 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.DynamicLinkingTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         7: putfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #4                  // String methodA()....</span><br><span class="line">         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #6                  // String methodB()....</span><br><span class="line">         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         9: invokevirtual #7                  // Method methodA:()V</span><br><span class="line">        <span class="number">12</span>: aload_0</span><br><span class="line">        <span class="number">13</span>: dup</span><br><span class="line">        14: getfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">17</span>: iconst_1</span><br><span class="line">        <span class="number">18</span>: iadd</span><br><span class="line">        19: putfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">22</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">23</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;DynamicLinkingTest.java&quot;</span></span><br></pre></td></tr></table></figure><p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p><p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p><ul><li>先找 #8 ：<ul><li>  <code>#8 = Class #32</code> ：去找 #32</li><li>  <code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li><li>  结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li></ul></li><li>再来找 #31：<ul><li>  <code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li><li>  <code>#19 = Utf8 methodA</code> ：方法名为 methodA</li><li>  <code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li></ul></li></ul><p>3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p><p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p><p><img src="/2021/02/08/JVM-3-2/image-20210208202029476.png" alt="image-20210208202029476"></p><blockquote><p>当常量池运行，信息会存放在方法区</p></blockquote><p><strong>为什么要用常量池呢？</strong></p><ol><li><p> 因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</p></li><li><p> 常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></li></ol><h2 id="重点-方法的调用"><a href="#重点-方法的调用" class="headerlink" title="重点-方法的调用"></a>重点-方法的调用</h2><h3 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li><strong>静态链接</strong>：</li></ul><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下<strong>将调用方法的符号引用转换为直接引用的过程称之为静态链接</strong></p><ul><li><strong>动态链接</strong>：</li></ul><p>如果被调用的方法在编译期无法被确定下来，也就是说，<strong>只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接</strong>。</p><h3 id="早期绑定与晚期绑定"><a href="#早期绑定与晚期绑定" class="headerlink" title="早期绑定与晚期绑定"></a>早期绑定与晚期绑定</h3><blockquote><p>静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p></blockquote><p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p><ul><li><strong>早期绑定</strong></li></ul><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p><ul><li><strong>晚期绑定</strong></li></ul><p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，多管闲事&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eat();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，天经地义&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAnimal</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHunt</span><span class="params">(Huntable h)</span> </span>&#123;</span><br><span class="line">        h.hunt();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>部分字节码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java2.AnimalTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">54</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAnimal</span><span class="params">(com.atguigu.java2.Animal)</span></span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Animal;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         1: invokevirtual #2                  // Method com/atguigu/java2/Animal.eat:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">56</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">57</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">1</span> animal   Lcom/atguigu/java2/Animal;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHunt</span><span class="params">(com.atguigu.java2.Huntable)</span></span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Huntable;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         1: invokeinterface #3,  1            // InterfaceMethod com/atguigu/java2/Huntable.hunt:()V</span><br><span class="line">         <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">60</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">61</span>: <span class="number">6</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">1</span>     h   Lcom/atguigu/java2/Huntable;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;AnimalTest.java&quot;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>invokevirtual 体现为晚期绑定</p></li><li><p>invokeinterface 也体现为晚期绑定</p></li><li><p>invokespecial 体现为早期绑定</p></li></ul></blockquote><h3 id="多态与绑定"><a href="#多态与绑定" class="headerlink" title="多态与绑定"></a>多态与绑定</h3><ol><li><p> 随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言<strong>具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式</strong>。</p></li><li><p> Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。<strong>如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法</strong>。</p></li></ol><h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><h5 id="虚方法与非虚方法的区别"><a href="#虚方法与非虚方法的区别" class="headerlink" title="虚方法与非虚方法的区别"></a><strong>虚方法与非虚方法的区别</strong></h5><ol><li><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</p><blockquote><p>静态方法、私有方法、final方法(前都不可被重写)、实例构造器(确定的)、父类方法(确定用父类方法)都是非虚方法</p></blockquote></li><li><p>其他方法称为虚方法(不确定)</p></li></ol><h5 id="子类对象的多态的使用前提："><a href="#子类对象的多态的使用前提：" class="headerlink" title="子类对象的多态的使用前提："></a><strong>子类对象的多态的使用前提：</strong></h5><blockquote><p>类的继承关系</p><p>方法的重写</p></blockquote><h5 id="虚拟机中调用方法的指令"><a href="#虚拟机中调用方法的指令" class="headerlink" title="虚拟机中调用方法的指令"></a><strong>虚拟机中调用方法的指令</strong></h5><ul><li><strong>普通指令：</strong></li></ul><ol><li> invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li> invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li> invokevirtual：调用所有虚方法</li><li> invokeinterface：调用接口方法</li></ol><blockquote><p>这四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。<strong>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法</strong>。</p></blockquote><ul><li><p><strong>动态调用指令</strong></p><p>invokedynamic：动态解析出需要调用的方法，然后执行</p><blockquote><ol><li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【<strong>动态类型语言</strong>】支持而做的一种改进。</li><li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的**Lambda表达式(函数式接口)**的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</li><li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Func</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">func</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">(Func func)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lambda lambda = <span class="keyword">new</span> Lambda();</span><br><span class="line"></span><br><span class="line">        Func func = s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        lambda.lambda(func);</span><br><span class="line"></span><br><span class="line">        lambda.lambda(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_004/0033.png"></li></ul><h5 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">showFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father show final&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCommon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father 普通方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showPrivate</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son private&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        showStatic(<span class="string">&quot;atguigu.com&quot;</span>);</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        <span class="keyword">super</span>.showStatic(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        showPrivate(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">super</span>.showCommon();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showFinal();<span class="comment">//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。如果加super，即super.showFinal，那么就是invokespecial</span></span><br><span class="line">        <span class="comment">//虚方法如下：</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        invokevirtual  你没有显示的加super.，编译器认为你可能调用子类的showCommon(即使son子类没有重写，也  会认为)，所以编译期间确定不下来，就是虚方法。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        showCommon();</span><br><span class="line">        info();</span><br><span class="line"></span><br><span class="line">        MethodInterface in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//invokeinterface</span></span><br><span class="line">        in.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Father f)</span> </span>&#123;</span><br><span class="line">        f.showCommon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son so = <span class="keyword">new</span> Son();</span><br><span class="line">        so.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MethodInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Son 类中 show() 方法的字节码指令如下</p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0032.png"><h3 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h3><ol><li><p>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言(Java)，反之是动态类型语言(js python)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String info = <span class="string">&quot;hjh&quot;</span>; <span class="comment">// 含具体类型， 如果为info=hjh则报错，说明编译期间会进行检查，不满足String类型，因此更严格</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;hjh&quot;</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="number">10</span><span class="comment">// var并不是真正的类型，只是形式上</span></span><br></pre></td></tr></table></figure></li><li><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是<strong>判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征</strong>。</p></li></ol><p>Java：String info = “mogu blog”;             (Java是静态类型语言的，会先编译就进行类型检查)<br>    JS：var name = “shkstart”;    var name = 10;    （运行时才进行检查）</p><pre><code>Python: info = 130.5 (运行时才检查)</code></pre><h3 id="Java语言中方法重写的本质"><a href="#Java语言中方法重写的本质" class="headerlink" title="Java语言中方法重写的本质"></a>Java语言中方法重写的本质</h3><ol><li><p>找到<strong>操作数栈顶的第一个元素</strong>所执行的对象的<strong>实际类型，记作C</strong>。</p></li><li><p>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。</p><ul><li>如果通过则返回这个方法的直接引用，查找过程结束</li></ul><ul><li>  如果不通过，则返回java.lang.IllegalAccessError 异常</li></ul></li><li><p>否则，按照继承关系<strong>从下往上</strong>依次对C的各个父类进行第2步的<strong>搜索和验证过程</strong>。</p></li><li><p>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常(是接口方法)。</p></li></ol><blockquote><p>上面这个过程称为<strong>动态分派</strong></p></blockquote><p><strong>IllegalAccessError介绍</strong></p><ol><li><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><blockquote><p>比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</p></blockquote></li></ol><h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><ol><li><p><strong>问题：</strong>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在<strong>每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率</strong>。</p><blockquote><p>解决：因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中(因为非常确定直接找到)。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</p></blockquote></li><li><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p></li></ol><p><strong>虚方法表何时创建：</strong></p><blockquote><p>虚方法表会在<strong>类加载的链接阶段</strong>被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</p><p><img src="/2021/02/08/JVM-3-2/image-20210208214249536.png" alt="image-20210208214249536"></p></blockquote><p><strong>例子1</strong></p><p>如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p><p><img src="/2021/02/08/JVM-3-2/image-20210208214306526.png" alt="image-20210208214306526"></p><blockquote><p>比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</p><p>下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</p></blockquote><p><strong>例子2</strong></p><p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20210208214727476.png" alt="image-20210208214727476"></p><p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20210208214749303.png" alt="image-20210208214749303"></p><p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20210208214959735.png" alt="image-20210208214959735"></p><p><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20210208215038812.png" alt="image-20210208215038812"></p><h2 id="内部结构-方法返回地址"><a href="#内部结构-方法返回地址" class="headerlink" title="内部结构-方法返回地址"></a>内部结构-方法返回地址</h2><p><img src="/2021/02/08/JVM-3-2/image-20210208230030202.png" alt="image-20210208230030202"></p><blockquote><p>在一些帖子里，方法返回地址、动态链接、一些附加信息  也叫做帧数据区</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li>  正常执行完成</li><li>  出现未处理的异常，非正常退出</li></ul></li><li><p> 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过<strong>异常表</strong>来确定，栈帧中一般不会保存这部分信息（所以是针对正常退出）。</p></li><li><p> 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p></li><li><p> <strong>正常完成出口和异常完成出口的区别</strong>在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p></li></ol><h3 id="方法退出的两种方式"><a href="#方法退出的两种方式" class="headerlink" title="方法退出的两种方式"></a><strong>方法退出的两种方式</strong></h3><p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p><h4 id="正常退出："><a href="#正常退出：" class="headerlink" title="正常退出："></a><strong>正常退出：</strong></h4><ol><li><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</p></li><li><p>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</p><p>在字节码指令中，返回指令包含：</p><ul><li><p>ireturn：当返回值是boolean，byte，char，short和int类型时使用</p></li><li><p>lreturn：Long类型</p></li><li><p>freturn：Float类型</p></li><li><p>dreturn：Double类型</p></li><li><p>areturn：引用类型</p></li><li><p>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</p></li></ul></li></ol><h4 id="异常退出："><a href="#异常退出：" class="headerlink" title="异常退出："></a><strong>异常退出：</strong></h4><ol><li><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</p><blockquote><p>方法执行过程中，抛出异常时的异常处理，存储在一个<strong>异常处理表</strong>，方便在发生异常的时候找到处理异常的代码</p><p><img src="/2021/02/08/JVM-3-2/image-20210208231006993.png" alt="image-20210208231006993"></p><p>注意：此处为字节码指令地址</p><p>上面表示：4-16行指令异常，用19行字节码指令方式处理，针对任何类型</p></blockquote></li></ol><p>异常处理表：</p><ul><li>  反编译字节码文件，可得到 Exception table</li><li>  from ：字节码指令起始地址</li><li>  to ：字节码指令结束地址</li><li>  target ：出现异常跳转至地址为 11 的指令执行</li><li>  type ：捕获异常的类型</li></ul><img src="/2021/02/08/JVM-3-2/../../../../../jvm/JVM/3-1-3JVM系列-第4章-虚拟机栈.assets/0041.png"><h2 id="内部结构-一些附加信息"><a href="#内部结构-一些附加信息" class="headerlink" title="内部结构-一些附加信息"></a>内部结构-一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三章-2：虚拟机栈&quot;&gt;&lt;a href=&quot;#第三章-2：虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;第三章-2：虚拟机栈&quot;&gt;&lt;/a&gt;第三章-2：虚拟机栈&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="运行时数据区" scheme="https://www.gtxhjh.cn/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    <category term="虚拟机栈" scheme="https://www.gtxhjh.cn/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>第三章_1-程序计数器(PC寄存器)</title>
    <link href="https://www.gtxhjh.cn/2021/02/08/JVM-3-1/"/>
    <id>https://www.gtxhjh.cn/2021/02/08/JVM-3-1/</id>
    <published>2021-02-08T15:52:54.000Z</published>
    <updated>2021-02-08T15:58:44.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-1：程序计数器-PC寄存器"><a href="#第三章-1：程序计数器-PC寄存器" class="headerlink" title="第三章-1：程序计数器(PC寄存器)"></a>第三章-1：程序计数器(PC寄存器)</h1><h2 id="PC寄存器介绍"><a href="#PC寄存器介绍" class="headerlink" title="PC寄存器介绍"></a>PC寄存器介绍</h2><blockquote><p>官方文档网址：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p></blockquote><p><img src="/2021/02/08/JVM-3-1/image-20210205205040315.png" alt="image-20210205205040315"></p><ol><li> JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li><li> 这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子（钩代码，行号指示器）），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</li><li> 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li> 在JVM规范中，<strong>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</strong>。</li><li> 任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。<strong>程序计数器会存储当前线程正在执行的Java方法的JVM指令地址</strong>；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li> 它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li> 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li> 它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域（无垃圾回收和OOM异常）</li></ol><h2 id="PC寄存器的作用"><a href="#PC寄存器的作用" class="headerlink" title="PC寄存器的作用"></a>PC寄存器的作用</h2><p>PC寄存器用来存储指向<strong>下一条指令的地址</strong>，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</p><p><img src="/2021/02/08/JVM-3-1/image-20210205205251917.png" alt="image-20210205205251917"></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line"></span><br><span class="line">        String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看字节码</p><blockquote><p>看字节码的方法：<a href="https://blog.csdn.net/21aspnet/article/details/88351875">https://blog.csdn.net/21aspnet/article/details/88351875</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter04/com/atguigu/java/PCRegisterTest.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">2</span>; size <span class="number">675</span> bytes</span><br><span class="line">  MD5 checksum 53b3ef104479ec9e9b7ce5319e5881d3</span><br><span class="line">  Compiled from <span class="string">&quot;PCRegisterTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java</span>.<span class="title">PCRegisterTest</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#26         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #27            // abc</span><br><span class="line">   #3 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Methodref          #30.#31        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #5 = Class              #32            // com/atguigu/java/PCRegisterTest</span><br><span class="line">   #6 = Class              #33            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/atguigu/java/PCRegisterTest;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               i</span><br><span class="line">  #19 = Utf8               I</span><br><span class="line">  #20 = Utf8               j</span><br><span class="line">  #21 = Utf8               k</span><br><span class="line">  #22 = Utf8               s</span><br><span class="line">  #23 = Utf8               Ljava/lang/String;</span><br><span class="line">  #24 = Utf8               SourceFile</span><br><span class="line">  #25 = Utf8               PCRegisterTest.java</span><br><span class="line">  #26 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #27 = Utf8               abc</span><br><span class="line">  #28 = Class              #34            // java/lang/System</span><br><span class="line">  #29 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;</span><br><span class="line">  #30 = Class              #37            // java/io/PrintStream</span><br><span class="line">  #31 = NameAndType        #38:#39        // println:(I)V</span><br><span class="line">  #32 = Utf8               com/atguigu/java/PCRegisterTest</span><br><span class="line">  #33 = Utf8               java/lang/Object</span><br><span class="line">  #34 = Utf8               java/lang/System</span><br><span class="line">  #35 = Utf8               out</span><br><span class="line">  #36 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #37 = Utf8               java/io/PrintStream</span><br><span class="line">  #38 = Utf8               println</span><br><span class="line">  #39 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java.PCRegisterTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java/PCRegisterTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">5</span>: istore_2</span><br><span class="line">         <span class="number">6</span>: iload_1</span><br><span class="line">         <span class="number">7</span>: iload_2</span><br><span class="line">         <span class="number">8</span>: iadd</span><br><span class="line">         <span class="number">9</span>: istore_3</span><br><span class="line">        10: ldc           #2                  // String abc</span><br><span class="line">        <span class="number">12</span>: astore        <span class="number">4</span></span><br><span class="line">        14: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">17</span>: iload_1</span><br><span class="line">        18: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        21: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">24</span>: iload_3</span><br><span class="line">        25: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">14</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">21</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span>     i   I</span><br><span class="line">            <span class="number">6</span>      <span class="number">23</span>     <span class="number">2</span>     j   I</span><br><span class="line">           <span class="number">10</span>      <span class="number">19</span>     <span class="number">3</span>     k   I</span><br><span class="line">           <span class="number">14</span>      <span class="number">15</span>     <span class="number">4</span>     s   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;PCRegisterTest.java&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>左边的数字代表<strong>指令地址（指令偏移）</strong>，即 PC 寄存器中可能存储的值，</p><p>执行引擎会读取 PC 寄存器中的值，操作虚拟机栈结构实现数据存取，并翻译指令为机器指令，让CPU做运算</p></li></ul><p><img src="/2021/02/08/JVM-3-1/image-20210205210241883.png" alt="image-20210205210241883"></p><h2 id="两个面试题"><a href="#两个面试题" class="headerlink" title="两个面试题"></a>两个面试题</h2><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？</strong>或者问<strong>为什么使用 PC 寄存器来记录当前线程的执行地址呢？</strong></p><ol><li><p> 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</p></li><li><p> JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</p></li></ol><p><img src="/2021/02/08/JVM-3-1/image-20210205210359065.png" alt="image-20210205210359065"></p><p><strong>PC寄存器为什么被设定为私有的？</strong></p><ol><li> 所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是==为每一个线程都分配一个PC寄存器==**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li> 由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li> 这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会<strong>产生自己的程序计数器和栈帧</strong>，程序计数器在各个线程之间互不影响。</li></ol><h2 id="CPU-时间片"><a href="#CPU-时间片" class="headerlink" title="CPU 时间片"></a>CPU 时间片</h2><ol><li><p> CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p></li><li><p> 在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p></li><li><p> 但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三章-1：程序计数器-PC寄存器&quot;&gt;&lt;a href=&quot;#第三章-1：程序计数器-PC寄存器&quot; class=&quot;headerlink&quot; title=&quot;第三章-1：程序计数器(PC寄存器)&quot;&gt;&lt;/a&gt;第三章-1：程序计数器(PC寄存器)&lt;/h1&gt;&lt;h2 id=&quot;PC寄</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="运行时数据区" scheme="https://www.gtxhjh.cn/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    <category term="程序计数器" scheme="https://www.gtxhjh.cn/tags/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>第三章-运行时数据区概述及线程</title>
    <link href="https://www.gtxhjh.cn/2021/02/08/JVM-3/"/>
    <id>https://www.gtxhjh.cn/2021/02/08/JVM-3/</id>
    <published>2021-02-08T15:50:10.000Z</published>
    <updated>2021-03-01T15:24:26.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章：运行时数据区概述及线程"><a href="#第3章：运行时数据区概述及线程" class="headerlink" title="第3章：运行时数据区概述及线程"></a>第3章：运行时数据区概述及线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="/2021/02/08/JVM-3/image-20210205202840541.png" alt="image-20210205202840541"></p><p>当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到<strong>运行时数据区</strong></p><p><img src="/2021/02/08/JVM-3/image-20210205203026946.png" alt="image-20210205203026946"></p><h2 id="运行时数据区结构"><a href="#运行时数据区结构" class="headerlink" title="运行时数据区结构"></a>运行时数据区结构</h2><h3 id="运行时数据区与内存"><a href="#运行时数据区与内存" class="headerlink" title="运行时数据区与内存"></a>运行时数据区与内存</h3><ol><li><p>内存是非常重要的系统资源，是<strong>硬盘和CPU的中间仓库及<em>桥梁</em></strong>，<strong>承载着操作系统和应用程序的<em>实时运行</em></strong>。==JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略==，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p></li><li><p>通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p></li></ol><blockquote><p>下图来自阿里巴巴手册JDK8</p></blockquote><p><img src="/2021/02/08/JVM-3/image-20210205203750578.png" alt="image-20210205203750578"></p><h3 id="线程的内存空间"><a href="#线程的内存空间" class="headerlink" title="线程的内存空间"></a>线程的内存空间</h3><ol><li><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是<strong>与线程一一对应</strong>的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p><img src="/2021/02/08/JVM-3/image-20210205203901582.png" alt="image-20210205203901582"></p></li><li><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>线程独有：独立包括程序计数器、栈、本地方法栈</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><strong>一般优化的就是堆空间、方法区，即共享部分</strong></p></li></ol><p><img src="/2021/02/08/JVM-3/image-20210205203843572.png" alt="image-20210205203843572"></p><h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p><strong>每个JVM只有一个Runtime实例</strong>。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p><blockquote><p>一个JVM对应一个Runtime实例，相当于运行时数据区</p></blockquote><p><img src="/2021/02/08/JVM-3/image-20210205204337554.png" alt="image-20210205204337554"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="JVM-线程"><a href="#JVM-线程" class="headerlink" title="JVM 线程"></a>JVM 线程</h3><ol><li><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</p></li><li><p><strong>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射</strong></p><blockquote><p>对于Java层面的线程，运行时真正调用的是操作系统的本地线程</p><p>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</p></blockquote></li><li><p>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</p></li></ol><h3 id="JVM-系统线程"><a href="#JVM-系统线程" class="headerlink" title="JVM 系统线程"></a>JVM 系统线程</h3><ul><li><p>如果使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</p></li><li><p>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p></li></ul><ol><li> <strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到<strong>安全点</strong>才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li> <strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行(典型的后台线程)</li><li> <strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li><li> <strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li><li> <strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第3章：运行时数据区概述及线程&quot;&gt;&lt;a href=&quot;#第3章：运行时数据区概述及线程&quot; class=&quot;headerlink&quot; title=&quot;第3章：运行时数据区概述及线程&quot;&gt;&lt;/a&gt;第3章：运行时数据区概述及线程&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="运行时数据区" scheme="https://www.gtxhjh.cn/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    <category term="概述" scheme="https://www.gtxhjh.cn/tags/%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>第二章-类加载子系统</title>
    <link href="https://www.gtxhjh.cn/2021/02/08/JVM-2/"/>
    <id>https://www.gtxhjh.cn/2021/02/08/JVM-2/</id>
    <published>2021-02-08T15:46:29.000Z</published>
    <updated>2021-03-01T15:24:39.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第2章：类加载子系统"><a href="#第2章：类加载子系统" class="headerlink" title="第2章：类加载子系统"></a>第2章：类加载子系统</h1><h2 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h2><h3 id="简图"><a href="#简图" class="headerlink" title="简图"></a>简图</h3><p><img src="images/image-20210202225707366.png" alt="image-20210202225707366"></p><ul><li>字节码文件通过类加载器子系统加载到内存</li><li>生成class对象，以及静态属性初始化等，主要在方法区</li><li>字节码指令的执行依靠执行引擎</li></ul><h3 id="详细图"><a href="#详细图" class="headerlink" title="详细图"></a>详细图</h3><p><img src="images/image-20210202225935448.png" alt="image-20210202225935448"></p><p><img src="images/image-20210202225952912.png" alt="image-20210202225952912"></p><blockquote><ol><li>加载</li></ol><p>验证、准备、解析</p><p>初始化</p><ol start="2"><li>内存层面、运行时数据区：</li></ol><p>PC寄存器（每个线程一份）</p><p>栈：虚拟机栈，每个线程一份，每个结构为栈帧</p><p>本地方法栈：涉及到本地方法接口调用</p><p>堆区：存放创建java对象</p><p>方法区：类信息、常量、域信息等</p><ol start="3"><li>执行引擎：</li></ol><p>解释器、即时编译器、垃圾回收器</p></blockquote><h2 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h2><p><strong>类加载器子系统作用：</strong></p><ol><li><p> 类加载器子系统<strong>负责从文件系统或者网络中加载Class文件</strong>，class文件在文件开头有特定的<em>文件标识</em>（验证阶段实现）。</p></li><li><p> ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p></li><li><p> <strong>==加载的类信息存放于一块称为方法区的内存空间==**。除了类的信息外，</strong>方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量**（这部分常量信息是Class文件中常量池部分的内存映射）</p></li></ol><p><img src="images/image-20210202234728432.png" alt="image-20210202234728432"></p><h2 id="类加载器ClassLoader角色"><a href="#类加载器ClassLoader角色" class="headerlink" title="类加载器ClassLoader角色"></a>类加载器ClassLoader角色</h2><ol><li> class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li> class file加载到JVM中，被称为DNA元数据模板（Car Class），放在方法区。</li><li> 在.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ol><p><img src="images/image-20210202235014793.png" alt="image-20210202235014793"></p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;谢谢ClassLoader加载我....&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;你的大恩大德，我下辈子再报！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加载过程</strong>：</p><ol><li>执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader</li><li>当前类是否加载？如果没有加载需要使用相应classloader装载，自定义类使用系统类加载器，加载中如果有问题抛出异常，相应的看字节码文件.class，如果<strong>不是合法的那么会有异常</strong></li><li>加载成功，有了class对象，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main</li></ol><p><img src="images/image-20210202235337618.png" alt="image-20210202235337618"></p><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p><strong>加载：</strong></p><ol><li><p> 通过一个类的全限定名获取定义此类的二进制字节流</p></li><li><p> 将这个字节流所代表的静态存储结构转化为方法区（源空间）的运行时数据结构</p></li><li><p> **==在内存中生成一个代表这个类的java.lang.Class对象(实例)==**，作为方法区这个类的各种数据的访问入口</p></li></ol><p><strong>加载class文件的方式：</strong></p><ol><li> 从本地系统中直接加载</li><li> 通过网络获取，典型场景：Web Applet</li><li> 从zip压缩包中读取，成为日后jar、war格式的基础（字节码文件）</li><li> 运行时计算生成，使用最多的是：动态代理技术</li><li> 由其他文件生成，典型场景：JSP应用</li><li> 从专有数据库中提取.class文件，比较少见</li><li> 从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ol><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><p>链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析</p><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证(Verify)"></a>验证(Verify)</h4><ol><li> 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。不合法会报verifyerror</li><li> 主要包括四种验证：<strong>文件格式验证，元数据验证，字节码验证，符号引用验证</strong>。</li></ol><p><strong>举例</strong></p><p>使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。</p><h4 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备(Prepare)"></a>准备(Prepare)</h4><ol><li> 为类变量（static<strong>变量</strong>）分配内存并且设置该类变量的<strong>默认初始值</strong>，即零值</li><li> 这里不包含用final修饰的static（这个就不是变量而是常量），因为final在<strong>编译的时候就会分配好了默认值</strong>，准备阶段会显式初始化</li><li> 注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li></ol><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//prepare阶段只是给a赋值为0，initial初始化阶段才为1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析(Resolve)"></a>解析(Resolve)</h4><ol><li><p> <strong>将常量池内的符号引用转换为直接引用的过程</strong></p></li><li><p> 事实上，<strong>解析操作往往会伴随着JVM在执行完初始化之后再执行</strong></p></li><li><p> 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p></li><li><p> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p></li></ol><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><h4 id="类的初始化时机-类的主动使用和被动使用"><a href="#类的初始化时机-类的主动使用和被动使用" class="headerlink" title="类的初始化时机/类的主动使用和被动使用"></a>类的初始化时机/类的主动使用和被动使用</h4><p>Java程序对类的使用方式分为：主动使用和被动使用</p><h5 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h5><ol><li><p><strong>创建</strong>类的实例(造对象)</p></li><li><p><strong>访问</strong>某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p><strong>调用</strong>类的静态方法</p></li><li><p><strong>反射主动加载</strong>（比如：Class.forName(“com.atguigu.Test”)）</p></li><li><p>初始化一个类的子类（父类也会主动使用）</p></li><li><p>Java虚拟机启动时<strong>被标明为启动类的类</strong></p></li><li><p>JDK7开始提供的<strong>动态语言支持</strong></p><p>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</p></li></ol><h5 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h5><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，<strong>都不会导致类的初始化</strong>，即不会执行初始化阶段（==不会调用 clinit() 方法和 init() 方法==）</p><blockquote><p>会加载，但不会初始化，因为有静态代码块的执行等</p></blockquote><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li><p> 初始化阶段就是执行<strong>类构造器方法</strong><code>&lt;clinit&gt;()</code>的过程</p></li><li><p> 此方法不需定义，是<strong>javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句==合并==而来</strong>。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</p></li><li><p> <code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</p></li><li><p> <code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>（类的<strong>构造器函数</strong>））</p></li><li><p> 若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code><strong>执行</strong>前，父类的<code>&lt;clinit&gt;()</code>已经<strong>执行完毕</strong></p></li><li><p> 虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁（一个类只会被加载一次）</p></li></ol><h4 id="1，2，3说明"><a href="#1，2，3说明" class="headerlink" title="1，2，3说明"></a>1，2，3说明</h4><p><strong>举例1：有static变量</strong></p><p>查看下面这个代码的字节码，可以发现有一个<code>&lt;clinit&gt;()</code>方法。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0009.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       num = <span class="number">2</span>;</span><br><span class="line">       number = <span class="number">20</span>;</span><br><span class="line">       System.out.println(num);</span><br><span class="line">       <span class="comment">//System.out.println(number);//报错：非法的前向引用。</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span></span><br><span class="line"><span class="comment">    * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会</span></span><br><span class="line"><span class="comment">    * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);<span class="comment">//2</span></span><br><span class="line">        System.out.println(ClassInitTest.number);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&lt;clint字节码&gt;：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> 1 putstatic #3 &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"> <span class="number">4</span> iconst_2</span><br><span class="line"> 5 putstatic #3 &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"> <span class="number">8</span> bipush <span class="number">20</span> <span class="comment">//先赋20</span></span><br><span class="line">10 putstatic #5 &lt;com/atguigu/java/ClassInitTest.number&gt;</span><br><span class="line">13 getstatic #2 &lt;java/lang/System.out&gt;</span><br><span class="line">16 getstatic #3 &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line">19 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">22</span> bipush <span class="number">10</span><span class="comment">//再赋10</span></span><br><span class="line">24 putstatic #5 &lt;com/atguigu/java/ClassInitTest.number&gt;</span><br><span class="line"><span class="number">27</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>当我们代码中包含static变量的时候，就会有clinit方法</p><p><strong>举例2：无 static 变量</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0010.png"><p>加上之后就有了</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0011.png"><h4 id="4说明"><a href="#4说明" class="headerlink" title="4说明"></a>4说明</h4><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0012.png"><p>在构造器中：</p><ul><li>先将类变量 a 赋值为 10</li><li>再将局部变量赋值为 20</li></ul><h4 id="5说明"><a href="#5说明" class="headerlink" title="5说明"></a>5说明</h4><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0013.png"><p>如上代码，加载流程如下：</p><ul><li>首先，执行 main() 方法需要加载 ClinitTest1 类</li><li>获取 Son.B 静态变量，需要加载 Son 类</li><li>Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载</li></ul><h4 id="6说明"><a href="#6说明" class="headerlink" title="6说明"></a>6说明</h4><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被<strong>同步加锁</strong></p><ul><li>类往内存的加载，只加载一次，加载到方法区</li><li>再使用，使用内存中类本身</li><li>因此一个类加载只调用一次clinit方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">            DeadThread dead = <span class="keyword">new</span> DeadThread();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程2开始</span><br><span class="line">线程1开始</span><br><span class="line">线程2初始化当前类</span><br><span class="line"></span><br><span class="line">&#x2F;然后程序卡死了</span><br></pre></td></tr></table></figure><p>程序卡死，分析原因：</p><ul><li>  两个线程<strong>同时去加载 DeadThread 类</strong>，而 DeadThread 类中静态代码块中有一处死循环</li><li>  <strong>先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放</strong></li><li>  所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）</li></ul><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol><li><p>JVM严格来讲支持两种类型的类加载器 。分别为<strong>引导类加载器</strong>（Bootstrap ClassLoader）和<strong>自定义类加载器</strong>（User-Defined ClassLoader）</p></li><li><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有==派生于抽象类ClassLoader的类加载器==都划分为自定义类加载器</strong></p></li><li><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</p></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0014.png"><p><strong>ExtClassLoader</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0015.png"><p><strong>AppClassLoader</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0016.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2 Launcher内部类</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器 包含关系</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//试图获取其上层：获取不到引导类加载器</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        <span class="comment">// 反射</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        ClassLoader classLoader1 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，<strong>因为引导类加载器右 C/C++ 语言，我们获取不到</strong></li><li>  Java的核心类库都是使用引导类加载器进行加载的</li><li>  两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明<strong>系统类加载器是全局唯一的</strong></li></ul><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><blockquote><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p></blockquote><ol><li> 这个类加载使用C/C++语言实现的，<strong>嵌套在JVM内部</strong></li><li> 它用来<strong>加载Java的核心库</strong>（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于<strong>提供JVM自身需要的类</strong></li><li> 并<strong>不继承自java.lang.ClassLoader，没有父加载器</strong></li><li> <strong>加载==扩展类和应用程序类加载器==，并作为他们的父类加载器</strong></li><li> 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ol><h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><blockquote><p><strong>扩展类加载器（Extension ClassLoader）</strong></p></blockquote><ol><li> <strong>Java语言编写</strong>，由sun.misc.Launcher$ExtClassLoader实现</li><li> <strong>派生于ClassLoader类</strong></li><li> 父类加载器为启动类加载器</li><li> 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。<strong>如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</strong></li></ol><h4 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h4><blockquote><p><strong>应用程序类加载器（也称为系统类加载器，AppClassLoader）</strong></p></blockquote><ol><li> Java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li> <strong>派生于ClassLoader类</strong></li><li> 父类加载器为扩展类加载器</li><li> 它<strong>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</strong></li><li> <strong>该类加载是程序中默认的类加载器</strong>，一般来说，Java应用的类都是由它来完成加载</li><li> 通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;**********启动类加载器**************&quot;</span>);</span><br><span class="line">        <span class="comment">//获取BootstrapClassLoader能够加载的api的路径</span></span><br><span class="line">        URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL element : urLs) &#123;</span><br><span class="line">            System.out.println(element.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span></span><br><span class="line">        ClassLoader classLoader = Provider.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***********扩展类加载器*************&quot;</span>);</span><br><span class="line">        String extDirs = System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String path : extDirs.split(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span></span><br><span class="line">        ClassLoader classLoader1 = CurveDB.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**********启动类加载器**************</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/resources.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/rt.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/sunrsasign.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/jsse.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/jce.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/charsets.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/jfr.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/classes</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">***********扩展类加载器*************</span><br><span class="line">C:\Program Files\Java\jdk1<span class="number">.8</span><span class="number">.0_131</span>\jre\lib\ext</span><br><span class="line">C:\Windows\Sun\Java\lib\ext</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@29453f44</span><br></pre></td></tr></table></figure><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><h4 id="什么时候需要自定义类加载器？"><a href="#什么时候需要自定义类加载器？" class="headerlink" title="什么时候需要自定义类加载器？"></a>什么时候需要自定义类加载器？</h4><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来<strong>定制类的加载方式</strong>。那为什么还需要自定义类加载器？</p><ol><li> 隔离加载类（中间件模块之间是隔离的，比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了（就要类仲裁）。不过<strong>一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间件之间是隔离的</strong>）</li><li> 修改类加载的方式</li><li> 扩展加载源（还可以考虑<strong>从数据库中加载类，路由器等等不同的地方加载</strong>）</li><li> 防止源码泄漏（<strong>对字节码文件进行<em>解密</em>，自己用的时候通过自定义类加载器来对其进行解密</strong>）</li></ol><h4 id="用户自定义类加载器实现步骤"><a href="#用户自定义类加载器实现步骤" class="headerlink" title="用户自定义类加载器实现步骤"></a>用户自定义类加载器实现步骤</h4><ol><li> 开发人员可以通过<strong>继承抽象类java.lang.ClassLoader类</strong>的方式，实现自己的类加载器，以满足一些特殊的需求</li><li> 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议<strong>把自定义的类加载逻辑写在findclass()方法中</strong></li><li> 在编写自定义类加载器时，<strong>如果没有太过于复杂的需求，可以直接继承URIClassLoader类</strong>，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><p>后详细</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//defineClass和findClass搭配使用</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//自定义流的获取方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassFromCustomPath(String name) &#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>, <span class="keyword">true</span>, customClassLoader);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><blockquote><p><strong>ClassLoader 类介绍</strong></p></blockquote><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（自定义类，不包括启动类加载器）</p><p><img src="images/image-20210204000243579.png" alt="image-20210204000243579"></p><p>sun.misc.Launcher它是一个java虚拟机的入口应用，扩展类和系统加载类都是其内部类</p><p><img src="images/image-20210204000529087.png" alt="image-20210204000529087"></p><h4 id="获取ClassLoader途径"><a href="#获取ClassLoader途径" class="headerlink" title="获取ClassLoader途径"></a>获取ClassLoader途径</h4><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0019.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.</span></span><br><span class="line">            ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            <span class="comment">//2.</span></span><br><span class="line">            ClassLoader classLoader1 = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            System.out.println(classLoader1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.</span></span><br><span class="line">            ClassLoader classLoader2 = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">            System.out.println(classLoader2);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="双亲委派机制原理"><a href="#双亲委派机制原理" class="headerlink" title="双亲委派机制原理"></a>双亲委派机制原理</h3><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说<strong>当需要使用该类时才会将它的class文件<em>加载到内存生成class对象</em></strong>。而且加载某个类的class文件时，Java虚拟机采用的是**==双亲委派模式，即把请求交由父类处理，它是一种任务委派模式==**</p><ol><li> 如果一个类加载器收到了类加载请求，它<strong>并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</strong>；（如扩展类加载器）</li><li> 如果父类加载器还存在其父类加载器，则<strong>进一步向上委托</strong>，依次递归，请求最终将到达顶层的启动类加载器；（如到引导类加载器）</li><li> 如果<strong>父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载</strong>，这就是双亲委派模式。</li><li> 父类加载器一层一层往下分配任务，<strong>如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</strong></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0020.png"><h3 id="双亲委派机制代码演示"><a href="#双亲委派机制代码演示" class="headerlink" title="双亲委派机制代码演示"></a>双亲委派机制代码演示</h3><h4 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h4><p>1、我们自己建立一个 java.lang.String 类，写上 static 代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        java.lang.String str = <span class="keyword">new</span> java.lang.String();</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,atguigu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        StringTest test = <span class="keyword">new</span> StringTest();</span><br><span class="line">        System.out.println(test.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello,atguigu.com</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><p>程序并没有输出我们静态代码块中的内容，可见<em>仍然加载的是 JDK 自带的 String 类</em>。</p><p>把刚刚的类改一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img/JVM/chapter_002/0021.png"><blockquote><p>由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader引导类加载器，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，<strong>在那个String类中并没有 main() 方法</strong>，所以就报了上面的错误。</p></blockquote><h4 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShkStart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br><span class="line">at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="number">662</span>)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">761</span>)</span><br><span class="line">at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:<span class="number">142</span>)</span><br><span class="line">at java.net.URLClassLoader.defineClass(URLClassLoader.java:<span class="number">467</span>)</span><br><span class="line">at java.net.URLClassLoader.access$<span class="number">100</span>(URLClassLoader.java:<span class="number">73</span>)</span><br><span class="line">at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">368</span>)</span><br><span class="line">at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">362</span>)</span><br><span class="line">at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">361</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">335</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:<span class="number">495</span>)</span><br><span class="line">Error: A JNI error has occurred, please check your installation and <span class="keyword">try</span> again</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> </span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制</strong></p><h4 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h4><p>当我们加载jdbc.jar 用于实现数据库连接的时候</p><ol><li><p>我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api</p></li><li><p>然后使用双亲委派机制，引导类加载器把rt.jar包加载进来，而<strong>rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类</strong>了</p></li><li><p><strong>具体的实现类就涉及到了某些第三方的jar包</strong>，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】</p></li><li><p><strong>==第三方的jar包中的类不属于核心api，属于系统类加载器来加载==</strong></p><blockquote><p>出现反向委派，系统类加载器，由当前线程上下文类加载器来加载具体实现类的api</p></blockquote></li><li><p>从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载</p></li></ol><p><img src="images/image-20210204001822391.png" alt="image-20210204001822391"></p><h3 id="双亲委派机制优势"><a href="#双亲委派机制优势" class="headerlink" title="双亲委派机制优势"></a>双亲委派机制优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p><ol><li><p>避免类的重复加载（类的层次关系来避免重复加载（只加载一次））</p></li><li><p>保护程序安全，防止核心API被随意篡改</p><ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ol><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><ul><li>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li><li>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a>如何判断两个class对象是否相同？</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li> 类的<strong>完整类名</strong>必须一致，<strong>包括包名</strong></li><li> <strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li></ol><blockquote><p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</p></blockquote><h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><ol><li><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</p><blockquote><ul><li><p><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></p></li><li><p>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（动态链接需要，后面讲）</p></li></ul></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第2章：类加载子系统&quot;&gt;&lt;a href=&quot;#第2章：类加载子系统&quot; class=&quot;headerlink&quot; title=&quot;第2章：类加载子系统&quot;&gt;&lt;/a&gt;第2章：类加载子系统&lt;/h1&gt;&lt;h2 id=&quot;内存结构概述&quot;&gt;&lt;a href=&quot;#内存结构概述&quot; class=&quot;</summary>
      
    
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://www.gtxhjh.cn/tags/jvm/"/>
    
    <category term="类加载子系统" scheme="https://www.gtxhjh.cn/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Flume自定义Sink</title>
    <link href="https://www.gtxhjh.cn/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Sink/"/>
    <id>https://www.gtxhjh.cn/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Sink/</id>
    <published>2021-02-07T07:56:25.000Z</published>
    <updated>2021-02-07T08:01:25.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flume自定义组件-Sink"><a href="#Flume自定义组件-Sink" class="headerlink" title="Flume自定义组件-Sink"></a>Flume自定义组件-Sink</h1><blockquote><p>Sink <strong>不断地轮询</strong> Channel 中的事件且<strong>批量地移除</strong>它们，并将这些事件批量写入到存储或索引系统、或者被发送到另一个 Flume Agent</p><p>Sink是完全事务性的。在从 Channel批量删除数据之前，每个 Sink用 Channel 启动一个事务。批量事件一旦成功写出到存储系统或下一个 Flume Agent，Sink就利用 Channel提交事务。<strong>事务一旦被提交，该 Channel从自己的内部缓冲区删除事件（否则重复数据）</strong>。 </p></blockquote><p>Sink组件目的地包括 hdfs、logger、avro、thrift、ipc、file、null、HBase、solr、自定义。官方提供的 Sink 类型已经很多，但是有时候并不能满足实际开发当中的需求，此时我们就需要根据实际需求自定义某些Sink。 </p><p>官方也提供了自定义 sink的接口： <a href="https://flume.apache.org/FlumeDeveloperGuide.html#sink">https://flume.apache.org/FlumeDeveloperGuide.html#sink</a> </p><blockquote><p>根据官方说明自定义MySink需要继承AbstractSink类并实现Configurable 接口。 </p><p>实现相应方法：<br>configure(Context context)//初始化context（读取配置文件内容） </p><p>process()//从Channel读取获取数据（event），这个方法将被循环调用。 </p><p>使用场景：读取 Channel数据写入MySQL或者其他文件系统。</p></blockquote><h2 id="自定义Sink"><a href="#自定义Sink" class="headerlink" title="自定义Sink"></a>自定义Sink</h2><h3 id="案例需求"><a href="#案例需求" class="headerlink" title="案例需求"></a>案例需求</h3><p>使用 flume接收数据，并在 Sink端给每条数据添加前缀和后缀，输出到控制台。前后缀可在flume任务配置文件中配置。 </p><h3 id="步骤示意图"><a href="#步骤示意图" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Sink/image-20210207113405264.png" alt="image-20210207113405264"></p><ol><li><p>自定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hjh.sink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flume.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.conf.Configurable;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.sink.AbstractSink;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 家慧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-02-07 14:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySink</span> <span class="keyword">extends</span> <span class="title">AbstractSink</span> <span class="keyword">implements</span> <span class="title">Configurable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义两个属性，前后缀</span></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String subfix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取logger对象</span></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(MySink.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置文件，为前后缀赋值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-07 14:43:46</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        prefix = context.getString(<span class="string">&quot;prefix&quot;</span>);</span><br><span class="line">        subfix = context.getString(<span class="string">&quot;subfix&quot;</span>, <span class="string">&quot;hjh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.获取channel</span></span><br><span class="line"><span class="comment">     * 2.从channel获取事务以及数据</span></span><br><span class="line"><span class="comment">     * 3.发送数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-07 14:45:12 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> EventDeliveryException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取返回值</span></span><br><span class="line">        Status status = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 2.获取channel</span></span><br><span class="line">        Channel channel = getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.从channel获取事务</span></span><br><span class="line">        Transaction transaction = channel.getTransaction();</span><br><span class="line">        <span class="comment">// 4.开启事务</span></span><br><span class="line">        transaction.begin();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 5.从channel获取数据</span></span><br><span class="line">            Event event = channel.take();</span><br><span class="line">            <span class="comment">// 6.处理事件</span></span><br><span class="line">            <span class="keyword">if</span> (event != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 事件体</span></span><br><span class="line">                String body = <span class="keyword">new</span> String(event.getBody());</span><br><span class="line">                <span class="comment">// 不用sout，用logger，需要logger对象</span></span><br><span class="line">                <span class="comment">// 调用各种级别的日志：info error debug warn</span></span><br><span class="line">                logger.info( prefix + body + subfix);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7.提交事务, 成功状态</span></span><br><span class="line">            transaction.commit();</span><br><span class="line">            status = Status.READY;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ChannelException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 提交失败, 回滚</span></span><br><span class="line">            transaction.rollback();</span><br><span class="line">            status = Status.BACKOFF;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭事务</span></span><br><span class="line">            transaction.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打包</p></li><li><p>配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a1.sources.r1.type &#x3D; netcat </span><br><span class="line">a1.sources.r1.bind &#x3D; localhost </span><br><span class="line">a1.sources.r1.port &#x3D; 44444 </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a1.sinks.k1.type &#x3D; com.atguigu.MySink </span><br><span class="line">#a1.sinks.k1.prefix &#x3D; atguigu: </span><br><span class="line">a1.sinks.k1.suffix &#x3D; :atguigu </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;flume-ng agent -c conf&#x2F; -f job&#x2F;mysink.conf -n a1 -Dflume.root.logger&#x3D;INFO,console </span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flume自定义组件-Sink&quot;&gt;&lt;a href=&quot;#Flume自定义组件-Sink&quot; class=&quot;headerlink&quot; title=&quot;Flume自定义组件-Sink&quot;&gt;&lt;/a&gt;Flume自定义组件-Sink&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Sink </summary>
      
    
    
    
    <category term="Flume" scheme="https://www.gtxhjh.cn/categories/Flume/"/>
    
    
    <category term="flume" scheme="https://www.gtxhjh.cn/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>Flume自定义Source</title>
    <link href="https://www.gtxhjh.cn/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Source/"/>
    <id>https://www.gtxhjh.cn/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Source/</id>
    <published>2021-02-07T07:56:15.000Z</published>
    <updated>2021-02-07T08:01:08.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flume自定义组件-Source"><a href="#Flume自定义组件-Source" class="headerlink" title="Flume自定义组件-Source"></a>Flume自定义组件-Source</h1><h2 id="自定义Source"><a href="#自定义Source" class="headerlink" title="自定义Source"></a>自定义Source</h2><blockquote><p>Source是负责接收数据到Flume Agent的组件。Source组件可以处理各种类型、各种格式的日志数据，包括avro、thrift、exec、jms、spooling directory、netcat、sequence generator、syslog、http、legacy。官方提供的 source类型已经很多，但是有时候并不能满足实际开发当中的需求，此时我们就需要根据实际需求自定义某些source。</p></blockquote><p>官方提供了自定义 source的接口： </p><p><a href="https://flume.apache.org/FlumeDeveloperGuide.html#source">https://flume.apache.org/FlumeDeveloperGuide.html#source</a> 根据官方说明自定义MySource</p><blockquote><p>需要继承AbstractSource类并实现Configurable 和PollableSource 接口</p><p>实现相应方法：<br>getBackOffSleepIncrement()//暂不用<br>getMaxBackOffSleepInterval()//暂不用<br>configure(Context context)//初始化context（读取配置文件内容，加载） </p><p>process()//获取数据，封装成 event并写入channel，这个方法将被循环调用， <strong>使用场景</strong>：读取 MySQL数据或者其他文件系统。 </p></blockquote><h3 id="案例需求"><a href="#案例需求" class="headerlink" title="案例需求"></a>案例需求</h3><p>使用flume接收数据，并给每条数据添加前缀，输出到控制台。前缀可从 flume配置文件中配置。 </p><p><img src="/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Source/image-20210206160459714.png" alt="image-20210206160459714"></p><h3 id="步骤示意图"><a href="#步骤示意图" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Source/image-20210206155115381.png" alt="image-20210206155115381"></p><ol><li><p>依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flume<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flume-ng-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>自定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> source;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flume.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.EventDeliveryException;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.PollableSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.conf.Configurable;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.event.SimpleEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.source.AbstractSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 家慧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-02-07 11:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySource</span> <span class="keyword">extends</span> <span class="title">AbstractSource</span> <span class="keyword">implements</span> <span class="title">Configurable</span>, <span class="title">PollableSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义全局的前缀&amp;后缀</span></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String subfix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置信息, 给前后缀赋值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-07 12:24:46</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        prefix = context.getString(<span class="string">&quot;prefix&quot;</span>);</span><br><span class="line">        subfix = context.getString(<span class="string">&quot;subfix&quot;</span>, <span class="string">&quot;hjh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.接收数据(for循环造数据)</span></span><br><span class="line"><span class="comment">     * 2.封装为事件</span></span><br><span class="line"><span class="comment">     * 3,将事件传给channel</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-07 12:05:19</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> EventDeliveryException </span>&#123;</span><br><span class="line">        Status status = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 1.接收数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 2.构造事件对象</span></span><br><span class="line">                SimpleEvent event = <span class="keyword">new</span> SimpleEvent();</span><br><span class="line">                <span class="comment">// 3.给事件设置值</span></span><br><span class="line">                event.setBody((prefix+ <span class="string">&quot;--&quot;</span> + i + <span class="string">&quot;--&quot;</span> + subfix).getBytes());</span><br><span class="line">                <span class="comment">// 4.将事件传给channel</span></span><br><span class="line">                getChannelProcessor().processEvent(event);</span><br><span class="line">                status = Status.READY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            status = Status.BACKOFF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getBackOffSleepIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxBackOffSleepInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>打包</p></li><li><p>配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a1.sources.r1.type &#x3D; com.atguigu.MySource </span><br><span class="line">a1.sources.r1.delay &#x3D; 1000 </span><br><span class="line">#a1.sources.r1.field &#x3D; atguigu </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a1.sinks.k1.type &#x3D; logger </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br></pre></td></tr></table></figure></li><li><p>开启</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;flume-ng agent -c conf&#x2F; -f job&#x2F;mysource.conf -n a1 -Dflume.root.logger&#x3D;INFO,console</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flume自定义组件-Source&quot;&gt;&lt;a href=&quot;#Flume自定义组件-Source&quot; class=&quot;headerlink&quot; title=&quot;Flume自定义组件-Source&quot;&gt;&lt;/a&gt;Flume自定义组件-Source&lt;/h1&gt;&lt;h2 id=&quot;自定义So</summary>
      
    
    
    
    <category term="Flume" scheme="https://www.gtxhjh.cn/categories/Flume/"/>
    
    
    <category term="flume" scheme="https://www.gtxhjh.cn/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>Flume自定义拦截器</title>
    <link href="https://www.gtxhjh.cn/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>https://www.gtxhjh.cn/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2021-02-07T07:56:01.000Z</published>
    <updated>2021-02-07T08:00:50.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flume自定义组件-Interceptor"><a href="#Flume自定义组件-Interceptor" class="headerlink" title="Flume自定义组件-Interceptor"></a>Flume自定义组件-Interceptor</h1><h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><h3 id="案例需求"><a href="#案例需求" class="headerlink" title="案例需求"></a>案例需求</h3><blockquote><p>使用Flume采集服务器本地日志，需要安装日志类型的不同，将不同种类的日志发往不同的分析系统</p></blockquote><p>如实际开发中，一台服务器产生的日志类型可能有不同种，不同类型的日志可能需要发送到不同的分析系统，可以用到Flume拓扑结构中的Multiplexing结构(channel选择器)</p><blockquote><p><strong>Multiplexing的原理</strong>：根据event中Header的某个key值，将不同的event发送到不同的channel</p><p>因此需要<strong>自定义一个Interceptor，为不同类型的event的Header中的key赋予不同的值</strong></p></blockquote><p>在该案例中，我们以端口数据模拟日志，以数字（单个）和字母（单个）模拟不同类型的日志，我们需要自定义 interceptor 区分数字和字母，将其分别发往不同的分析系统（Channel）。 </p><h3 id="步骤示意图"><a href="#步骤示意图" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/07/Flume%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/image-20210206141255716.png" alt="image-20210206141255716"></p><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flume<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flume-ng-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>定义拦截器类并实现Interceptor接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hjh.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flume.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.Event;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.interceptor.Interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-02-06 14:37:16</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明一个存放事件的集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Event&gt; addHeaderEvents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-06 14:48:15</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        addHeaderEvents = <span class="keyword">new</span> ArrayList&lt;Event&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个事件拦截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-06 14:47:42 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event 接口,需要实现类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">intercept</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取事件中的头信息</span></span><br><span class="line">        Map&lt;String, String&gt; headers = event.getHeaders();</span><br><span class="line">        <span class="comment">// 2.获取事件中的body信息</span></span><br><span class="line">        String body = <span class="keyword">new</span> String(event.getBody());</span><br><span class="line">        <span class="comment">// 3.根据body总是否有&quot;hello&quot;来决定添加怎样的头信息</span></span><br><span class="line">        <span class="keyword">if</span> (body.contains(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 4.添加头信息</span></span><br><span class="line">            headers.put(<span class="string">&quot;type&quot;</span>,<span class="string">&quot;hjh&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4.添加头信息</span></span><br><span class="line">            headers.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;bigdata&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回事件</span></span><br><span class="line">        <span class="keyword">return</span> event;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量事件拦截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-06 14:50:19</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Event&gt; <span class="title">intercept</span><span class="params">(List&lt;Event&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.清空集合</span></span><br><span class="line">        addHeaderEvents.clear();</span><br><span class="line">        <span class="comment">// 2.遍历events，给每一个事件添加头信息</span></span><br><span class="line">        <span class="keyword">for</span> (Event event : list) &#123;</span><br><span class="line">            <span class="comment">// 3.给每个事件添加头信息</span></span><br><span class="line">            addHeaderEvents.add(intercept(event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.返回结果</span></span><br><span class="line">        <span class="keyword">return</span> addHeaderEvents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-02-06 14:54:16</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 把构造方法私有化</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@date</span> 2021-02-06 14:54:54</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Interceptor <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TypeInterceptor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 配置方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@author</span> hjh</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@date</span> 2021-02-06 14:54:28</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打包，放入集群(flume/lib)</p></li><li><p>配置文件</p><p>为hadoop102上的Flume1配置1个netcat source，1个sink group（2个 avro sink），并配置相应的ChannelSelector和interceptor。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 k2 </span><br><span class="line"># 两个，有选择</span><br><span class="line">a1.channels &#x3D; c1 c2 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a1.sources.r1.type &#x3D; netcat </span><br><span class="line">a1.sources.r1.bind &#x3D; localhost </span><br><span class="line">a1.sources.r1.port &#x3D; 44444 </span><br><span class="line"></span><br><span class="line"># 关键</span><br><span class="line"># 拦截器</span><br><span class="line">a1.sources.r1.interceptors &#x3D; i1 </span><br><span class="line"># 静态内部类</span><br><span class="line">a1.sources.r1.interceptors.i1.type &#x3D; com.hjh.interceptor.TypeInterceptor$Builder </span><br><span class="line"></span><br><span class="line"># channel selector</span><br><span class="line">a1.sources.r1.selector.type &#x3D; multiplexing </span><br><span class="line"># 与header的key对应</span><br><span class="line">a1.sources.r1.selector.header &#x3D; type</span><br><span class="line"># 与header的value对应</span><br><span class="line">a1.sources.r1.selector.mapping.hjh &#x3D; c1 </span><br><span class="line">a1.sources.r1.selector.mapping.bigdata &#x3D; c2 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a1.sinks.k1.type &#x3D; avro </span><br><span class="line">a1.sinks.k1.hostname &#x3D; hadoop103 </span><br><span class="line">a1.sinks.k1.port &#x3D; 4141 </span><br><span class="line"></span><br><span class="line">a1.sinks.k2.type&#x3D;avro </span><br><span class="line">a1.sinks.k2.hostname &#x3D; hadoop104 </span><br><span class="line">a1.sinks.k2.port &#x3D; 4242 </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory </span><br><span class="line">a1.channels.c2.type &#x3D; memory </span><br><span class="line">a1.channels.c2.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c2.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 c2 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br><span class="line">a1.sinks.k2.channel &#x3D; c2 </span><br></pre></td></tr></table></figure><p>为hadoop103上的Flume2配置一个avro source 和一个logger sink。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line">a1.sources.r1.type &#x3D; avro </span><br><span class="line">a1.sources.r1.bind &#x3D; hadoop103 </span><br><span class="line">a1.sources.r1.port &#x3D; 4141 </span><br><span class="line"></span><br><span class="line">a1.sinks.k1.type &#x3D; logger </span><br><span class="line"></span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br></pre></td></tr></table></figure><p>为hadoop104上的Flume3配置一个avro source 和一个logger sink。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line">a1.sources.r1.type &#x3D; avro </span><br><span class="line">a1.sources.r1.bind &#x3D; hadoop104</span><br><span class="line">a1.sources.r1.port &#x3D; 4242</span><br><span class="line"></span><br><span class="line">a1.sinks.k1.type &#x3D; logger </span><br><span class="line"></span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br></pre></td></tr></table></figure></li><li><p>分别在hadoop102，hadoop103，hadoop104上启动 flume进程，注意先后顺序</p></li><li><p>在hadoop102使用 netcat向localhost:44444发送字母和数字。 </p></li><li><p>观察hadoop103和 hadoop104打印的日志</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flume自定义组件-Interceptor&quot;&gt;&lt;a href=&quot;#Flume自定义组件-Interceptor&quot; class=&quot;headerlink&quot; title=&quot;Flume自定义组件-Interceptor&quot;&gt;&lt;/a&gt;Flume自定义组件-Intercept</summary>
      
    
    
    
    <category term="Flume" scheme="https://www.gtxhjh.cn/categories/Flume/"/>
    
    
    <category term="flume" scheme="https://www.gtxhjh.cn/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>第二章 Flume进阶（2）</title>
    <link href="https://www.gtxhjh.cn/2021/02/05/Flume%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89/"/>
    <id>https://www.gtxhjh.cn/2021/02/05/Flume%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89/</id>
    <published>2021-02-05T08:58:34.000Z</published>
    <updated>2021-02-05T09:00:20.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-Flume进阶（2）"><a href="#第二章-Flume进阶（2）" class="headerlink" title="第二章 Flume进阶（2）"></a>第二章 Flume进阶（2）</h1><blockquote><p>下用实例来进行Flume学习</p></blockquote><h2 id="复制和多路复用案例"><a href="#复制和多路复用案例" class="headerlink" title="复制和多路复用案例"></a>复制和多路复用案例</h2><blockquote><p>使用 Flume-1 监控文件变动，Flume-1 将变动内容传递给 Flume-2（Avro Sink），（Avro Source）Flume-2 负责存储到HDFS。同时Flume-1将变动内容传递给Flume-3（Avro Sink），（Avro Source）Flume-3负责输出到Local FileSystem</p></blockquote><h3 id="步骤示意图"><a href="#步骤示意图" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/05/Flume%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89/image-20210205151801258.png" alt="image-20210205151801258"></p><ol><li><p>配置文件</p><p>配置一个接收日志文件的source和两个channel、两个sink，分别输送给flume-flume-hdfs和flume-flume-dir</p><ul><li><p>flume-file-flume.conf </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 k2 </span><br><span class="line">a1.channels &#x3D; c1 c2 </span><br><span class="line"></span><br><span class="line"># 将数据流复制给所有channel</span><br><span class="line">a1.sources.r1.selector.type &#x3D; replicating </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a1.sources.r1.type &#x3D; exec </span><br><span class="line">a1.sources.r1.command &#x3D; tail -F &#x2F;opt&#x2F;module&#x2F;hive&#x2F;logs&#x2F;hive.log a1.sources.r1.shell &#x3D; &#x2F;bin&#x2F;bash -c </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line"># sink端的avro是一个数据发送者</span><br><span class="line">a1.sinks.k1.type &#x3D; avro </span><br><span class="line">a1.sinks.k1.hostname &#x3D; hadoop102 </span><br><span class="line">a1.sinks.k1.port &#x3D; 4141 </span><br><span class="line"></span><br><span class="line">a1.sinks.k2.type &#x3D; avro </span><br><span class="line">a1.sinks.k2.hostname &#x3D; hadoop102 </span><br><span class="line">a1.sinks.k2.port &#x3D; 4142 </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line">a1.channels.c2.type &#x3D; memory </span><br><span class="line">a1.channels.c2.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c2.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 c2 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br><span class="line">a1.sinks.k2.channel &#x3D; c2</span><br></pre></td></tr></table></figure></li><li><p>flume-flume-hdfs.conf</p><p>上级Flume输出到的Source，输出为HDFS的Sink</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a2.sources &#x3D; r1 </span><br><span class="line">a2.sinks &#x3D; k1 </span><br><span class="line">a2.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line"># source端的avro是一个数据接收服务</span><br><span class="line">a2.sources.r1.type &#x3D; avro </span><br><span class="line">a2.sources.r1.bind &#x3D; hadoop102 </span><br><span class="line">a2.sources.r1.port &#x3D; 4141 </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a2.sinks.k1.type &#x3D; hdfs </span><br><span class="line">a2.sinks.k1.hdfs.path &#x3D; hdfs:&#x2F;&#x2F;hadoop102:9000&#x2F;flume2&#x2F;%Y%m%d&#x2F;%H #上传文件的前缀</span><br><span class="line">a2.sinks.k1.hdfs.filePrefix &#x3D; flume2- </span><br><span class="line">#是否按照时间滚动文件夹</span><br><span class="line">a2.sinks.k1.hdfs.round &#x3D; true </span><br><span class="line">#多少时间单位创建一个新的文件夹</span><br><span class="line">a2.sinks.k1.hdfs.roundValue &#x3D; 1 </span><br><span class="line">#重新定义时间单位</span><br><span class="line">a2.sinks.k1.hdfs.roundUnit &#x3D; hour </span><br><span class="line">#是否使用本地时间戳</span><br><span class="line">a2.sinks.k1.hdfs.useLocalTimeStamp &#x3D; true </span><br><span class="line">#积攒多少个Event才flush到HDFS一次</span><br><span class="line">a2.sinks.k1.hdfs.batchSize &#x3D; 100 </span><br><span class="line">#设置文件类型，可支持压缩</span><br><span class="line">a2.sinks.k1.hdfs.fileType &#x3D; DataStream </span><br><span class="line">#多久生成一个新的文件</span><br><span class="line">a2.sinks.k1.hdfs.rollInterval &#x3D; 600 </span><br><span class="line">#设置每个文件的滚动大小大概是128M</span><br><span class="line">a2.sinks.k1.hdfs.rollSize &#x3D; 134217700 </span><br><span class="line">#文件的滚动与Event数量无关</span><br><span class="line">a2.sinks.k1.hdfs.rollCount &#x3D; 0 </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a2.channels.c1.type &#x3D; memory </span><br><span class="line">a2.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a2.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a2.sources.r1.channels &#x3D; c1 </span><br><span class="line">a2.sinks.k1.channel &#x3D; c1 </span><br></pre></td></tr></table></figure></li><li><p>flume-flume-dir.conf</p><p>配置上级Flume输出到的Source，输出为本地目录（需要存在）的Sink</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a3.sources &#x3D; r1 </span><br><span class="line">a3.sinks &#x3D; k1 </span><br><span class="line">a3.channels &#x3D; c2 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a3.sources.r1.type &#x3D; avro </span><br><span class="line">a3.sources.r1.bind &#x3D; hadoop102 </span><br><span class="line">a3.sources.r1.port &#x3D; 4142</span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a3.sinks.k1.type &#x3D; file_roll </span><br><span class="line">a3.sinks.k1.sink.directory &#x3D; &#x2F;opt&#x2F;module&#x2F;data&#x2F;flume3 </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a3.channels.c2.type &#x3D; memory </span><br><span class="line">a3.channels.c2.capacity &#x3D; 1000 </span><br><span class="line">a3.channels.c2.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a3.sources.r1.channels &#x3D; c2 </span><br><span class="line">a3.sinks.k1.channel &#x3D; c2 </span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a3 --conf-file job/group1/flume-flume-dir.conf </span><br><span class="line">bin/flume-ng agent --conf conf/ --name a2 --conf-file job/group1/flume-flume-hdfs.conf </span><br><span class="line">bin/flume-ng agent --conf conf/ --name a1 --conf-file job/group1/flume-file-flume.conf </span><br></pre></td></tr></table></figure></li><li><p>启动Hadoop和Hive</p></li><li><p>检查HDFS数据</p></li></ol><h2 id="负载均衡和故障转移案例"><a href="#负载均衡和故障转移案例" class="headerlink" title="负载均衡和故障转移案例"></a>负载均衡和故障转移案例</h2><blockquote><p>使用 Flume1 监控一个端口，其 sink 组中的 sink 分别对接 Flume2 和 Flume3，采用FailoverSinkProcessor，实现故障转移的功能。</p></blockquote><h3 id="步骤示意图-1"><a href="#步骤示意图-1" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/05/Flume%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89/image-20210205153444280.png" alt="image-20210205153444280"></p><ol><li><p>配置文件</p><ul><li><p>flume-netcat-flume.conf </p><p>配置1个netcat source和 1个 channel、1个sink group（2个sink），分别输送给 flume-flume-console1和flume-flume-console2。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line">a1.sinkgroups &#x3D; g1 </span><br><span class="line">a1.sinks &#x3D; k1 k2 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a1.sources.r1.type &#x3D; netcat </span><br><span class="line">a1.sources.r1.bind &#x3D; localhost </span><br><span class="line">a1.sources.r1.port &#x3D; 44444 </span><br><span class="line"></span><br><span class="line">a1.sinkgroups.g1.processor.type &#x3D; failover a1.sinkgroups.g1.processor.priority.k1 &#x3D; 5 a1.sinkgroups.g1.processor.priority.k2 &#x3D; 10 a1.sinkgroups.g1.processor.maxpenalty &#x3D; 10000 </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a1.sinks.k1.type &#x3D; avro </span><br><span class="line">a1.sinks.k1.hostname &#x3D; hadoop102 </span><br><span class="line">a1.sinks.k1.port &#x3D; 4141</span><br><span class="line"></span><br><span class="line">a1.sinks.k2.type &#x3D; avro </span><br><span class="line">a1.sinks.k2.hostname &#x3D; hadoop102 </span><br><span class="line">a1.sinks.k2.port &#x3D; 4142 </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br><span class="line">a1.sinkgroups.g1.sinks &#x3D; k1 k2 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br><span class="line">a1.sinks.k2.channel &#x3D; c1 </span><br></pre></td></tr></table></figure><blockquote><p>processor.priority：配置优先级</p><p>加入三个Sink，优先级按顺序为k1、k2、k3</p><p>当k1宕机，那么进入失败队列，不再考虑，后选择k2，当k1复活，则与processor.maxpenalty，假如是30s，那么30s之内复活则不考虑</p></blockquote><p>如果使用<strong>负载均衡</strong>，改动如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a1.sinkgroups.g1.processor.type &#x3D; load_balance </span><br><span class="line">a1.sinkgroups.g1.processor.backoff &#x3D; true</span><br><span class="line">a1.sinkgroups.g1.processor.selector &#x3D; random</span><br></pre></td></tr></table></figure></li><li><p>flume-flume-console1.conf </p><p>配置上级Flume输出的 Source，输出是到本地控制台。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a2.sources &#x3D; r1 </span><br><span class="line">a2.sinks &#x3D; k1 </span><br><span class="line">a2.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a2.sources.r1.type &#x3D; avro </span><br><span class="line">a2.sources.r1.bind &#x3D; hadoop102 </span><br><span class="line">a2.sources.r1.port &#x3D; 4141 </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a2.sinks.k1.type &#x3D; logger </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a2.channels.c1.type &#x3D; memory </span><br><span class="line">a2.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a2.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a2.sources.r1.channels &#x3D; c1 </span><br><span class="line">a2.sinks.k1.channel &#x3D; c1 </span><br></pre></td></tr></table></figure></li><li><p>flume-flume-console2.conf </p><p>配置上级Flume输出的 Source，输出是到本地控制台。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a3.sources &#x3D; r1 </span><br><span class="line">a3.sinks &#x3D; k1 </span><br><span class="line">a3.channels &#x3D; c2 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a3.sources.r1.type &#x3D; avro </span><br><span class="line">a3.sources.r1.bind &#x3D; hadoop102 </span><br><span class="line">a3.sources.r1.port &#x3D; 4142 </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a3.sinks.k1.type &#x3D; logger </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a3.channels.c2.type &#x3D; memory </span><br><span class="line">a3.channels.c2.capacity &#x3D; 1000 </span><br><span class="line">a3.channels.c2.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a3.sources.r1.channels &#x3D; c2 </span><br><span class="line">a3.sinks.k1.channel &#x3D; c2 </span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a3 --conf-file job/group2/flume-flume-console2.conf -Dflume.root.logger=INFO,console </span><br><span class="line">bin/flume-ng agent --conf conf/ --name a2 --conf-file job/group2/flume-flume-console1.conf -Dflume.root.logger=INFO,console </span><br><span class="line">bin/flume-ng agent --conf conf/ --name a1 --conf-file job/group2/flume-netcat-flume.conf </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>向本机44444端口发送内容</p></li><li><p>查看控制台打印日志</p></li><li><p>kill Flume2，观察Flume3打印情况</p><blockquote><p>注：使用jps -ml查看Flume进程。 </p></blockquote></li></ol><h2 id="聚合案例"><a href="#聚合案例" class="headerlink" title="聚合案例"></a>聚合案例</h2><blockquote><p>hadoop102上的Flume-1监控文件/opt/module/data/group.log，<br>hadoop103上的Flume-2监控某一个端口的数据流，<br>Flume-1 与 Flume-2 将数据发送给 hadoop104 上的 Flume-3，Flume-3 将最终数据打印到控制台。</p></blockquote><h3 id="步骤示意图-2"><a href="#步骤示意图-2" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/05/Flume%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89/image-20210205163825594.png" alt="image-20210205163825594"></p><ol><li><p>配置文件</p><ol><li><p>flume1-logger-flume.conf</p><p>配置Source用于监控 hive.log文件，配置Sink输出数据到下一级Flume。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a1.sources.r1.type &#x3D; exec </span><br><span class="line">a1.sources.r1.command &#x3D; tail -F &#x2F;opt&#x2F;module&#x2F;group.log a1.sources.r1.shell &#x3D; &#x2F;bin&#x2F;bash -c </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a1.sinks.k1.type &#x3D; avro </span><br><span class="line">a1.sinks.k1.hostname &#x3D; hadoop104 </span><br><span class="line">a1.sinks.k1.port &#x3D; 4141 </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>flume2-netcat-flume.conf</p><p>配置Source监控端口 44444数据流，配置Sink数据到下一级Flume： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a2.sources &#x3D; r1 </span><br><span class="line">a2.sinks &#x3D; k1 </span><br><span class="line">a2.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a2.sources.r1.type &#x3D; netcat </span><br><span class="line">a2.sources.r1.bind &#x3D; hadoop103 </span><br><span class="line">a2.sources.r1.port &#x3D; 44444 </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a2.sinks.k1.type &#x3D; avro </span><br><span class="line">a2.sinks.k1.hostname &#x3D; hadoop104 </span><br><span class="line">a2.sinks.k1.port &#x3D; 4141 </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory </span><br><span class="line">a2.channels.c1.type &#x3D; memory </span><br><span class="line">a2.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a2.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a2.sources.r1.channels &#x3D; c1 </span><br><span class="line">a2.sinks.k1.channel &#x3D; c1 </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>flume3-flume-logger.conf</p><p>配置source用于接收 flume1与flume2发送过来的数据流，最终合并后sink到控制台。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a3.sources &#x3D; r1 </span><br><span class="line">a3.sinks &#x3D; k1 </span><br><span class="line">a3.channels &#x3D; c1 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a3.sources.r1.type &#x3D; avro </span><br><span class="line">a3.sources.r1.bind &#x3D; hadoop104 </span><br><span class="line">a3.sources.r1.port &#x3D; 4141</span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line"># Describe the sink </span><br><span class="line">a3.sinks.k1.type &#x3D; logger </span><br><span class="line"></span><br><span class="line"># Describe the channel </span><br><span class="line">a3.channels.c1.type &#x3D; memory </span><br><span class="line">a3.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a3.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a3.sources.r1.channels &#x3D; c1 </span><br><span class="line">a3.sinks.k1.channel &#x3D; c1 </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a3 --conf-file job/group3/flume3-flume-logger.conf -Dflume.root.logger=INFO,console </span><br><span class="line">bin/flume-ng agent --conf conf/ --name a2 --conf-file job/group3/flume1-logger-flume.conf </span><br><span class="line">bin/flume-ng agent --conf conf/ --name a1 --conf-file job/group3/flume2-netcat-flume.conf </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在hadoop103上向/opt/module目录下的group.log追加内容 </p></li><li><p>在hadoop102上向44444端口发送数据 </p></li><li><p>检查hadoop104上数据</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-Flume进阶（2）&quot;&gt;&lt;a href=&quot;#第二章-Flume进阶（2）&quot; class=&quot;headerlink&quot; title=&quot;第二章 Flume进阶（2）&quot;&gt;&lt;/a&gt;第二章 Flume进阶（2）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;下用实例来进行Fl</summary>
      
    
    
    
    <category term="Flume" scheme="https://www.gtxhjh.cn/categories/Flume/"/>
    
    
    <category term="flume" scheme="https://www.gtxhjh.cn/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>第二章 Flume进阶（1）</title>
    <link href="https://www.gtxhjh.cn/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/"/>
    <id>https://www.gtxhjh.cn/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/</id>
    <published>2021-02-04T10:00:52.000Z</published>
    <updated>2021-02-10T14:13:23.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-Flume进阶（1）"><a href="#第二章-Flume进阶（1）" class="headerlink" title="第二章 Flume进阶（1）"></a>第二章 Flume进阶（1）</h1><h2 id="Flume事务"><a href="#Flume事务" class="headerlink" title="Flume事务"></a>Flume事务</h2><p><img src="/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/image-20210204170214688.png" alt="image-20210204170214688"></p><blockquote><p>Channel是<strong>被动型</strong>的，事务主动推送事件，而输出端主动拉取事件</p></blockquote><h2 id="Flume-Agent内部原理"><a href="#Flume-Agent内部原理" class="headerlink" title="Flume Agent内部原理"></a>Flume Agent内部原理</h2><p><img src="/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/image-20210204172300521.png" alt="image-20210204172300521"></p><blockquote><p>拦截器可以配置多个，更灵活</p><p>source可以绑定多个channel，由channel选择器来选择绑定的channel，同时可以设置选择策略</p><ul><li>ChannelSelector</li></ul><p>ChannelSelector 的作用就是选出 Event将要被发往哪个 Channel。其共有两种类型，分别是Replicating（复制）和 Multiplexing（多路复用）</p><blockquote><p>ReplicatingSelector（默认） 会将同一个Event发往<strong>所有的</strong> Channel</p><p>Multiplexing 会根据<strong>相应的原则</strong>，将不同的 Event发往不同的Channel</p><p>如：</p><p>![image-20210208134618032](第二章 Flume进阶（1）.assets/image-20210208134618032.png)</p></blockquote><p>put事务就在第六步</p><p>channel可以绑定多个sink，具体给哪个sink由sink组决定</p><ul><li>SinkProcessor</li></ul><p>SinkProcessor 共 有 三 种 类 型 ， 分 别 是 DefaultSinkProcessor 、LoadBalancingSinkProcessor 和FailoverSinkProcessor </p><blockquote><p><strong>DefaultSinkProcessor</strong> 对应的是单个的 Sink</p><p>LoadBalancingSinkProcessor 和FailoverSinkProcessor 对应的是 Sink Group</p><ol><li><strong>LoadBalancingSinkProcessor</strong> 可以实现负载均衡的功能</li><li><strong>FailoverSinkProcessor</strong>可以实现故障转移的功能</li></ol></blockquote></blockquote><h2 id="Flume拓扑结构"><a href="#Flume拓扑结构" class="headerlink" title="Flume拓扑结构"></a>Flume拓扑结构</h2><h3 id="简单串联"><a href="#简单串联" class="headerlink" title="简单串联"></a>简单串联</h3><p><img src="/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/image-20210204174330299.png" alt="image-20210204174330299"></p><ul><li><p>将多个 flume (Agent)顺序连接起来了，从最初的 source 开始到最终 sink 传送的目的存储系统</p><blockquote><p>可同一台机器也可跨机器。跨机器时flume不能跨机器读磁盘，需要网络通信读取使用Sink-&gt;RPC-&gt;Source串起来</p></blockquote></li><li><p>此模式不建议桥接过多的flume数量，flume数量过多不仅<strong>会影响传输速率</strong>，而且一旦传输过程中某个节点 flume宕机，会影响整个传输系统</p></li></ul><h3 id="复制和多路复用"><a href="#复制和多路复用" class="headerlink" title="复制和多路复用"></a>复制和多路复用</h3><p><img src="/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/image-20210204174352601.png" alt="image-20210204174352601"></p><blockquote><p>单source，多channel、sink</p></blockquote><p>Flume 支持将事件流向一个或者多个目的地。这种模式可以将相同数据复制到多个channel 中，或者将不同数据分发到不同的 channel 中，sink 可以选择传送到不同的目的地。 </p><h3 id="负载均衡和故障转移"><a href="#负载均衡和故障转移" class="headerlink" title="负载均衡和故障转移"></a>负载均衡和故障转移</h3><p><img src="/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/image-20210204174418127.png" alt="image-20210204174418127"></p><blockquote><p>一个Channel多个Sink，<strong>Sink组应用</strong></p></blockquote><p>Flume支持使用将多个sink逻辑上分到一个sink组，sink组<em>配合不同的SinkProcessor</em>可以实现负载均衡和错误恢复的功能</p><ul><li>解决单个进程压力过大问题同时可以故障转移</li></ul><blockquote><p>单个Sink压力大，三个Sink轮询的方式发到三个不同的Agent，让不同的Agent写HDFS，同时3个Channel可以缓存更多</p></blockquote><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><img src="/2021/02/04/Flume%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/image-20210204174431094.png" alt="image-20210204174431094"></p><blockquote><p>多个源头Source</p></blockquote><p>最常见的，也非常实用的模式，日常 web应用通常分布在上百个服务器，大者甚至上千个、上万个服务器，产生的日志，处理起来也非常麻烦。用 flume的这种组合方式能很好的解决这一问题。</p><blockquote><p><strong>每台服务器部署一个flume</strong> 采集日志，<strong>传送到一个集中收集日志的flume</strong>，再由此flume 上传到hdfs、hive、hbase 等，进行日志分析</p><ul><li>聚合到一台压力过大，也可以采用上个模式，降低压力</li><li>另外，一种汇总方式是每个Sink发送到<strong>同个端口</strong>，另一种是发送到<strong>不同端口</strong>，那么就有3个source来接收而这三个source绑定一个channel，也是一种聚合</li></ul><p><strong>后台多个服务器解决同一个业务，但是任何一台不可能同时处理用户多个请求，需要负载均衡，用户的请求到底给谁处理，即负载均衡。如软件层的负载均衡Nginx，轮询的发送用户请求</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-Flume进阶（1）&quot;&gt;&lt;a href=&quot;#第二章-Flume进阶（1）&quot; class=&quot;headerlink&quot; title=&quot;第二章 Flume进阶（1）&quot;&gt;&lt;/a&gt;第二章 Flume进阶（1）&lt;/h1&gt;&lt;h2 id=&quot;Flume事务&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Flume" scheme="https://www.gtxhjh.cn/categories/Flume/"/>
    
    
    <category term="flume" scheme="https://www.gtxhjh.cn/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>第一章 Flume概述</title>
    <link href="https://www.gtxhjh.cn/2021/02/04/Flume%E6%A6%82%E8%BF%B0/"/>
    <id>https://www.gtxhjh.cn/2021/02/04/Flume%E6%A6%82%E8%BF%B0/</id>
    <published>2021-02-04T10:00:19.000Z</published>
    <updated>2021-02-04T10:05:08.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-Flume概述"><a href="#第一章-Flume概述" class="headerlink" title="第一章 Flume概述"></a>第一章 Flume概述</h1><blockquote><p>Flume 是Cloudera 提供的一个高可用的，高可靠的，分布式的海量**==日志数据==采集、聚合和传输的系统**（即文本文件，图片不行）</p><p>Flume 基于流式架构，灵活简单</p></blockquote><p><img src="/2021/02/04/Flume%E6%A6%82%E8%BF%B0/image-20210204125745058-1612416154240.png" alt="image-20210204125745058"></p><p>Flume最主要的作用：**==实时==读取服务器本地磁盘的数据，将数据写入到HDFS**</p><h2 id="Flume基础架构"><a href="#Flume基础架构" class="headerlink" title="Flume基础架构"></a>Flume基础架构</h2><p><img src="/2021/02/04/Flume%E6%A6%82%E8%BF%B0/image-20210204130430497-1612416151397.png" alt="image-20210204130430497"></p><blockquote><p>方框中才是主要的Flume组件</p></blockquote><ul><li><p>Agent</p><ol><li>一个JVM进程，以<strong>事件</strong>的形式将数据从源头送至目的</li><li>主要有 3个部分组成：Source 、Channel、Sink </li></ol></li><li><p>Source（读）</p><ol><li><p>Source负责接收数据到Flume Agent的组件</p><blockquote><p>Source组件可以处理各种类型、各种格式的日志数据，包括avro、thrift、exec、jms、spooling directory、netcat、sequence generator、syslog、http、legacy </p></blockquote><p><strong>举例：</strong></p><p>Avro Source：单点故障时，希望对接另一个Flume用到，两个Flume通信，<strong>轻量RPC通道</strong></p><p>Exec Source：命令行监控</p><p>Taildir Source：监控多个目录变化的数据，监控本地文件会用到</p><p>Kafka Source：从Kafka读</p><p>NetCat</p></li></ol></li><li><p>Channel（<strong>缓冲</strong>）</p><p>Channel是位于Source 和Sink 之间的**==缓冲区==<strong>，因此，Channel允许Source 和Sink</strong>运作在不同的速率**上</p><blockquote><p>Channel 是线程安全的，可以同时处理几个 Source 的写入操作和几个Sink的读取操作</p></blockquote><p>Flume自带两种Channel：<strong>Memory Channel和 File Channel以及Kafka Channel</strong></p><ol><li>Memory Channel是<strong>内存中的队列</strong>。Memory Channel在不需要关心数据丢失的情景下适用。如果需要关心数据丢失，那么 Memory Channel就不应该使用，因为程序死亡、机器宕机或者重启都会导致数据丢失（容易坏）</li><li>File Channel 将所有事件写到磁盘。因此在程序关闭或机器宕机的情况下不会丢失数据，（但是慢）</li></ol></li><li><p>Sink（写）</p><p>Sink 不断地<em>轮询 Channel 中的事件且批量地移除它们</em>，并将这些事件<strong>批量写入到存储或索引系统、或者被发送到另一个 Flume Agent</strong></p><blockquote><p>Sink 组件目的地包括 hdfs、hive、logger、avro（avro sink到avro source）、thrift、ipc、file、HBase、solr、自定义 </p></blockquote></li><li><p>Event</p><p>传输单元，<strong>Flume 数据传输的基本单元</strong>，以 Event 的形式将数据从源头送至目的地（封装）</p><p>Event由<strong>Header</strong>和**==Body==**两部分组成</p><ul><li>Header用来存放该 event的一些<strong>属性</strong>，为 <strong>K-V结构</strong></li><li>Body用来存放该条数据，形式为<strong>字节数组</strong></li></ul><p><img src="/2021/02/04/Flume%E6%A6%82%E8%BF%B0/image-20210204132154832.png" alt="image-20210204132154832"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-Flume概述&quot;&gt;&lt;a href=&quot;#第一章-Flume概述&quot; class=&quot;headerlink&quot; title=&quot;第一章 Flume概述&quot;&gt;&lt;/a&gt;第一章 Flume概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Flume 是Cloudera 提供的一个</summary>
      
    
    
    
    <category term="Flume" scheme="https://www.gtxhjh.cn/categories/Flume/"/>
    
    
    <category term="flume" scheme="https://www.gtxhjh.cn/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>Flume部署</title>
    <link href="https://www.gtxhjh.cn/2021/02/04/Flume%E9%83%A8%E7%BD%B2/"/>
    <id>https://www.gtxhjh.cn/2021/02/04/Flume%E9%83%A8%E7%BD%B2/</id>
    <published>2021-02-04T10:00:08.000Z</published>
    <updated>2021-02-04T10:04:13.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flume部署"><a href="#Flume部署" class="headerlink" title="Flume部署"></a>Flume部署</h1><ol><li><p>flume启动只需要启动agent即可</p></li><li><p>配置conf，有官方案例，配置source、sink、channel的，案例分析如下</p><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204135115408.png" alt="image-20210204135115408"></p><blockquote><p>复数s表示可多个</p><p>前面为变量声明后面为赋值</p><p>channels和channel说明：source可以绑定多个channel，而sink只能绑定一个channel，但是一个channel可以绑定多个sink</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent   </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 </span><br><span class="line">a1.channels &#x3D; c1 </span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a1.sources.r1.type &#x3D; netcat </span><br><span class="line">a1.sources.r1.bind &#x3D; localhost </span><br><span class="line">a1.sources.r1.port &#x3D; 44444 </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a1.sinks.k1.type &#x3D; logger </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br></pre></td></tr></table></figure></li><li><p>开启Flume监听端口</p><p>法1：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a1 --conf-file job/flume-netcat-logger.conf -Dflume.root.logger=INFO,console </span><br></pre></td></tr></table></figure><p>法2：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent -c conf/ -n a1 -f job/flume-netcat-logger.conf -Dflume.root.logger=INFO,console </span><br></pre></td></tr></table></figure><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204135914136.png" alt="image-20210204135914136"></p><p>开启了一个服务端</p><p>再开启一个客户端发送消息</p><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204140530296.png" alt="image-20210204140530296"></p><p>服务端接收到</p><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204140459986.png" alt="image-20210204140459986"></p></li></ol><h2 id="监控单个追加文件"><a href="#监控单个追加文件" class="headerlink" title="监控单个追加文件"></a>监控单个追加文件</h2><blockquote><p>实时监控Hive日志，并上传到HDFS中</p></blockquote><h3 id="步骤示意图"><a href="#步骤示意图" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204141239468.png" alt="image-20210204141239468"></p><ol><li><p>Flume要想将数据输出到HDFS，须持有Hadoop相关jar包 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commons-configuration-1.6.jar、 </span><br><span class="line">hadoop-auth-2.7.2.jar、</span><br><span class="line">hadoop-common-2.7.2.jar、 </span><br><span class="line">hadoop-hdfs-2.7.2.jar、 </span><br><span class="line">commons-io-2.4.jar、</span><br><span class="line">htrace-core-3.1.0-incubating.jar </span><br></pre></td></tr></table></figure><p>拷贝到/opt/module/flume/lib文件夹下</p></li><li><p>创建flume-file-hdfs.conf配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent </span><br><span class="line">a1.sources &#x3D; r1 </span><br><span class="line">a1.sinks &#x3D; k1 </span><br><span class="line">a1.channels &#x3D; c1</span><br><span class="line"></span><br><span class="line"># Describe the source</span><br><span class="line">a1.sources.r1.type &#x3D; exec</span><br><span class="line">a1.sources.r1.command &#x3D; tail -F &#x2F;opt&#x2F;module&#x2F;hive&#x2F;logs&#x2F;hive.log</span><br><span class="line"># 执行shell脚本的绝对路径</span><br><span class="line">a1.sources.r1.shell &#x3D; &#x2F;bin&#x2F;bash -c </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a1.sinks.k1.type &#x3D; hdfs</span><br><span class="line"># 路径用了年月日加小时</span><br><span class="line">a1.sink.k1.hdfs.path &#x3D;  hdfs:&#x2F;&#x2F;hadoop102:9000&#x2F;flume&#x2F;%Y%m%d&#x2F;%H</span><br><span class="line"># 上传文件的前缀</span><br><span class="line">a1.sinks.k1.hdfs.filePrefix &#x3D; logs- </span><br><span class="line"></span><br><span class="line"># 是否按照时间滚动文件夹</span><br><span class="line">a1.sinks.k1.hdfs.round &#x3D; true </span><br><span class="line"># 多少时间单位创建一个新的文件夹</span><br><span class="line">a1.sinks.k1.hdfs.roundValue &#x3D; 1 </span><br><span class="line"># 重新定义时间单位</span><br><span class="line">a1.sinks.k1.hdfs.roundUnit &#x3D; hour </span><br><span class="line"></span><br><span class="line"># 是否使用本地时间戳</span><br><span class="line">a1.sinks.k1.hdfs.useLocalTimeStamp &#x3D; true </span><br><span class="line"></span><br><span class="line"># 积攒多少个Event才flush到HDFS一次,看容量，到时间也会刷新不一定到容量</span><br><span class="line">a1.sinks.k1.hdfs.batchSize &#x3D; 1000 </span><br><span class="line"># 设置文件类型，可支持压缩,LZO也可</span><br><span class="line">a1.sinks.k1.hdfs.fileType &#x3D; DataStream </span><br><span class="line"></span><br><span class="line"># 多久生成一个新的文件</span><br><span class="line">a1.sinks.k1.hdfs.rollInterval &#x3D; 30 </span><br><span class="line"># 设置每个文件的滚动大小</span><br><span class="line">a1.sinks.k1.hdfs.rollSize &#x3D; 134217700 </span><br><span class="line"># 文件的滚动与Event数量无关</span><br><span class="line">a1.sinks.k1.hdfs.rollCount &#x3D; 0</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory </span><br><span class="line">a1.channels.c1.type &#x3D; memory </span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000 </span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel </span><br><span class="line">a1.sources.r1.channels &#x3D; c1 </span><br><span class="line">a1.sinks.k1.channel &#x3D; c1 </span><br></pre></td></tr></table></figure><blockquote><p>对于所有与时间相关的转义序列，Event Header中必须存在以 “timestamp”的 key（除非hdfs.useLocalTimeStamp 设置为 true，此方法会使用 TimestampInterceptor 自动添加timestamp）</p></blockquote><p>由于 Hive 日志在 Linux 系统中所以读取文件的类型选择：exec 即 execute 执行的意思。表示执行 Linux命令来读取文件。 </p></li><li><p>运行Flume</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a2 --conf-file job/flume-file-hdfs.conf</span><br></pre></td></tr></table></figure></li><li><p>开启Hadoop和Hive并操作Hive产生日志 </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br><span class="line">sbin/start-yarn.sh</span><br><span class="line">bin/hive</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt;</span><br></pre></td></tr></table></figure></li><li><p>在HDFS上查看文件</p><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204151706518.png" alt="image-20210204151706518"></p></li></ol><h2 id="监控目录下多个新文件"><a href="#监控目录下多个新文件" class="headerlink" title="监控目录下多个新文件"></a>监控目录下多个新文件</h2><blockquote><p>使用Flume监听整个目录的文件，并上传至HDFS</p></blockquote><h3 id="步骤示意图-1"><a href="#步骤示意图-1" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204152209228.png" alt="image-20210204152209228"></p><ol><li><p>配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a3.sources &#x3D; r3 </span><br><span class="line">a3.sinks &#x3D; k3 </span><br><span class="line">a3.channels &#x3D; c3 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a3.sources.r3.type &#x3D; spooldir </span><br><span class="line">a3.sources.r3.spoolDir &#x3D; &#x2F;opt&#x2F;module&#x2F;flume&#x2F;upload </span><br><span class="line"></span><br><span class="line">a3.sources.r3.fileSuffix &#x3D; .COMPLETED </span><br><span class="line">a3.sources.r3.fileHeader &#x3D; true </span><br><span class="line">#忽略所有以.tmp结尾的文件，不上传</span><br><span class="line">a3.sources.r3.ignorePattern &#x3D; ([^ ]*\.tmp) </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a3.sinks.k3.type &#x3D; hdfs </span><br><span class="line">a3.sinks.k3.hdfs.path </span><br><span class="line">hdfs:&#x2F;&#x2F;hadoop102:9000&#x2F;flume&#x2F;upload&#x2F;%Y%m%d&#x2F;%H #上传文件的前缀</span><br><span class="line">a3.sinks.k3.hdfs.filePrefix &#x3D; upload- </span><br><span class="line">#是否按照时间滚动文件夹</span><br><span class="line">a3.sinks.k3.hdfs.round &#x3D; true </span><br><span class="line">#多少时间单位创建一个新的文件夹</span><br><span class="line">a3.sinks.k3.hdfs.roundValue &#x3D; 1 </span><br><span class="line">#重新定义时间单位</span><br><span class="line">a3.sinks.k3.hdfs.roundUnit &#x3D; hour </span><br><span class="line">#是否使用本地时间戳</span><br><span class="line">a3.sinks.k3.hdfs.useLocalTimeStamp &#x3D; true </span><br><span class="line">#积攒多少个Event才flush到HDFS一次</span><br><span class="line">a3.sinks.k3.hdfs.batchSize &#x3D; 100 </span><br><span class="line"></span><br><span class="line">#设置文件类型，可支持压缩</span><br><span class="line">a3.sinks.k3.hdfs.fileType &#x3D; DataStream </span><br><span class="line">#多久生成一个新的文件</span><br><span class="line">a3.sinks.k3.hdfs.rollInterval &#x3D; 60 </span><br><span class="line">#设置每个文件的滚动大小大概是128M</span><br><span class="line">a3.sinks.k3.hdfs.rollSize &#x3D; 134217700 </span><br><span class="line">#文件的滚动与Event数量无关</span><br><span class="line">a3.sinks.k3.hdfs.rollCount &#x3D; 0 </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory a3.channels.c3.type &#x3D; memory </span><br><span class="line">a3.channels.c3.capacity &#x3D; 1000 </span><br><span class="line">a3.channels.c3.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel a3.sources.r3.channels &#x3D; c3 </span><br><span class="line">a3.sinks.k3.channel &#x3D; c3 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204152409837.png" alt="image-20210204152409837"></p><blockquote><p>文件后缀表示添加给完成的文件后缀.COMPLETED，因为要不断观察文件，作监控，上传一个文件后添加后缀，下次在看到该后缀则不上传</p></blockquote></li><li><p>启动监控文件夹命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a3 --conf-file job/flume-dir-hdfs.conf </span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：在使用Spooling Directory Source 时</p><ul><li><p>不要在监控目录中创建并持续修改文件（<strong>不可监控动态变化即追加文件</strong>）</p></li><li><p>上传完成的文件会以**.COMPLETED结尾**</p></li><li><p>被监控文件夹<strong>每500毫秒扫描一次文件变动</strong> </p></li></ul></blockquote></li><li><p>向upload文件夹中添加文件</p></li><li><p>查看HDFS上的数据</p></li><li><p>等待1s，再次查询upload文件夹</p></li></ol><h2 id="监控目录下多个追加文件"><a href="#监控目录下多个追加文件" class="headerlink" title="监控目录下多个追加文件"></a>监控目录下多个追加文件</h2><blockquote><p>Exec source 适用于监控一个实时追加的文件，但不能保证数据不丢失</p><p>Spooldir Source能够保证数据不丢失，且能够实现断点续传，但延迟较高，不能实时监控</p><p>而Taildir Source既能够实现断点续传，又可以保证数据不丢失，还能够进行实时监控。 </p></blockquote><blockquote><p>用Flume监听整个目录的实时追加文件，并上传至HDFS</p></blockquote><h3 id="步骤示意图-2"><a href="#步骤示意图-2" class="headerlink" title="步骤示意图"></a>步骤示意图</h3><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204155954745.png" alt="image-20210204155954745"></p><ol><li><p>配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a3.sources &#x3D; r3 </span><br><span class="line">a3.sinks &#x3D; k3 </span><br><span class="line">a3.channels &#x3D; c3 </span><br><span class="line"></span><br><span class="line"># Describe&#x2F;configure the source </span><br><span class="line">a3.sources.r3.type &#x3D; TAILDIR </span><br><span class="line">a3.sources.r3.positionFile &#x3D; &#x2F;opt&#x2F;module&#x2F;flume&#x2F;tail_dir.json a3.sources.r3.filegroups &#x3D; f1 </span><br><span class="line">a3.sources.r3.filegroups.f1 &#x3D; &#x2F;opt&#x2F;module&#x2F;flume&#x2F;files&#x2F;file.* </span><br><span class="line"></span><br><span class="line"># Describe the sink </span><br><span class="line">a3.sinks.k3.type &#x3D; hdfs </span><br><span class="line">a3.sinks.k3.hdfs.path </span><br><span class="line">hdfs:&#x2F;&#x2F;hadoop102:9000&#x2F;flume&#x2F;upload&#x2F;%Y%m%d&#x2F;%H #上传文件的前缀</span><br><span class="line">a3.sinks.k3.hdfs.filePrefix &#x3D; upload- </span><br><span class="line">#是否按照时间滚动文件夹</span><br><span class="line">a3.sinks.k3.hdfs.round &#x3D; true </span><br><span class="line">#多少时间单位创建一个新的文件夹</span><br><span class="line">a3.sinks.k3.hdfs.roundValue &#x3D; 1 </span><br><span class="line">#重新定义时间单位</span><br><span class="line">a3.sinks.k3.hdfs.roundUnit &#x3D; hour </span><br><span class="line">#是否使用本地时间戳</span><br><span class="line">a3.sinks.k3.hdfs.useLocalTimeStamp &#x3D; true </span><br><span class="line">#积攒多少个Event才flush到HDFS一次</span><br><span class="line">a3.sinks.k3.hdfs.batchSize &#x3D; 100 </span><br><span class="line">#设置文件类型，可支持压缩</span><br><span class="line">a3.sinks.k3.hdfs.fileType &#x3D; DataStream </span><br><span class="line">#多久生成一个新的文件</span><br><span class="line">a3.sinks.k3.hdfs.rollInterval &#x3D; 60 </span><br><span class="line">#设置每个文件的滚动大小大概是128M</span><br><span class="line">a3.sinks.k3.hdfs.rollSize &#x3D; 134217700 </span><br><span class="line">#文件的滚动与Event数量无关</span><br><span class="line">a3.sinks.k3.hdfs.rollCount &#x3D; 0 </span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory a3.channels.c3.type &#x3D; memory </span><br><span class="line">a3.channels.c3.capacity &#x3D; 1000 </span><br><span class="line">a3.channels.c3.transactionCapacity &#x3D; 100 </span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel a3.sources.r3.channels &#x3D; c3 </span><br><span class="line">a3.sinks.k3.channel &#x3D; c3 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/02/04/Flume%E9%83%A8%E7%BD%B2/image-20210204160221739.png" alt="image-20210204160221739"></p><blockquote><p>positionFile：json文件</p><p>Taildir说明：</p><p>Taildir Source 维护了一个json格式的position File，其会定期的往 position File中更新每个文件读取到的最新的位置，因此能够实现断点续传。Position File的格式如下： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;inode&quot;:2496272,&quot;pos&quot;:12,&quot;file&quot;:&quot;&#x2F;opt&#x2F;module&#x2F;flume&#x2F;files&#x2F;file1.t xt&quot;&#125; </span><br><span class="line">&#123;&quot;inode&quot;:2496275,&quot;pos&quot;:12,&quot;file&quot;:&quot;&#x2F;opt&#x2F;module&#x2F;flume&#x2F;files&#x2F;file2.t xt&quot;&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：Linux 中储存文件元数据的区域就叫做inode，每个inode 都有一个号码，操作系统用 inode 号码来识别不同的文件，Unix/Linux 系统内部不使用文件名，而使用 inode 号码来识别文件</p></blockquote></li><li><p>启动监控文件夹命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a3 --conf-file job/flume-taildir-hdfs.conf </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>向files文件夹中追加内容</p></li><li><p>向upload文件夹中添加文件 </p></li><li><p>查看HDFS上的数据</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flume部署&quot;&gt;&lt;a href=&quot;#Flume部署&quot; class=&quot;headerlink&quot; title=&quot;Flume部署&quot;&gt;&lt;/a&gt;Flume部署&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;flume启动只需要启动agent即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置co</summary>
      
    
    
    
    <category term="Flume" scheme="https://www.gtxhjh.cn/categories/Flume/"/>
    
    
    <category term="flume" scheme="https://www.gtxhjh.cn/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>命令行在任意目录下启动任意脚本方法</title>
    <link href="https://www.gtxhjh.cn/2021/02/03/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9C%A8%E4%BB%BB%E6%84%8F%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%90%AF%E5%8A%A8%E4%BB%BB%E6%84%8F%E8%84%9A%E6%9C%AC%E6%96%B9%E6%B3%95/"/>
    <id>https://www.gtxhjh.cn/2021/02/03/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9C%A8%E4%BB%BB%E6%84%8F%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%90%AF%E5%8A%A8%E4%BB%BB%E6%84%8F%E8%84%9A%E6%9C%AC%E6%96%B9%E6%B3%95/</id>
    <published>2021-02-03T08:11:35.000Z</published>
    <updated>2021-02-03T08:45:36.648Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天在执行.sh脚本文件时，发现必须在脚本所在的路径下才可执行，找到方法可以在任意目录下启动脚本，在此记录</p><p>[<a href="https://blog.csdn.net/qq_16633405/article/details/82056619]">https://blog.csdn.net/qq_16633405/article/details/82056619]</a>: </p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>简单说PATH就是一组路径的字符串变量，当你输入的命令不带任何路径时，LINUX会在PATH记录的路径中查找该命令。有的话则执行，<strong>不存在则提示命令找不到</strong>，也就是我们经常看到的<code>-bash: ***: command not found</code>。比如在根目录/下可以输入命令ls,在/usr目录下也可以输入ls,但其实ls命令根本不在这个两个目录下，当你输入ls命令时LINUX会去/bin,/usr/bin,/sbin等目录寻找该命令。而PATH就是定义/bin:/sbin:/usr/bin等这些路径的变量，其中冒号为目录间的分割符。使用<code>export $PATH</code>命令可以查看环境变量的内容。<br>那么如何自定义一个路径呢</p><hr><p>修改环境变量PATH， 给PATH增加一个值/usr/local/apache/bin </p><h2 id="Linux环境变量"><a href="#Linux环境变量" class="headerlink" title="Linux环境变量"></a>Linux环境变量</h2><p><strong>注意：</strong></p><ul><li>登录式Shell，采用用户名比如XXXX登录，会自动加载/etc/profile</li><li>非登录式Shell，采用ssh 比如ssh XXXX登录，不会自动加载/etc/profile，会自动加载~/.bashrc</li></ul><p>首先查看~/.bashrc</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> rm=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> cp=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> mv=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; <span class="keyword">then</span></span><br><span class="line">        . /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><blockquote><p>加载该文件，会加载/etc/bashrc文件，因此继续查看/etc/bashrc，下拉文件底部，可以看到下代码</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -r <span class="string">&quot;<span class="variable">$i</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$PS1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        . <span class="string">&quot;<span class="variable">$i</span>&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        . <span class="string">&quot;<span class="variable">$i</span>&quot;</span> &gt;/dev/null</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>该语句表示其会加载/etc/profile.d中所有.sh后缀的文件</p></blockquote><p>继续查看/etc/profile文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># By default, we want umask to get set. This sets it for login shell</span></span><br><span class="line"><span class="comment"># Current threshold for system reserved uid/gids is 200</span></span><br><span class="line"><span class="comment"># You could check uidgid reservation validity in</span></span><br><span class="line"><span class="comment"># /usr/share/doc/setup-*/uidgid file</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$UID</span> -gt 199 ] &amp;&amp; [ <span class="string">&quot;`/usr/bin/id -gn`&quot;</span> = <span class="string">&quot;`/usr/bin/id -un`&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">umask</span> 002</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">umask</span> 022</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh /etc/profile.d/sh.local ; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -r <span class="string">&quot;<span class="variable">$i</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;-#*i&#125;</span>&quot;</span> != <span class="string">&quot;$-&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            . <span class="string">&quot;<span class="variable">$i</span>&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            . <span class="string">&quot;<span class="variable">$i</span>&quot;</span> &gt;/dev/null</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> i</span><br><span class="line"><span class="built_in">unset</span> -f pathmunge</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>其也会加载到profile.d中.sh后缀文件</p></blockquote><p>那么综上，整理profile与profile.d的区别</p><ul><li> 两个文件都是设置环境变量文件的，/etc/profile是永久性的环境变量,是全局变量，/etc/profile.d/设置所有 用户生效</li><li>/etc/profile.d/比/etc/profile好维护，不想要什么变量直接删除/etc/profile.d/下对应的shell脚本即可，不用 像/etc/profile需要改动此文件 </li></ul><blockquote><p>[<a href="https://blog.csdn.net/qq_36522306/article/details/94616769]">https://blog.csdn.net/qq_36522306/article/details/94616769]</a>: </p></blockquote><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><blockquote><p>加入需要任意地方启动/XX/XX/XX中的.sh脚本</p></blockquote><h2 id="1、直接在命令行中设置PATH"><a href="#1、直接在命令行中设置PATH" class="headerlink" title="1、直接在命令行中设置PATH"></a>1、直接在命令行中设置PATH</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> PATH=<span class="variable">$PATH</span>:/XX/XX/XX</span></span><br></pre></td></tr></table></figure><blockquote><p> 使用这种方法,只对当前会话有效，也就是说每当登出或注销系统以后，PATH设置就会失效。 </p></blockquote><h2 id="2、在profile中设置PATH"><a href="#2、在profile中设置PATH" class="headerlink" title="2、在profile中设置PATH"></a>2、在profile中设置PATH</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p> 找到export行，在下面新增加一行，内容为： </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/XX/XX/XX</span><br></pre></td></tr></table></figure><p>最后命令行中输入：source profile命令使得PATH的修改立马生效</p><h2 id="3、在当前用户的profile中设置PATH"><a href="#3、在当前用户的profile中设置PATH" class="headerlink" title="3、在当前用户的profile中设置PATH"></a>3、在当前用户的profile中设置PATH</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p> 修改PATH行,把/XX/XX/XX添加进去,如 :</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PATH=$PATH:$HOME/bin:/XX/XX/XX。</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">source</span> ~/.bash_profile</span></span><br></pre></td></tr></table></figure><p> 让这次的修改生效。</p><blockquote><p>这种方法只对当前用户起作用的,其他用户该修改无效</p></blockquote><h2 id="4、在profile-d中设置PATH"><a href="#4、在profile-d中设置PATH" class="headerlink" title="4、在profile.d中设置PATH"></a>4、在profile.d中设置PATH</h2><p>对于/XX/XX/XX中某个XX.sh脚本（/XX/XX/XX/XX.sh）</p><p>在profile.d中创建一个新的文件，如env.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir env.sh</span><br></pre></td></tr></table></figure><p>在其中加入/XX/XX/XX路径</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/XX/XX/XX</span><br></pre></td></tr></table></figure><p>以后在/XX/XX/XX中的任意XX.sh脚本，均可在任意位置执行XX命令执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;今天在执行.sh脚本文件时，发现必须在脚本所在的路径下才可执行，找到方法可以在任意目录下启动脚本，在此记录&lt;/p&gt;
&lt;p&gt;[&lt;a href=&quot;https://blog.csdn.net/qq_16633405/article/details/820</summary>
      
    
    
    
    <category term="脚本" scheme="https://www.gtxhjh.cn/categories/%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="脚本" scheme="https://www.gtxhjh.cn/tags/%E8%84%9A%E6%9C%AC/"/>
    
    <category term="linux" scheme="https://www.gtxhjh.cn/tags/linux/"/>
    
  </entry>
  
</feed>
